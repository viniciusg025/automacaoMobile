// src/util.ts
import { hostname as hostname2, platform as platform2, type as type2, version as version2, arch as arch2, tmpdir } from "node:os";
import crypto from "node:crypto";
import fs4 from "node:fs";
import zlib from "node:zlib";
import { format, promisify } from "node:util";
import path4 from "node:path";
import util2 from "node:util";
import gitRepoInfo from "git-repo-info";
import gitconfig from "gitconfiglocal";
import { FormData } from "formdata-node";
import { performance as performance2 } from "node:perf_hooks";

// src/logPatcher.ts
import Transport from "winston-transport";
var LOG_LEVELS = {
  INFO: "INFO",
  ERROR: "ERROR",
  DEBUG: "DEBUG",
  TRACE: "TRACE",
  WARN: "WARN"
};
var logPatcher = class extends Transport {
  logToTestOps = (level = LOG_LEVELS.INFO, message = [""]) => {
    process.emit(`bs:addLog:${process.pid}`, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: level.toUpperCase(),
      message: `"${message.join(", ")}"`,
      kind: "TEST_LOG",
      http_response: {}
    });
  };
  /* Patching this would show user an extended trace on their cli */
  trace = (...message) => {
    this.logToTestOps(LOG_LEVELS.TRACE, message);
  };
  debug = (...message) => {
    this.logToTestOps(LOG_LEVELS.DEBUG, message);
  };
  info = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
  warn = (...message) => {
    this.logToTestOps(LOG_LEVELS.WARN, message);
  };
  error = (...message) => {
    this.logToTestOps(LOG_LEVELS.ERROR, message);
  };
  log = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
};
var logPatcher_default = logPatcher;

// src/instrumentation/performance/performance-tester.ts
import { createObjectCsvWriter } from "csv-writer";
import fs2 from "node:fs";
import fsPromise from "node:fs/promises";
import { performance, PerformanceObserver } from "node:perf_hooks";
import util from "node:util";
import worker from "node:worker_threads";
import path2 from "node:path";
import { arch, hostname, platform, type, version } from "node:os";

// src/bstackLogger.ts
import path from "node:path";
import fs from "node:fs";
import chalk from "chalk";
import logger from "@wdio/logger";

// package.json
var package_default = {
  name: "@wdio/browserstack-service",
  version: "9.20.1",
  description: "WebdriverIO service for better Browserstack integration",
  author: "Adam Bjerstedt <abjerstedt@gmail.com>",
  homepage: "https://github.com/webdriverio/webdriverio/tree/main/packages/wdio-browserstack-service",
  license: "MIT",
  engines: {
    node: ">=18.20.0"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/webdriverio/webdriverio.git",
    directory: "packages/wdio-browserstack-service"
  },
  keywords: [
    "webdriverio",
    "wdio",
    "browserstack",
    "wdio-service"
  ],
  bugs: {
    url: "https://github.com/webdriverio/webdriverio/issues"
  },
  type: "module",
  types: "./build/index.d.ts",
  exports: {
    ".": {
      types: "./build/index.d.ts",
      import: "./build/index.js"
    },
    "./cleanup": {
      import: "./build/cleanup.js",
      source: "./src/cleanup.ts"
    }
  },
  typeScriptVersion: "3.8.3",
  dependencies: {
    "@browserstack/ai-sdk-node": "1.5.17",
    "@browserstack/wdio-browserstack-service": "^2.0.0",
    "@percy/appium-app": "^2.0.9",
    "@percy/selenium-webdriver": "^2.2.2",
    "@types/gitconfiglocal": "^2.0.1",
    "@wdio/logger": "workspace:*",
    "@wdio/reporter": "workspace:*",
    "@wdio/types": "workspace:*",
    "browserstack-local": "^1.5.1",
    chalk: "^5.3.0",
    "csv-writer": "^1.6.0",
    "formdata-node": "5.0.1",
    "git-repo-info": "^2.1.1",
    gitconfiglocal: "^2.1.0",
    undici: "^6.21.3",
    uuid: "^11.1.0",
    webdriverio: "workspace:*",
    "winston-transport": "^4.5.0",
    yauzl: "^3.0.0",
    tar: "^6.1.15"
  },
  peerDependencies: {
    "@wdio/cli": "^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0 || ^9.0.0"
  },
  devDependencies: {
    "@types/node": "^20.1.0",
    "@types/yauzl": "^2.10.3",
    "@types/tar": "^6.1.13",
    "@wdio/globals": "workspace:*"
  },
  publishConfig: {
    access: "public"
  }
};

// src/constants.ts
var bstackServiceVersion = package_default.version;
var consoleHolder = Object.assign({}, console);
var APP_ALLY_ISSUES_ENDPOINT = "api/v1/issues";
var APP_ALLY_ISSUES_SUMMARY_ENDPOINT = "api/v1/issues-summary";
var BSTACK_SERVICE_VERSION = bstackServiceVersion;
var LOGS_FILE = "logs/bstack-wdio-service.log";
var BROWSERSTACK_TESTHUB_JWT = "BROWSERSTACK_TESTHUB_JWT";
var TESTOPS_SCREENSHOT_ENV = "BS_TESTOPS_ALLOW_SCREENSHOTS";
var BROWSERSTACK_TESTHUB_UUID = "BROWSERSTACK_TESTHUB_UUID";
var PERF_MEASUREMENT_ENV = "BROWSERSTACK_O11Y_PERF_MEASUREMENT";
var RERUN_ENV = "BROWSERSTACK_RERUN";
var TESTOPS_BUILD_COMPLETED_ENV = "BS_TESTOPS_BUILD_COMPLETED";
var BROWSERSTACK_ACCESSIBILITY = "BROWSERSTACK_ACCESSIBILITY";
var BROWSERSTACK_OBSERVABILITY = "BROWSERSTACK_OBSERVABILITY";
var MAX_GIT_META_DATA_SIZE_IN_BYTES = 64 * 1024;
var GIT_META_DATA_TRUNCATED = "...[TRUNCATED]";
var WDIO_NAMING_PREFIX = "WebdriverIO-";
var PERF_METRICS_WAIT_TIME = 2e3;

// src/bstackLogger.ts
var log = logger("@wdio/browserstack-service");
var BStackLogger = class {
  static logFilePath = path.join(process.cwd(), LOGS_FILE);
  static logFolderPath = path.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        this.ensureLogsFolder();
        this.logFileStream = fs.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk[COLORS[level]](level.toUpperCase())} ${chalk.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log.debug(message, param);
    } else {
      log.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs.existsSync(this.logFilePath)) {
      fs.truncateSync(this.logFilePath);
    }
  }
  static ensureLogsFolder() {
    if (!fs.existsSync(this.logFolderPath)) {
      fs.mkdirSync(this.logFolderPath);
    }
  }
};

// src/cli/apiUtils.ts
var APIUtils = class {
  static FUNNEL_INSTRUMENTATION_URL = "https://api.browserstack.com/sdk/v1/event";
  static BROWSERSTACK_AUTOMATE_API_URL = "https://api.browserstack.com";
  static BROWSERSTACK_AA_API_URL = "https://api.browserstack.com";
  static BROWSERSTACK_PERCY_API_URL = "https://api.browserstack.com";
  static BROWSERSTACK_AUTOMATE_API_CLOUD_URL = "https://api-cloud.browserstack.com";
  static BROWSERSTACK_AA_API_CLOUD_URL = "https://api-cloud.browserstack.com";
  static APP_ALLY_ENDPOINT = "https://app-accessibility.browserstack.com/automate";
  static DATA_ENDPOINT = "https://collector-observability.browserstack.com";
  static UPLOAD_LOGS_ADDRESS = "https://upload-observability.browserstack.com";
  static EDS_URL = "https://eds.browserstack.com";
  static updateURLSForGRR(apis) {
    this.FUNNEL_INSTRUMENTATION_URL = `${apis.automate.api}/sdk/v1/event`;
    this.BROWSERSTACK_AUTOMATE_API_URL = apis.automate.api;
    this.BROWSERSTACK_AA_API_URL = apis.appAutomate.api;
    this.BROWSERSTACK_PERCY_API_URL = apis.percy.api;
    this.BROWSERSTACK_AUTOMATE_API_CLOUD_URL = apis.automate.upload;
    this.BROWSERSTACK_AA_API_CLOUD_URL = apis.appAutomate.upload;
    this.APP_ALLY_ENDPOINT = `${apis.appAccessibility.api}/automate`;
    this.DATA_ENDPOINT = apis.observability.api;
    this.UPLOAD_LOGS_ADDRESS = apis.observability.upload;
    this.EDS_URL = apis.edsInstrumentation.api;
  }
};

// src/fetchWrapper.ts
import { fetch as undiciFetch, ProxyAgent } from "undici";
var ResponseError = class extends Error {
  response;
  constructor(message, res) {
    super(message);
    this.response = res;
  }
};
async function fetchWrap(input, init) {
  const res = await _fetch(input, init);
  if (!res.ok) {
    throw new ResponseError(`Error response from server ${res.status}:  ${await res.text()}`, res);
  }
  return res;
}
function _fetch(input, init) {
  const proxyUrl = process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
  if (proxyUrl) {
    const noProxy = process.env.NO_PROXY && process.env.NO_PROXY.trim() ? process.env.NO_PROXY.trim().split(/[\s,;]+/) : [];
    const request = new Request(input);
    const url = new URL(request.url);
    if (!noProxy.some((str) => url.hostname.endsWith(str))) {
      return undiciFetch(
        request.url,
        { ...init, dispatcher: new ProxyAgent(proxyUrl) }
      );
    }
  }
  return fetch(input, init);
}

// src/instrumentation/performance/performance-tester.ts
var PerformanceTester = class _PerformanceTester {
  static _observer;
  static _csvWriter;
  static _events = [];
  static _measuredEvents = [];
  static started = false;
  static details = {};
  static eventsMap = {};
  static browser;
  static scenarioThatRan;
  static jsonReportDirName = "performance-report";
  static jsonReportDirPath = path2.join(process.cwd(), "logs", this.jsonReportDirName);
  static jsonReportFileName = `${this.jsonReportDirPath}/performance-report-${_PerformanceTester.getProcessId()}.json`;
  static startMonitoring(csvName = "performance-report.csv") {
    if (!fs2.existsSync(this.jsonReportDirPath)) {
      fs2.mkdirSync(this.jsonReportDirPath, { recursive: true });
    }
    this._observer = new PerformanceObserver((list) => {
      list.getEntries().filter((entry) => entry.entryType === "measure").forEach(
        (entry) => {
          let finalEntry = entry;
          finalEntry = entry.toJSON();
          if (this.details[entry.name]) {
            finalEntry = Object.assign(finalEntry, this.details[entry.name]);
          }
          delete this.details[entry.name];
          this._measuredEvents.push(finalEntry);
        }
      );
      if (process.env[PERF_MEASUREMENT_ENV]) {
        list.getEntries().forEach((entry) => this._events.push(entry));
      }
    });
    const entryTypes = ["measure"];
    if (process.env[PERF_MEASUREMENT_ENV]) {
      entryTypes.push("function");
    }
    this._observer.observe({ buffered: true, entryTypes });
    this.started = true;
    if (process.env[PERF_MEASUREMENT_ENV]) {
      this._csvWriter = createObjectCsvWriter({
        path: csvName,
        header: [
          { id: "name", title: "Function Name" },
          { id: "time", title: "Execution Time (ms)" }
        ]
      });
    }
  }
  static calculateTimes(methods) {
    const times = {};
    this._events.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
    });
    const timeTaken = methods.reduce((a, c) => {
      return times[c] + (a || 0);
    }, 0);
    BStackLogger.debug(`Time for ${methods} is ${timeTaken}`);
    return timeTaken;
  }
  static async stopAndGenerate(filename = "performance-own.html") {
    if (!this.started) {
      return;
    }
    await _PerformanceTester.sleep(PERF_METRICS_WAIT_TIME);
    try {
      const eventsJson = JSON.stringify(this._measuredEvents);
      const finalJSONStr = eventsJson.slice(1, -1) + ",";
      await fsPromise.appendFile(this.jsonReportFileName, finalJSONStr);
    } catch (er) {
      BStackLogger.debug(`Failed to write events of the worker to ${this.jsonReportFileName}: ${util.format(er)}`);
    }
    this._observer.disconnect();
    if (!process.env[PERF_MEASUREMENT_ENV]) {
      return;
    }
    await _PerformanceTester.sleep(PERF_METRICS_WAIT_TIME);
    this.started = false;
    this.generateCSV(this._events);
    const content = this.generateReport(this._events);
    const dir = path2.join(process.cwd(), filename);
    try {
      await fsPromise.writeFile(dir, content);
      BStackLogger.info(`Performance report is at ${path2}`);
    } catch (err) {
      BStackLogger.error(`Error in writing html ${util.format(err)}`);
    }
  }
  static generateReport(entries) {
    let html = "<!DOCTYPE html><html><head><title>Performance Report</title></head><body>";
    html += "<h1>Performance Report</h1>";
    html += "<table><thead><tr><th>Function Name</th><th>Duration (ms)</th></tr></thead><tbody>";
    entries.forEach((entry) => {
      html += `<tr><td>${entry.name}</td><td>${entry.duration}</td></tr>`;
    });
    html += "</tbody></table></body></html>";
    return html;
  }
  static generateCSV(entries) {
    const times = {};
    entries.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
      return {
        name: entry.name,
        time: entry.duration
      };
    });
    const dat = Object.entries(times).map(([key, value]) => {
      return {
        name: key,
        time: value
      };
    });
    this._csvWriter.writeRecords(dat).then(() => BStackLogger.info("Performance CSV report generated successfully")).catch((error) => console.error(error));
  }
  static Measure(label, details = {}) {
    const self = this;
    return (target, key, descriptor) => {
      const originalMethod = descriptor.value;
      if (descriptor.value) {
        descriptor.value = function(...args) {
          return _PerformanceTester.measure.apply(self, [label, originalMethod, { methodName: key.toString(), ...details }, args, this]);
        };
      }
    };
  }
  static measureWrapper(name, fn, details = {}) {
    const self = this;
    details.worker = _PerformanceTester.getProcessId();
    details.testName = _PerformanceTester.scenarioThatRan && _PerformanceTester.scenarioThatRan[_PerformanceTester.scenarioThatRan.length - 1];
    details.platform = _PerformanceTester.browser?.sessionId;
    return function(...args) {
      return self.measure(name, fn, details, args);
    };
  }
  static isEnabled() {
    return !(process.env.BROWSERSTACK_SDK_INSTRUMENTATION === "false");
  }
  static measure(label, fn, details = {}, args, thisArg = null) {
    if (!this.started || !this.isEnabled()) {
      return fn.apply(thisArg, args);
    }
    _PerformanceTester.start(label);
    if (this.details) {
      this.details[label] = details;
    }
    try {
      const returnVal = fn.apply(thisArg, args);
      if (returnVal instanceof Promise) {
        return new Promise((resolve, reject) => {
          returnVal.then((v) => {
            _PerformanceTester.end(label);
            resolve(v);
          }).catch((e) => {
            _PerformanceTester.end(label, false, util.format(e));
            reject(e);
          });
        });
      }
      _PerformanceTester.end(label);
      return returnVal;
    } catch (er) {
      _PerformanceTester.end(label, false, util.format(er));
      throw er;
    }
  }
  static start(event) {
    const finalEvent = event + "-start";
    if (this.eventsMap[finalEvent]) {
      return;
    }
    performance.mark(finalEvent);
    this.eventsMap[finalEvent] = 1;
  }
  static end(event, success = true, failure, details = {}) {
    performance.mark(event + "-end");
    performance.measure(event, event + "-start", event + "-end");
    this.details[event] = Object.assign({ success, failure: util.format(failure) }, Object.assign(Object.assign({
      worker: _PerformanceTester.getProcessId(),
      platform: _PerformanceTester.browser?.sessionId,
      testName: _PerformanceTester.scenarioThatRan && _PerformanceTester.scenarioThatRan[_PerformanceTester.scenarioThatRan.length - 1]
    }, details), this.details[event] || {}));
  }
  static getProcessId() {
    return `${process.pid}-${worker.threadId}`;
  }
  static sleep = (ms = 100) => new Promise((resolve) => setTimeout(resolve, ms));
  static async uploadEventsData() {
    try {
      let measures = [];
      if (await fsPromise.access(this.jsonReportDirPath).then(() => true).catch(() => false)) {
        const files = (await fsPromise.readdir(this.jsonReportDirPath)).map((file) => path2.resolve(this.jsonReportDirPath, file));
        measures = (await Promise.all(files.map((file) => fsPromise.readFile(file, "utf-8")))).map((el) => `[${el.slice(0, -1)}]`).map((el) => JSON.parse(el)).flat();
      }
      if (this._measuredEvents.length > 0) {
        measures = measures.concat(this._measuredEvents);
      }
      const date = /* @__PURE__ */ new Date();
      const options = {
        timeZone: "UTC",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        // To include microseconds
        hour12: false
      };
      const formattedDate = new Intl.DateTimeFormat("en-GB", options).formatToParts(date).map(({ type: type3, value }) => type3 === "timeZoneName" ? "Z" : value).join("").replace(",", "T");
      const payload = {
        event_type: "sdk_events",
        data: {
          testhub_uuid: process.env.PERF_TESTHUB_UUID || process.env.SDK_RUN_ID,
          created_day: formattedDate,
          event_name: "SDKFeaturePerformance",
          user_data: process.env.PERF_USER_NAME,
          host_info: JSON.stringify({
            hostname: hostname(),
            platform: platform(),
            type: type(),
            version: version(),
            arch: arch()
          }),
          event_json: { measures, sdkRunId: process.env.SDK_RUN_ID }
        }
      };
      const result = await fetchWrap(`${APIUtils.EDS_URL}/send_sdk_events`, {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      BStackLogger.debug(`Successfully uploaded performance events ${util.format(await result.text())}`);
    } catch (er) {
      BStackLogger.debug(`Failed to upload performance events ${util.format(er)}`);
    }
    try {
      if (await fsPromise.access(this.jsonReportDirPath).then(() => true, () => false)) {
        const files = await fsPromise.readdir(this.jsonReportDirPath);
        for (const file of files) {
          await fsPromise.unlink(path2.join(this.jsonReportDirPath, file));
        }
      }
    } catch (er) {
      BStackLogger.debug(`Failed to delete performance related files ${util.format(er)}`);
    }
  }
};

// src/instrumentation/performance/constants.ts
var EVENTS = {
  SDK_SETUP: "sdk:setup",
  SDK_CLEANUP: "sdk:cleanup",
  SDK_PRE_TEST: "sdk:pre-test",
  SDK_TEST: "sdk:test",
  SDK_POST_TEST: "sdk:post-test",
  SDK_HOOK: "sdk:hook",
  SDK_DRIVER: "sdk:driver",
  SDK_A11Y: "sdk:a11y",
  SDK_O11Y: "sdk:o11y",
  SDK_AUTO_CAPTURE: "sdk:auto-capture",
  SDK_PROXY_SETUP: "sdk:proxy-setup",
  SDK_TESTHUB: "sdk:testhub",
  SDK_AUTOMATE: "sdk:automate",
  SDK_APP_AUTOMATE: "sdk:app-automate",
  SDK_TURBOSCALE: "sdk:turboscale",
  SDK_PERCY: "sdk:percy",
  SDK_PRE_INITIALIZE: "sdk:driver:pre-initialization",
  SDK_POST_INITIALIZE: "sdk:driver:post-initialization",
  SDK_CLI_CHECK_UPDATE: "sdk:cli:check-update",
  SDK_CLI_DOWNLOAD: "sdk:cli:download",
  SDK_CLI_ON_BOOTSTRAP: "sdk:cli:on-bootstrap",
  SDK_CLI_ON_CONNECT: "sdk:cli:on-connect",
  SDK_CLI_START: "sdk:cli:start",
  SDK_CLI_ON_STOP: "sdk:cli:on-stop",
  SDK_CONNECT_BIN_SESSION: "sdk:connectBinSession",
  SDK_START_BIN_SESSION: "sdk:startBinSession"
};
var TESTHUB_EVENTS = {
  START: `${EVENTS.SDK_TESTHUB}:start`,
  STOP: `${EVENTS.SDK_TESTHUB}:stop`
};
var AUTOMATE_EVENTS = {
  KEEP_ALIVE: `${EVENTS.SDK_AUTOMATE}:keep-alive`,
  HUB_MANAGEMENT: `${EVENTS.SDK_AUTOMATE}:hub-management`,
  LOCAL_START: `${EVENTS.SDK_AUTOMATE}:local-start`,
  LOCAL_STOP: `${EVENTS.SDK_AUTOMATE}:local-stop`,
  DRIVER_MANAGE: `${EVENTS.SDK_AUTOMATE}:driver-manage`,
  SESSION_NAME: `${EVENTS.SDK_AUTOMATE}:session-name`,
  SESSION_STATUS: `${EVENTS.SDK_AUTOMATE}:session-status`,
  SESSION_ANNOTATION: `${EVENTS.SDK_AUTOMATE}:session-annotation`,
  IDLE_TIMEOUT: `${EVENTS.SDK_AUTOMATE}:idle-timeout`,
  GENERATE_CI_ARTIFACT: `${EVENTS.SDK_AUTOMATE}:ci-artifacts`,
  PRINT_BUILDLINK: `${EVENTS.SDK_AUTOMATE}:print-buildlink`
};
var A11Y_EVENTS = {
  PERFORM_SCAN: `${EVENTS.SDK_A11Y}:driver-performscan`,
  SAVE_RESULTS: `${EVENTS.SDK_A11Y}:save-results`,
  GET_RESULTS: `${EVENTS.SDK_A11Y}:get-accessibility-results`,
  GET_RESULTS_SUMMARY: `${EVENTS.SDK_A11Y}:get-accessibility-results-summary`
};
var PERCY_EVENTS = {
  DOWNLOAD: `${EVENTS.SDK_PERCY}:download`,
  SCREENSHOT: `${EVENTS.SDK_PERCY}:screenshot`,
  START: `${EVENTS.SDK_PERCY}:start`,
  STOP: `${EVENTS.SDK_PERCY}:stop`,
  AUTO_CAPTURE: `${EVENTS.SDK_PERCY}:auto-capture`,
  SNAPSHOT: `${EVENTS.SDK_PERCY}:snapshot`,
  SCREENSHOT_APP: `${EVENTS.SDK_PERCY}:screenshot-app`
};
var O11Y_EVENTS = {
  SYNC: `${EVENTS.SDK_O11Y}:sync`,
  TAKE_SCREENSHOT: `${EVENTS.SDK_O11Y}:driver-takeScreenShot`,
  PRINT_BUILDLINK: `${EVENTS.SDK_O11Y}:print-buildlink`
};
var HOOK_EVENTS = {
  BEFORE_EACH: `${EVENTS.SDK_HOOK}:before-each`,
  AFTER_EACH: `${EVENTS.SDK_HOOK}:after-each`,
  AFTER_ALL: `${EVENTS.SDK_HOOK}:after-all`,
  BEFORE_ALL: `${EVENTS.SDK_HOOK}:before-all`,
  BEFORE: `${EVENTS.SDK_HOOK}:before`,
  AFTER: `${EVENTS.SDK_HOOK}:after`
};
var TURBOSCALE_EVENTS = {
  HUB_MANAGEMENT: `${EVENTS.SDK_TURBOSCALE}:hub-management`,
  PRINT_BUILDLINK: `${EVENTS.SDK_TURBOSCALE}:print-buildlink`
};
var APP_AUTOMATE_EVENTS = {
  APP_UPLOAD: `${EVENTS.SDK_APP_AUTOMATE}:app-upload`
};
var DRIVER_EVENT = {
  QUIT: `${EVENTS.SDK_DRIVER}:quit`,
  GET: `${EVENTS.SDK_DRIVER}:get`,
  PRE_EXECUTE: `${EVENTS.SDK_DRIVER}:pre-execute`,
  POST_EXECUTE: `${EVENTS.SDK_DRIVER}:post-execute`
};

// src/testHub/utils.ts
var handleErrorForObservability = (error) => {
  process.env[BROWSERSTACK_OBSERVABILITY] = "false";
  logBuildError(error, "Test Reporting and Analytics");
};
var handleErrorForAccessibility = (error) => {
  process.env[BROWSERSTACK_ACCESSIBILITY] = "false";
  logBuildError(error, "accessibility");
};
var logBuildError = (error, product = "") => {
  if (!error || !error.errors) {
    BStackLogger.error(`${product.toUpperCase()} Build creation failed ${error}`);
    return;
  }
  for (const errorJson of error.errors) {
    const errorType = errorJson.key;
    const errorMessage = errorJson.message;
    if (errorMessage) {
      switch (errorType) {
        case "ERROR_INVALID_CREDENTIALS":
          BStackLogger.error(errorMessage);
          break;
        case "ERROR_ACCESS_DENIED":
          BStackLogger.info(errorMessage);
          break;
        case "ERROR_SDK_DEPRECATED":
          BStackLogger.error(errorMessage);
          break;
        default:
          BStackLogger.error(errorMessage);
      }
    }
  }
};
var getProductMapForBuildStartCall = (config, accessibilityAutomation) => {
  return {
    observability: config.testObservability.enabled,
    accessibility: accessibilityAutomation,
    percy: config.percy,
    automate: config.automate,
    app_automate: config.appAutomate
  };
};

// src/crash-reporter.ts
var CrashReporter = class {
  /* User test config for build run minus PII */
  static userConfigForReporting = {};
  /* User credentials used for reporting crashes in browserstack service */
  static credentialsForCrashReportUpload = {};
  static setCredentialsForCrashReportUpload(options, config) {
    this.credentialsForCrashReportUpload = {
      username: getObservabilityUser(options, config),
      password: getObservabilityKey(options, config)
    };
    process.env.CREDENTIALS_FOR_CRASH_REPORTING = JSON.stringify(this.credentialsForCrashReportUpload);
  }
  static setConfigDetails(userConfig, capabilities, options) {
    const configWithoutPII = this.filterPII(userConfig);
    const filteredCapabilities = this.filterCapabilities(capabilities);
    this.userConfigForReporting = {
      framework: userConfig.framework,
      services: configWithoutPII.services,
      capabilities: filteredCapabilities,
      env: {
        "BROWSERSTACK_BUILD": process.env.BROWSERSTACK_BUILD,
        "BROWSERSTACK_BUILD_NAME": process.env.BROWSERSTACK_BUILD_NAME,
        "BUILD_TAG": process.env.BUILD_TAG
      }
    };
    process.env.USER_CONFIG_FOR_REPORTING = JSON.stringify(this.userConfigForReporting);
    this.setCredentialsForCrashReportUpload(options, userConfig);
  }
  static async uploadCrashReport(exception, stackTrace) {
    try {
      if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
        this.credentialsForCrashReportUpload = process.env.CREDENTIALS_FOR_CRASH_REPORTING !== void 0 ? JSON.parse(process.env.CREDENTIALS_FOR_CRASH_REPORTING) : this.credentialsForCrashReportUpload;
      }
    } catch (error) {
      return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user credentials while reporting crash due to ${error}`);
    }
    if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
      return BStackLogger.error("[Crash_Report_Upload] Failed to parse user credentials while reporting crash");
    }
    try {
      if (Object.keys(this.userConfigForReporting).length === 0) {
        this.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
      }
    } catch (error) {
      BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while reporting crash due to ${error}`);
      this.userConfigForReporting = {};
    }
    const data = {
      hashed_id: process.env[BROWSERSTACK_TESTHUB_UUID],
      observability_version: {
        frameworkName: WDIO_NAMING_PREFIX + (this.userConfigForReporting.framework || "null"),
        sdkVersion: BSTACK_SERVICE_VERSION
      },
      exception: {
        error: exception.toString(),
        stackTrace
      },
      config: this.userConfigForReporting
    };
    const url = `${APIUtils.DATA_ENDPOINT}/api/v1/analytics`;
    const encodedAuth = Buffer.from(`${this.credentialsForCrashReportUpload.username}:${this.credentialsForCrashReportUpload.password}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await _fetch(url, {
      method: "POST",
      body: JSON.stringify(data),
      headers
    });
    if (response.ok) {
      BStackLogger.debug(`[Crash_Report_Upload] Success response: ${JSON.stringify(await response.json())}`);
    } else {
      BStackLogger.error(`[Crash_Report_Upload] Failed due to ${response.body}`);
    }
  }
  static recursivelyRedactKeysFromObject(obj, keys) {
    if (!obj) {
      return;
    }
    if (Array.isArray(obj)) {
      obj.map((ele) => this.recursivelyRedactKeysFromObject(ele, keys));
    } else {
      for (const prop in obj) {
        if (keys.includes(prop.toLowerCase())) {
          obj[prop] = "[REDACTED]";
        } else if (typeof obj[prop] === "object") {
          this.recursivelyRedactKeysFromObject(obj[prop], keys);
        }
      }
    }
  }
  static deletePIIKeysFromObject(obj) {
    if (!obj) {
      return;
    }
    ["user", "username", "key", "accessKey"].forEach((key) => delete obj[key]);
  }
  static filterCapabilities(capabilities) {
    const capsCopy = JSON.parse(JSON.stringify(capabilities));
    this.recursivelyRedactKeysFromObject(capsCopy, ["extensions"]);
    return capsCopy;
  }
  static filterPII(userConfig) {
    const configWithoutPII = JSON.parse(JSON.stringify(userConfig));
    this.deletePIIKeysFromObject(configWithoutPII);
    const finalServices = [];
    const initialServices = configWithoutPII.services;
    delete configWithoutPII.services;
    try {
      for (const serviceArray of initialServices) {
        if (Array.isArray(serviceArray) && serviceArray.length >= 2 && serviceArray[0] === "browserstack") {
          for (let idx = 1; idx < serviceArray.length; idx++) {
            this.deletePIIKeysFromObject(serviceArray[idx]);
            if (serviceArray[idx]) {
              this.deletePIIKeysFromObject(serviceArray[idx].testReportingOptions);
              this.deletePIIKeysFromObject(serviceArray[idx].testObservabilityOptions);
            }
          }
          finalServices.push(serviceArray);
          break;
        }
      }
    } catch (err) {
      BStackLogger.error(`Error in parsing user config PII with error ${err ? err.stack || err : err}`);
      return configWithoutPII;
    }
    configWithoutPII.services = finalServices;
    return configWithoutPII;
  }
};

// src/testOps/featureStats.ts
var FeatureStats = class _FeatureStats {
  triggeredCount = 0;
  sentCount = 0;
  failedCount = 0;
  groups = {};
  mark(status, groupId) {
    switch (status) {
      case "triggered":
        this.triggered(groupId);
        break;
      case "success":
      case "sent":
        this.sent(groupId);
        break;
      case "failed":
        this.failed(groupId);
        break;
      default:
        BStackLogger.debug("Request to mark usage for unknown status - " + status);
        break;
    }
  }
  triggered(groupId) {
    this.triggeredCount += 1;
    if (groupId) {
      this.createGroup(groupId).triggered();
    }
  }
  sent(groupId) {
    this.sentCount += 1;
    if (groupId) {
      this.createGroup(groupId).sent();
    }
  }
  failed(groupId) {
    this.failedCount += 1;
    if (groupId) {
      this.createGroup(groupId).failed();
    }
  }
  success(groupId) {
    this.sent(groupId);
  }
  createGroup(groupId) {
    if (!this.groups[groupId]) {
      this.groups[groupId] = new _FeatureStats();
    }
    return this.groups[groupId];
  }
  getTriggeredCount() {
    return this.triggeredCount;
  }
  getSentCount() {
    return this.sentCount;
  }
  getFailedCount() {
    return this.failedCount;
  }
  getUsageForGroup(groupId) {
    return this.groups[groupId] || new _FeatureStats();
  }
  getOverview() {
    return { triggeredCount: this.triggeredCount, sentCount: this.sentCount, failedCount: this.failedCount };
  }
  getGroups() {
    return this.groups;
  }
  add(featureStats) {
    this.triggeredCount += featureStats.getTriggeredCount();
    this.sentCount += featureStats.getSentCount();
    this.failedCount += featureStats.getFailedCount();
    Object.entries(featureStats.getGroups()).forEach(([groupId, group]) => {
      this.createGroup(groupId).add(group);
    });
  }
  // omitGroups: true/false -> Include groups or not
  // onlyGroups: true/false -> data includes only groups
  // nestedGroups: true/false -> groups will be nested in groups if true
  toJSON(config = {}) {
    const overviewData = !config.onlyGroups ? {
      triggeredCount: this.triggeredCount,
      sentCount: this.sentCount,
      failedCount: this.failedCount
    } : {};
    const groupsData = {};
    if (!config.omitGroups) {
      Object.entries(this.groups).forEach(([groupId, group2]) => {
        groupsData[groupId] = group2.toJSON();
      });
    }
    const group = config.nestedGroups ? { groups: groupsData } : groupsData;
    return {
      ...overviewData,
      ...group
    };
  }
  static fromJSON(json) {
    const stats = new _FeatureStats();
    if (!json || isObjectEmpty(json)) {
      return stats;
    }
    stats.triggeredCount = json.triggeredCount;
    stats.sentCount = json.sentCount;
    stats.failedCount = json.failedCount;
    if (!json.groups) {
      return stats;
    }
    Object.entries(json.groups).forEach(([groupId, group]) => {
      stats.groups[groupId] = _FeatureStats.fromJSON(group);
    });
    return stats;
  }
};
var featureStats_default = FeatureStats;

// src/testOps/featureUsage.ts
var FeatureUsage = class {
  isTriggered;
  status;
  error;
  constructor(isTriggered) {
    if (isTriggered !== void 0) {
      this.isTriggered = isTriggered;
    }
  }
  getTriggered() {
    return this.isTriggered;
  }
  setTriggered(triggered) {
    this.isTriggered = triggered;
  }
  setStatus(status) {
    this.status = status;
  }
  setError(error) {
    this.error = error;
  }
  triggered() {
    this.isTriggered = true;
  }
  failed(e) {
    this.status = "failed";
    this.error = getErrorString(e);
  }
  success() {
    this.status = "success";
  }
  getStatus() {
    return this.status;
  }
  getError() {
    return this.error;
  }
  toJSON() {
    return {
      isTriggered: this.isTriggered,
      status: this.status,
      error: this.error
    };
  }
};
var featureUsage_default = FeatureUsage;

// src/testOps/testOpsConfig.ts
var TestOpsConfig = class _TestOpsConfig {
  constructor(enabled = true, manuallySet = false) {
    this.enabled = enabled;
    this.manuallySet = manuallySet;
    _TestOpsConfig._instance = this;
  }
  static _instance;
  buildStopped = false;
  buildHashedId;
  static getInstance(...args) {
    if (!this._instance) {
      this._instance = new _TestOpsConfig(...args);
    }
    return this._instance;
  }
};
var testOpsConfig_default = TestOpsConfig;

// src/testOps/usageStats.ts
var UsageStats = class _UsageStats {
  static instance;
  testStartedStats;
  testFinishedStats;
  hookStartedStats;
  hookFinishedStats;
  cbtSessionStats;
  logStats;
  launchBuildUsage;
  stopBuildUsage;
  static getInstance() {
    if (!_UsageStats.instance) {
      _UsageStats.instance = new _UsageStats();
    }
    return _UsageStats.instance;
  }
  constructor() {
    this.testStartedStats = new featureStats_default();
    this.testFinishedStats = new featureStats_default();
    this.hookStartedStats = new featureStats_default();
    this.hookFinishedStats = new featureStats_default();
    this.cbtSessionStats = new featureStats_default();
    this.logStats = new featureStats_default();
    this.launchBuildUsage = new featureUsage_default();
    this.stopBuildUsage = new featureUsage_default();
  }
  add(usageStats) {
    this.testStartedStats.add(usageStats.testStartedStats);
    this.testFinishedStats.add(usageStats.testFinishedStats);
    this.hookStartedStats.add(usageStats.hookStartedStats);
    this.hookFinishedStats.add(usageStats.hookFinishedStats);
    this.cbtSessionStats.add(usageStats.cbtSessionStats);
    this.logStats.add(usageStats.logStats);
  }
  getFormattedData(workersData) {
    this.addDataFromWorkers(workersData);
    const testOpsConfig = testOpsConfig_default.getInstance();
    const usage = {
      enabled: testOpsConfig.enabled,
      manuallySet: testOpsConfig.manuallySet,
      buildHashedId: testOpsConfig.buildHashedId
    };
    if (!usage.enabled) {
      return usage;
    }
    try {
      usage.events = this.getEventsData();
    } catch (e) {
      BStackLogger.debug("exception in getFormattedData: " + e);
    }
    return usage;
  }
  addDataFromWorkers(workersData) {
    workersData.map((workerData) => {
      try {
        const usageStatsForWorker = _UsageStats.fromJSON(workerData.usageStats);
        this.add(usageStatsForWorker);
      } catch (e) {
        BStackLogger.debug("Exception in adding workerData: " + e);
      }
    });
  }
  getEventsData() {
    return {
      buildEvents: {
        started: this.launchBuildUsage.toJSON(),
        finished: this.stopBuildUsage.toJSON()
      },
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ omitGroups: true }),
        ...this.testFinishedStats.toJSON({ onlyGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ omitGroups: true }),
        ...this.hookFinishedStats.toJSON({ onlyGroups: true })
      },
      logEvents: this.logStats.toJSON(),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  getDataToSave() {
    return {
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ nestedGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ nestedGroups: true })
      },
      logEvents: this.logStats.toJSON({ nestedGroups: true }),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  static fromJSON(data) {
    const usageStats = new _UsageStats();
    usageStats.testStartedStats = featureStats_default.fromJSON(data.testEvents.started);
    usageStats.testFinishedStats = featureStats_default.fromJSON(data.testEvents.finished);
    usageStats.hookStartedStats = featureStats_default.fromJSON(data.hookEvents.started);
    usageStats.hookFinishedStats = featureStats_default.fromJSON(data.hookEvents.finished);
    usageStats.logStats = featureStats_default.fromJSON(data.logEvents);
    usageStats.cbtSessionStats = featureStats_default.fromJSON(data.cbtSessionStats);
    return usageStats;
  }
};
var usageStats_default = UsageStats;

// src/util.ts
import tar from "tar";
import { fileFromPath } from "formdata-node/file-from-path";

// src/scripts/accessibility-scripts.ts
import path3 from "node:path";
import fs3 from "node:fs";
import os from "node:os";
var AccessibilityScripts = class _AccessibilityScripts {
  static instance = null;
  performScan = null;
  getResults = null;
  getResultsSummary = null;
  saveTestResults = null;
  commandsToWrap = null;
  ChromeExtension = {};
  browserstackFolderPath = "";
  commandsPath = "";
  // don't allow to create instances from it other than through `checkAndGetInstance`
  constructor() {
    this.browserstackFolderPath = this.getWritableDir();
    this.commandsPath = path3.join(this.browserstackFolderPath, "commands.json");
  }
  static checkAndGetInstance() {
    if (!_AccessibilityScripts.instance) {
      _AccessibilityScripts.instance = new _AccessibilityScripts();
      _AccessibilityScripts.instance.readFromExistingFile();
    }
    return _AccessibilityScripts.instance;
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  getWritableDir() {
    const orderedPaths = [
      path3.join(os.homedir(), ".browserstack"),
      process.cwd(),
      os.tmpdir()
    ];
    for (const orderedPath of orderedPaths) {
      try {
        if (fs3.existsSync(orderedPath)) {
          fs3.accessSync(orderedPath);
          return orderedPath;
        }
        fs3.mkdirSync(orderedPath, { recursive: true });
        return orderedPath;
      } catch (error) {
      }
    }
    return "";
  }
  readFromExistingFile() {
    try {
      if (fs3.existsSync(this.commandsPath)) {
        const data = fs3.readFileSync(this.commandsPath, "utf8");
        if (data) {
          this.update(JSON.parse(data));
        }
      }
    } catch {
    }
  }
  update(data) {
    if (data.scripts) {
      this.performScan = data.scripts.scan;
      this.getResults = data.scripts.getResults;
      this.getResultsSummary = data.scripts.getResultsSummary;
      this.saveTestResults = data.scripts.saveResults;
    }
    if (data.commands && data.commands.length) {
      this.commandsToWrap = data.commands;
    }
    if (data.nonBStackInfraA11yChromeOptions) {
      this.ChromeExtension = data.nonBStackInfraA11yChromeOptions;
    }
  }
  store() {
    if (!fs3.existsSync(this.browserstackFolderPath)) {
      fs3.mkdirSync(this.browserstackFolderPath);
    }
    fs3.writeFileSync(this.commandsPath, JSON.stringify({
      commands: this.commandsToWrap,
      scripts: {
        scan: this.performScan,
        getResults: this.getResults,
        getResultsSummary: this.getResultsSummary,
        saveResults: this.saveTestResults
      },
      nonBStackInfraA11yChromeOptions: this.ChromeExtension
    }));
  }
};
var accessibility_scripts_default = AccessibilityScripts.checkAndGetInstance();

// src/util.ts
var pGitconfig = promisify(gitconfig);
var DEFAULT_REQUEST_CONFIG = {
  headers: {
    "Content-Type": "application/json",
    "X-BSTACK-OBS": "true"
  }
};
var COLORS = {
  error: "red",
  warn: "yellow",
  info: "cyanBright",
  debug: "green",
  trace: "cyan",
  progress: "magenta"
};
function processError(error, fn, args) {
  BStackLogger.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
  let argsString;
  try {
    argsString = JSON.stringify(args);
  } catch {
    argsString = util2.inspect(args, { depth: 2 });
  }
  CrashReporter.uploadCrashReport(`Error in executing ${fn.name} with args ${argsString} : ${error}`, error && error.stack || "unknown error");
}
function o11yErrorHandler(fn) {
  return function(...args) {
    try {
      let functionToHandle = fn;
      if (process.env[PERF_MEASUREMENT_ENV]) {
        functionToHandle = performance2.timerify(functionToHandle);
      }
      const result = functionToHandle(...args);
      if (result instanceof Promise) {
        return result.catch((error) => processError(error, fn, args));
      }
      return result;
    } catch (error) {
      processError(error, fn, args);
    }
  };
}
var processTestObservabilityResponse = (response) => {
  if (!response.observability) {
    handleErrorForObservability(null);
    return;
  }
  if (!response.observability.success) {
    handleErrorForObservability(response.observability);
    return;
  }
  process.env[BROWSERSTACK_OBSERVABILITY] = "true";
  if (response.observability.options.allow_screenshots) {
    process.env[TESTOPS_SCREENSHOT_ENV] = response.observability.options.allow_screenshots.toString();
  }
};
var jsonifyAccessibilityArray = (dataArray, keyName, valueName) => {
  const result = {};
  dataArray.forEach((element) => {
    result[element[keyName]] = element[valueName];
  });
  return result;
};
var processAccessibilityResponse = (response, options) => {
  if (!response.accessibility) {
    if (options.accessibility === true) {
      handleErrorForAccessibility(null);
    }
    return;
  }
  if (!response.accessibility.success) {
    handleErrorForAccessibility(response.accessibility);
    return;
  }
  if (response.accessibility.options) {
    const { accessibilityToken, pollingTimeout, scannerVersion } = jsonifyAccessibilityArray(response.accessibility.options.capabilities, "name", "value");
    const result = jsonifyAccessibilityArray(response.accessibility.options.capabilities, "name", "value");
    const scriptsJson = {
      "scripts": jsonifyAccessibilityArray(response.accessibility.options.scripts, "name", "command"),
      "commands": response.accessibility.options.commandsToWrap?.commands ?? [],
      "nonBStackInfraA11yChromeOptions": result["goog:chromeOptions"]
    };
    if (scannerVersion) {
      process.env.BSTACK_A11Y_SCANNER_VERSION = scannerVersion;
      BStackLogger.debug(`Accessibility scannerVersion ${scannerVersion}`);
    }
    if (accessibilityToken) {
      process.env.BSTACK_A11Y_JWT = accessibilityToken;
      process.env[BROWSERSTACK_ACCESSIBILITY] = "true";
    }
    if (pollingTimeout) {
      process.env.BSTACK_A11Y_POLLING_TIMEOUT = pollingTimeout;
    }
    if (scriptsJson) {
      accessibility_scripts_default.update(scriptsJson);
      accessibility_scripts_default.store();
    }
  }
};
var processLaunchBuildResponse = (response, options) => {
  if (options.testObservability) {
    processTestObservabilityResponse(response);
  }
  processAccessibilityResponse(response, options);
};
var launchTestSession = PerformanceTester.measureWrapper(TESTHUB_EVENTS.START, o11yErrorHandler(async function launchTestSession2(options, config, bsConfig, bStackConfig, accessibilityAutomation) {
  const launchBuildUsage = usageStats_default.getInstance().launchBuildUsage;
  launchBuildUsage.triggered();
  const data = {
    format: "json",
    project_name: getObservabilityProject(options, bsConfig.projectName),
    name: getObservabilityBuild(options, bsConfig.buildName),
    build_identifier: bsConfig.buildIdentifier,
    started_at: (/* @__PURE__ */ new Date()).toISOString(),
    tags: getObservabilityBuildTags(options, bsConfig.buildTag),
    host_info: {
      hostname: hostname2(),
      platform: platform2(),
      type: type2(),
      version: version2(),
      arch: arch2()
    },
    ci_info: getCiInfo(),
    build_run_identifier: process.env.BROWSERSTACK_BUILD_RUN_IDENTIFIER,
    failed_tests_rerun: process.env[RERUN_ENV] || false,
    version_control: await getGitMetaData(),
    accessibility: {
      settings: options.accessibilityOptions
    },
    browserstackAutomation: shouldAddServiceVersion(config, options.testObservability),
    framework_details: {
      frameworkName: WDIO_NAMING_PREFIX + config.framework,
      frameworkVersion: bsConfig.bstackServiceVersion,
      sdkVersion: bsConfig.bstackServiceVersion,
      language: "ECMAScript",
      testFramework: {
        name: "WebdriverIO",
        version: bsConfig.bstackServiceVersion
      }
    },
    product_map: getProductMapForBuildStartCall(bStackConfig, accessibilityAutomation),
    config: {}
  };
  if (accessibilityAutomation && (isTurboScale(options) || data.browserstackAutomation === false)) {
    data.accessibility.settings ??= {};
    data.accessibility.settings["includeEncodedExtension"] = true;
  }
  try {
    if (Object.keys(CrashReporter.userConfigForReporting).length === 0) {
      CrashReporter.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
    }
  } catch (error) {
    return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while sending build start event due to ${error}`);
  }
  data.config = CrashReporter.userConfigForReporting;
  try {
    const url = `${APIUtils.DATA_ENDPOINT}/api/v2/builds`;
    const encodedAuth = Buffer.from(`${getObservabilityUser(options, config)}:${getObservabilityKey(options, config)}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await _fetch(url, {
      method: "POST",
      headers,
      body: JSON.stringify(data)
    });
    const jsonResponse = await response.json();
    delete data?.accessibility?.settings?.includeEncodedExtension;
    BStackLogger.debug(`[Start_Build] Success response: ${JSON.stringify(jsonResponse)}`);
    process.env[TESTOPS_BUILD_COMPLETED_ENV] = "true";
    if (jsonResponse.jwt) {
      process.env[BROWSERSTACK_TESTHUB_JWT] = jsonResponse.jwt;
    }
    if (jsonResponse.build_hashed_id) {
      process.env[BROWSERSTACK_TESTHUB_UUID] = jsonResponse.build_hashed_id;
      testOpsConfig_default.getInstance().buildHashedId = jsonResponse.build_hashed_id;
      BStackLogger.info(`Testhub started with id: ${testOpsConfig_default.getInstance()?.buildHashedId}`);
    }
    processLaunchBuildResponse(jsonResponse, options);
    launchBuildUsage.success();
    return jsonResponse;
  } catch (error) {
    BStackLogger.debug(`TestHub build start failed: ${format(error)}`);
    if (!error.success) {
      launchBuildUsage.failed(error);
      logBuildError(error);
      return null;
    }
  }
}));
var isAccessibilityAutomationSession = (accessibilityFlag) => {
  try {
    const hasA11yJwtToken = typeof process.env.BSTACK_A11Y_JWT === "string" && process.env.BSTACK_A11Y_JWT.length > 0 && process.env.BSTACK_A11Y_JWT !== "null" && process.env.BSTACK_A11Y_JWT !== "undefined";
    return accessibilityFlag && hasA11yJwtToken;
  } catch (error) {
    BStackLogger.debug(`Exception in verifying the Accessibility session with error : ${error}`);
  }
  return false;
};
var isAppAccessibilityAutomationSession = (accessibilityFlag, isAppAutomate) => {
  const accessibilityAutomation = isAccessibilityAutomationSession(accessibilityFlag);
  return accessibilityAutomation && isAppAutomate;
};
var formatString = (template, ...values) => {
  let i = 0;
  if (template === null) {
    return "";
  }
  return template.replace(/%s/g, () => {
    const value = values[i++];
    return value !== null && value !== void 0 ? value : "";
  });
};
var _getParamsForAppAccessibility = (commandName) => {
  return {
    "thTestRunUuid": process.env.TEST_ANALYTICS_ID,
    "thBuildUuid": process.env.BROWSERSTACK_TESTHUB_UUID,
    "thJwtToken": process.env.BROWSERSTACK_TESTHUB_JWT,
    "authHeader": process.env.BSTACK_A11Y_JWT,
    "scanTimestamp": Date.now(),
    "method": commandName
  };
};
var performA11yScan = async (isAppAutomate, browser, isBrowserStackSession, isAccessibility, commandName) => {
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot perform Accessibility scan.");
    return;
  }
  try {
    if (isAppAccessibilityAutomationSession(isAccessibility, isAppAutomate)) {
      const results = await browser.execute(formatString(accessibility_scripts_default.performScan, JSON.stringify(_getParamsForAppAccessibility(commandName))), {});
      BStackLogger.debug(util2.format(results));
      return results;
    }
    if (accessibility_scripts_default.performScan) {
      const results = await executeAccessibilityScript(browser, accessibility_scripts_default.performScan, { method: commandName || "" });
      return results;
    }
    BStackLogger.error("AccessibilityScripts.performScan is null");
    return;
  } catch (err) {
    BStackLogger.error("Accessibility Scan could not be performed : " + err);
    return;
  }
};
var getA11yResults = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility) => {
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results.");
    return [];
  }
  try {
    BStackLogger.debug("Performing scan before getting results");
    await performA11yScan(isAppAutomate, browser, isBrowserStackSession, isAccessibility);
    if (accessibility_scripts_default.getResults) {
      const results = await executeAccessibilityScript(browser, accessibility_scripts_default.getResults);
      return results;
    }
    BStackLogger.error("AccessibilityScripts.getResults is null");
    return [];
  } catch (error) {
    BStackLogger.error("No accessibility results were found.");
    BStackLogger.debug(`getA11yResults Failed. Error: ${error}`);
    return [];
  }
});
var getAppA11yResults = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId) => {
  if (!isBrowserStackSession) {
    return [];
  }
  if (!isAppAccessibilityAutomationSession(isAccessibility, isAppAutomate)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return [];
  }
  try {
    const apiUrl = `${APIUtils.APP_ALLY_ENDPOINT}/${APP_ALLY_ISSUES_ENDPOINT}`;
    const apiRespone = await getAppA11yResultResponse(apiUrl, isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId);
    const result = apiRespone?.data?.data?.issues;
    BStackLogger.debug(`Polling Result: ${JSON.stringify(result)}`);
    return result;
  } catch (error) {
    BStackLogger.error("No accessibility summary was found.");
    BStackLogger.debug(`getAppA11yResults Failed. Error: ${error}`);
    return [];
  }
});
var getAppA11yResultsSummary = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS_SUMMARY, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId) => {
  if (!isBrowserStackSession) {
    return {};
  }
  if (!isAppAccessibilityAutomationSession(isAccessibility, isAppAutomate)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return {};
  }
  try {
    const apiUrl = `${APIUtils.APP_ALLY_ENDPOINT}/${APP_ALLY_ISSUES_SUMMARY_ENDPOINT}`;
    const apiRespone = await getAppA11yResultResponse(apiUrl, isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId);
    const result = apiRespone?.data?.data?.summary;
    BStackLogger.debug(`Polling Result: ${JSON.stringify(result)}`);
    return result;
  } catch {
    BStackLogger.error("No accessibility summary was found.");
    return {};
  }
});
var getAppA11yResultResponse = async (apiUrl, isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId) => {
  BStackLogger.debug("Performing scan before getting results summary");
  await performA11yScan(isAppAutomate, browser, isBrowserStackSession, isAccessibility);
  const upperTimeLimit = process.env.BSTACK_A11Y_POLLING_TIMEOUT ? Date.now() + parseInt(process.env.BSTACK_A11Y_POLLING_TIMEOUT) * 1e3 : Date.now() + 3e4;
  const params = { test_run_uuid: process.env.TEST_ANALYTICS_ID, session_id: sessionId, timestamp: Date.now() };
  const header = { Authorization: `Bearer ${process.env.BSTACK_A11Y_JWT}` };
  const apiRespone = await pollApi(apiUrl, params, header, upperTimeLimit);
  BStackLogger.debug(`Polling Result: ${JSON.stringify(apiRespone)}`);
  return apiRespone;
};
var getA11yResultsSummary = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS_SUMMARY, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility) => {
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return {};
  }
  try {
    BStackLogger.debug("Performing scan before getting results summary");
    await performA11yScan(isAppAutomate, browser, isBrowserStackSession, isAccessibility);
    if (accessibility_scripts_default.getResultsSummary) {
      const summaryResults = await executeAccessibilityScript(browser, accessibility_scripts_default.getResultsSummary);
      return summaryResults;
    }
    BStackLogger.error("AccessibilityScripts.getResultsSummary is null");
    return {};
  } catch {
    BStackLogger.error("No accessibility summary was found.");
    return {};
  }
});
var stopBuildUpstream = PerformanceTester.measureWrapper(TESTHUB_EVENTS.STOP, o11yErrorHandler(async function stopBuildUpstream2() {
  const stopBuildUsage = usageStats_default.getInstance().stopBuildUsage;
  stopBuildUsage.triggered();
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    stopBuildUsage.failed("Build is not completed yet");
    return {
      status: "error",
      message: "Build is not completed yet"
    };
  }
  if (!process.env[BROWSERSTACK_TESTHUB_JWT]) {
    stopBuildUsage.failed("Token/buildID is undefined, build creation might have failed");
    BStackLogger.debug("[STOP_BUILD] Missing Authentication Token/ Build ID");
    return {
      status: "error",
      message: "Token/buildID is undefined, build creation might have failed"
    };
  }
  const data = {
    "stop_time": (/* @__PURE__ */ new Date()).toISOString()
  };
  try {
    const url = `${APIUtils.DATA_ENDPOINT}/api/v1/builds/${process.env[BROWSERSTACK_TESTHUB_UUID]}/stop`;
    const response = await _fetch(url, {
      method: "PUT",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${process.env[BROWSERSTACK_TESTHUB_JWT]}`
      },
      body: JSON.stringify(data)
    });
    BStackLogger.debug(`[STOP_BUILD] Success response: ${await response.text()}`);
    stopBuildUsage.success();
    return {
      status: "success",
      message: ""
    };
  } catch (error) {
    stopBuildUsage.failed(error);
    BStackLogger.debug(`[STOP_BUILD] Failed. Error: ${error}`);
    return {
      status: "error",
      message: error.message
    };
  }
}));
function getCiInfo() {
  const env = process.env;
  if (typeof env.JENKINS_URL === "string" && env.JENKINS_URL.length > 0 || typeof env.JENKINS_HOME === "string" && env.JENKINS_HOME.length > 0) {
    return {
      name: "Jenkins",
      build_url: env.BUILD_URL,
      job_name: env.JOB_NAME,
      build_number: env.BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.CIRCLECI)) {
    return {
      name: "CircleCI",
      build_url: env.CIRCLE_BUILD_URL,
      job_name: env.CIRCLE_JOB,
      build_number: env.CIRCLE_BUILD_NUM
    };
  }
  if (isTrue(env.CI) && isTrue(env.TRAVIS)) {
    return {
      name: "Travis CI",
      build_url: env.TRAVIS_BUILD_WEB_URL,
      job_name: env.TRAVIS_JOB_NAME,
      build_number: env.TRAVIS_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && env.CI_NAME === "codeship") {
    return {
      name: "Codeship",
      build_url: null,
      job_name: null,
      build_number: null
    };
  }
  if (env.BITBUCKET_BRANCH && env.BITBUCKET_COMMIT) {
    return {
      name: "Bitbucket",
      build_url: env.BITBUCKET_GIT_HTTP_ORIGIN,
      job_name: null,
      build_number: env.BITBUCKET_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.DRONE)) {
    return {
      name: "Drone",
      build_url: env.DRONE_BUILD_LINK,
      job_name: null,
      build_number: env.DRONE_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.SEMAPHORE)) {
    return {
      name: "Semaphore",
      build_url: env.SEMAPHORE_ORGANIZATION_URL,
      job_name: env.SEMAPHORE_JOB_NAME,
      build_number: env.SEMAPHORE_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.GITLAB_CI)) {
    return {
      name: "GitLab",
      build_url: env.CI_JOB_URL,
      job_name: env.CI_JOB_NAME,
      build_number: env.CI_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.BUILDKITE)) {
    return {
      name: "Buildkite",
      build_url: env.BUILDKITE_BUILD_URL,
      job_name: env.BUILDKITE_LABEL || env.BUILDKITE_PIPELINE_NAME,
      build_number: env.BUILDKITE_BUILD_NUMBER
    };
  }
  if (isTrue(env.TF_BUILD) && env.TF_BUILD_BUILDNUMBER) {
    return {
      name: "Visual Studio Team Services",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
      job_name: env.SYSTEM_DEFINITIONID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (isTrue(env.APPVEYOR)) {
    return {
      name: "Appveyor",
      build_url: `${env.APPVEYOR_URL}/project/${env.APPVEYOR_ACCOUNT_NAME}/${env.APPVEYOR_PROJECT_SLUG}/builds/${env.APPVEYOR_BUILD_ID}`,
      job_name: env.APPVEYOR_JOB_NAME,
      build_number: env.APPVEYOR_BUILD_NUMBER
    };
  }
  if (env.AZURE_HTTP_USER_AGENT && env.TF_BUILD) {
    return {
      name: "Azure CI",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
      job_name: env.BUILD_BUILDID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (env.CODEBUILD_BUILD_ID || env.CODEBUILD_RESOLVED_SOURCE_VERSION || env.CODEBUILD_SOURCE_VERSION) {
    return {
      name: "AWS CodeBuild",
      build_url: env.CODEBUILD_PUBLIC_BUILD_URL,
      job_name: env.CODEBUILD_BUILD_ID,
      build_number: env.CODEBUILD_BUILD_ID
    };
  }
  if (env.bamboo_buildNumber) {
    return {
      name: "Bamboo",
      build_url: env.bamboo_buildResultsUrl,
      job_name: env.bamboo_shortJobName,
      build_number: env.bamboo_buildNumber
    };
  }
  if (env.WERCKER || env.WERCKER_MAIN_PIPELINE_STARTED) {
    return {
      name: "Wercker",
      build_url: env.WERCKER_BUILD_URL,
      job_name: env.WERCKER_MAIN_PIPELINE_STARTED ? "Main Pipeline" : null,
      build_number: env.WERCKER_GIT_COMMIT
    };
  }
  if (env.GCP_PROJECT || env.GCLOUD_PROJECT || env.GOOGLE_CLOUD_PROJECT) {
    return {
      name: "Google Cloud",
      build_url: null,
      job_name: env.PROJECT_ID,
      build_number: env.BUILD_ID
    };
  }
  if (env.SHIPPABLE) {
    return {
      name: "Shippable",
      build_url: env.SHIPPABLE_BUILD_URL,
      job_name: env.SHIPPABLE_JOB_ID ? `Job #${env.SHIPPABLE_JOB_ID}` : null,
      build_number: env.SHIPPABLE_BUILD_NUMBER
    };
  }
  if (isTrue(env.NETLIFY)) {
    return {
      name: "Netlify",
      build_url: env.DEPLOY_URL,
      job_name: env.SITE_NAME,
      build_number: env.BUILD_ID
    };
  }
  if (isTrue(env.GITHUB_ACTIONS)) {
    return {
      name: "GitHub Actions",
      build_url: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}`,
      job_name: env.GITHUB_WORKFLOW,
      build_number: env.GITHUB_RUN_ID
    };
  }
  if (isTrue(env.CI) && env.VERCEL === "1") {
    return {
      name: "Vercel",
      build_url: `http://${env.VERCEL_URL}`,
      job_name: null,
      build_number: null
    };
  }
  if (env.TEAMCITY_VERSION) {
    return {
      name: "Teamcity",
      build_url: null,
      job_name: null,
      build_number: env.BUILD_NUMBER
    };
  }
  if (env.CONCOURSE || env.CONCOURSE_URL || env.CONCOURSE_USERNAME || env.CONCOURSE_TEAM) {
    return {
      name: "Concourse",
      build_url: null,
      job_name: env.BUILD_JOB_NAME || null,
      build_number: env.BUILD_ID || null
    };
  }
  if (env.GO_JOB_NAME) {
    return {
      name: "GoCD",
      build_url: null,
      job_name: env.GO_JOB_NAME,
      build_number: env.GO_PIPELINE_COUNTER
    };
  }
  if (env.CF_BUILD_ID) {
    return {
      name: "CodeFresh",
      build_url: env.CF_BUILD_URL,
      job_name: env.CF_PIPELINE_NAME,
      build_number: env.CF_BUILD_ID
    };
  }
  return null;
}
async function getGitMetaData() {
  const info = gitRepoInfo();
  if (!info.commonGitDir) {
    return;
  }
  const { remote } = await pGitconfig(info.commonGitDir);
  const remotes = remote ? Object.keys(remote).map((remoteName) => ({ name: remoteName, url: remote[remoteName].url })) : [];
  let gitMetaData = {
    name: "git",
    sha: info.sha,
    short_sha: info.abbreviatedSha,
    branch: info.branch,
    tag: info.tag,
    committer: info.committer,
    committer_date: info.committerDate,
    author: info.author,
    author_date: info.authorDate,
    commit_message: info.commitMessage,
    root: info.root,
    common_git_dir: info.commonGitDir,
    worktree_git_dir: info.worktreeGitDir,
    last_tag: info.lastTag,
    commits_since_last_tag: info.commitsSinceLastTag,
    remotes
  };
  gitMetaData = checkAndTruncateVCSInfo(gitMetaData);
  return gitMetaData;
}
function isBStackSession(config) {
  if (typeof config.user === "string" && typeof config.key === "string" && config.key.length === 20) {
    return true;
  }
  return false;
}
function isBrowserstackInfra(config, caps) {
  const isBrowserstack = (str) => {
    return str === "browserstack.com" || str.endsWith(".browserstack.com");
  };
  if (config.hostname && !isBrowserstack(config.hostname)) {
    return false;
  }
  if (caps && typeof caps === "object") {
    if (Array.isArray(caps)) {
      for (const capability of caps) {
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    } else {
      for (const key in caps) {
        const capability = caps[key];
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    }
  }
  if (!isBStackSession(config)) {
    return false;
  }
  return true;
}
function shouldAddServiceVersion(config, testObservability, caps) {
  if (config.services && config.services.toString().includes("chromedriver") && testObservability !== false || !isBrowserstackInfra(config, caps)) {
    return false;
  }
  return true;
}
function getObservabilityUser(options, config) {
  if (process.env.BROWSERSTACK_USERNAME) {
    return process.env.BROWSERSTACK_USERNAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.user) {
    return options.testObservabilityOptions.user;
  }
  return config.user;
}
function getObservabilityKey(options, config) {
  if (process.env.BROWSERSTACK_ACCESS_KEY) {
    return process.env.BROWSERSTACK_ACCESS_KEY;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.key) {
    return options.testObservabilityOptions.key;
  }
  return config.key;
}
function getObservabilityProject(options, bstackProjectName) {
  if (process.env.TEST_OBSERVABILITY_PROJECT_NAME) {
    return process.env.TEST_OBSERVABILITY_PROJECT_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.projectName) {
    return options.testObservabilityOptions.projectName;
  }
  return bstackProjectName;
}
function getObservabilityBuild(options, bstackBuildName) {
  if (process.env.TEST_OBSERVABILITY_BUILD_NAME) {
    return process.env.TEST_OBSERVABILITY_BUILD_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildName) {
    return options.testObservabilityOptions.buildName;
  }
  return bstackBuildName || path4.basename(path4.resolve(process.cwd()));
}
function getObservabilityBuildTags(options, bstackBuildTag) {
  if (process.env.TEST_OBSERVABILITY_BUILD_TAG) {
    return process.env.TEST_OBSERVABILITY_BUILD_TAG.split(",");
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildTag) {
    return options.testObservabilityOptions.buildTag;
  }
  if (bstackBuildTag) {
    return [bstackBuildTag];
  }
  return [];
}
function isTrue(value) {
  return (value + "").toLowerCase() === "true";
}
var patchConsoleLogs = o11yErrorHandler(() => {
  const BSTestOpsPatcher = new logPatcher_default({});
  Object.keys(consoleHolder).forEach((method) => {
    if (!(method in console) || method === "Console" || typeof console[method] !== "function") {
      BStackLogger.debug(`Skipping method: ${method}, exists: ${method in console}, type: ${typeof console[method]}`);
      return;
    }
    const origMethod = console[method].bind(console);
    console[method] = (...args) => {
      try {
        if (!Object.keys(BSTestOpsPatcher).includes(method)) {
          origMethod(...args);
        } else {
          origMethod(...args);
          BSTestOpsPatcher[method](...args);
        }
      } catch (error) {
        BStackLogger.debug(`Error while patching console logs : ${error}`);
        origMethod(...args);
      }
    };
  });
});
var getPlatformVersion = o11yErrorHandler(function getPlatformVersion2(caps, userCaps) {
  if (!caps && !userCaps) {
    return void 0;
  }
  const bstackOptions = userCaps?.["bstack:options"];
  const keys = ["platformVersion", "platform_version", "osVersion", "os_version"];
  for (const key of keys) {
    if (caps?.[key]) {
      BStackLogger.debug(`Got ${key} from driver caps`);
      return String(caps?.[key]);
    } else if (bstackOptions && bstackOptions?.[key]) {
      BStackLogger.debug(`Got ${key} from user bstack options`);
      return String(bstackOptions?.[key]);
    } else if (userCaps[key]) {
      BStackLogger.debug(`Got ${key} from user caps`);
      return String(userCaps[key]);
    }
  }
  return void 0;
});
var isObjectEmpty = (objectName) => {
  return objectName && Object.keys(objectName).length === 0 && objectName.constructor === Object;
};
var getErrorString = (err) => {
  if (!err) {
    return void 0;
  }
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error) {
    return err.message;
  }
};
function truncateString(field, truncateSizeInBytes) {
  try {
    const bufferSizeInBytes = Buffer.from(GIT_META_DATA_TRUNCATED).length;
    const fieldBufferObj = Buffer.from(field);
    const lenOfFieldBufferObj = fieldBufferObj.length;
    const finalLen = Math.ceil(lenOfFieldBufferObj - truncateSizeInBytes - bufferSizeInBytes);
    if (finalLen > 0) {
      const truncatedString = fieldBufferObj.subarray(0, finalLen).toString() + GIT_META_DATA_TRUNCATED;
      return truncatedString;
    }
  } catch (error) {
    BStackLogger.debug(`Error while truncating field, nothing was truncated here: ${error}`);
  }
  return field;
}
function getSizeOfJsonObjectInBytes(jsonData) {
  try {
    const buffer = Buffer.from(JSON.stringify(jsonData));
    return buffer.length;
  } catch (error) {
    BStackLogger.debug(`Something went wrong while calculating size of JSON object: ${error}`);
  }
  return -1;
}
function checkAndTruncateVCSInfo(gitMetaData) {
  const gitMetaDataSizeInBytes = getSizeOfJsonObjectInBytes(gitMetaData);
  if (gitMetaDataSizeInBytes && gitMetaDataSizeInBytes > MAX_GIT_META_DATA_SIZE_IN_BYTES) {
    const truncateSize = gitMetaDataSizeInBytes - MAX_GIT_META_DATA_SIZE_IN_BYTES;
    const truncatedCommitMessage = truncateString(gitMetaData.commit_message, truncateSize);
    gitMetaData.commit_message = truncatedCommitMessage;
    BStackLogger.info(`The commit has been truncated. Size of commit after truncation is ${getSizeOfJsonObjectInBytes(gitMetaData) / 1024} KB`);
  }
  return gitMetaData;
}
function isTurboScale(options) {
  return Boolean(options?.turboScale);
}
async function pollApi(url, params, headers, upperLimit, startTime = Date.now()) {
  params.timestamp = Math.round(Date.now() / 1e3);
  BStackLogger.debug(`current timestamp ${params.timestamp}`);
  try {
    const response = await makeGetRequest(url, params, headers);
    const responseData = await response.json();
    return {
      data: responseData,
      headers: response.headers,
      message: "Polling succeeded."
    };
  } catch (error) {
    if (error.response && error.response.status === 404) {
      const nextPollTime = parseInt(error.response.headers.get("next_poll_time"), 10) * 1e3;
      BStackLogger.debug(`timeInMillis ${nextPollTime}`);
      if (isNaN(nextPollTime)) {
        BStackLogger.warn("Invalid or missing `nextPollTime` header. Stopping polling.");
        return {
          data: {},
          headers: error.response.headers,
          message: "Invalid nextPollTime header value. Polling stopped."
        };
      }
      const elapsedTime = nextPollTime - Date.now();
      BStackLogger.debug(
        `elapsedTime ${elapsedTime} timeInMillis ${nextPollTime} upperLimit ${upperLimit}`
      );
      if (nextPollTime > upperLimit) {
        BStackLogger.warn("Polling stopped due to upper time limit.");
        return {
          data: {},
          headers: error.response.headers,
          message: "Polling stopped due to upper time limit."
        };
      }
      BStackLogger.debug(`Polling again in ${elapsedTime}ms with params:`, params);
      await new Promise((resolve) => setTimeout(resolve, elapsedTime));
      return pollApi(url, params, headers, upperLimit, startTime);
    } else if (error.response) {
      let errorMessage = error.response.statusText;
      try {
        const parsedError = JSON.parse(error.response.json());
        errorMessage = parsedError.message;
      } catch {
        BStackLogger.debug(`Error parsing pollApi request body ${error.response.body}`);
        errorMessage = "Unknown error";
      }
      throw {
        data: {},
        headers: {},
        message: errorMessage
      };
    } else {
      BStackLogger.error(`Unexpected error occurred: ${error}`);
      return { data: {}, headers: {}, message: "Unexpected error occurred." };
    }
  }
}
async function makeGetRequest(url, params, headers) {
  const urlObj = new URL(url);
  Object.keys(params).forEach((key) => urlObj.searchParams.append(key, params[key]));
  const response = await _fetch(urlObj.toString(), {
    method: "GET",
    headers
  });
  if (!response.ok) {
    const error = new Error("Request failed");
    error.response = response;
    throw error;
  }
  return response;
}
async function executeAccessibilityScript(browser, fnBody, arg) {
  return browser.execute(
    `return (function (...bstackSdkArgs) {
            return new Promise((resolve, reject) => {
                const data = bstackSdkArgs[0];
                bstackSdkArgs.push(resolve);
                ${fnBody.replace(/arguments/g, "bstackSdkArgs")}
            });
        })(${arg ? JSON.stringify(arg) : ""})`
  );
}

// src/cleanup.ts
import fs7 from "node:fs";
import util4 from "node:util";

// src/instrumentation/funnelInstrumentation.ts
import os2 from "node:os";
import util3, { format as format2 } from "node:util";
import path6 from "node:path";
import fs6 from "node:fs";

// src/data-store.ts
import path5 from "node:path";
import fs5 from "node:fs";
var workersDataDirPath = path5.join(process.cwd(), "logs", "worker_data");

// src/instrumentation/funnelInstrumentation.ts
function redactCredentialsFromFunnelData(data) {
  if (data) {
    if (data.userName) {
      data.userName = "[REDACTED]";
    }
    if (data.accessKey) {
      data.accessKey = "[REDACTED]";
    }
  }
  return data;
}
async function fireFunnelRequest(data) {
  const { userName, accessKey } = data;
  redactCredentialsFromFunnelData(data);
  BStackLogger.debug("Sending SDK event with data " + util3.inspect(data, { depth: 6 }));
  const encodedAuth = Buffer.from(`${userName}:${accessKey}`, "utf8").toString("base64");
  const response = await fetchWrap(APIUtils.FUNNEL_INSTRUMENTATION_URL, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      Authorization: `Basic ${encodedAuth}`
    },
    body: JSON.stringify(data)
  });
  BStackLogger.debug("Funnel Event Response: " + JSON.stringify(await response.text()));
}

// src/cleanup.ts
var BStackCleanup = class _BStackCleanup {
  static async startCleanup() {
    try {
      const funnelDataCleanup = process.argv.includes("--funnelData");
      let funnelData = null;
      if (funnelDataCleanup) {
        const index = process.argv.indexOf("--funnelData");
        const filePath = process.argv[index + 1];
        funnelData = _BStackCleanup.getFunnelDataFromFile(filePath);
      }
      if (process.argv.includes("--observability") && funnelData) {
        await this.executeObservabilityCleanup(funnelData);
      }
      if (funnelDataCleanup && funnelData) {
        await this.sendFunnelData(funnelData);
      }
    } catch (err) {
      const error = err;
      BStackLogger.error(error);
    }
    try {
      if (process.argv.includes("--performanceData")) {
        await PerformanceTester.uploadEventsData();
      }
    } catch (er) {
      BStackLogger.debug(`Error in sending events data ${util4.format(er)}`);
    }
  }
  static async executeObservabilityCleanup(funnelData) {
    if (!process.env[BROWSERSTACK_TESTHUB_JWT]) {
      return;
    }
    BStackLogger.debug("Executing Test Reporting and Analytics cleanup");
    try {
      const result = await stopBuildUpstream();
      if (process.env[BROWSERSTACK_OBSERVABILITY] && process.env[BROWSERSTACK_TESTHUB_UUID]) {
        BStackLogger.info(`
Visit https://automation.browserstack.com/builds/${process.env[BROWSERSTACK_TESTHUB_UUID]} to view build report, insights, and many more debugging information all at one place!
`);
      }
      const status = result && result.status || "failed";
      const message = result && result.message;
      this.updateO11yStopData(funnelData, status, status === "failed" ? message : void 0);
    } catch (e) {
      BStackLogger.error("Error in stopping Test Reporting and Analytics build: " + e);
      this.updateO11yStopData(funnelData, "failed", e);
    }
  }
  static updateO11yStopData(funnelData, status, error = void 0) {
    const toData = funnelData?.event_properties?.productUsage?.testObservability;
    if (!toData) {
      return;
    }
    let existingStopData = toData.events.buildEvents.finished;
    existingStopData = existingStopData || {};
    existingStopData = {
      ...existingStopData,
      status,
      error: getErrorString(error),
      stoppedFrom: "exitHook"
    };
    toData.events.buildEvents.finished = existingStopData;
  }
  static async sendFunnelData(funnelData) {
    try {
      await fireFunnelRequest(funnelData);
      BStackLogger.debug("Funnel data sent successfully from cleanup");
    } catch (e) {
      BStackLogger.error("Error in sending funnel data: " + e);
    }
  }
  static getFunnelDataFromFile(filePath) {
    if (!filePath) {
      return null;
    }
    const content = fs7.readFileSync(filePath, "utf8");
    const data = JSON.parse(content);
    this.removeFunnelDataFile(filePath);
    return data;
  }
  static removeFunnelDataFile(filePath) {
    if (!filePath) {
      return;
    }
    fs7.rmSync(filePath, { force: true });
  }
};
await BStackCleanup.startCleanup();
export {
  BStackCleanup as default
};
