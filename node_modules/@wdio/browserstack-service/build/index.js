var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/launcher.ts
import fs13 from "node:fs";
import { readFile } from "node:fs/promises";
import path18 from "node:path";
import { promisify as promisify4, format as format4 } from "node:util";
import { performance as performance3, PerformanceObserver as PerformanceObserver2 } from "node:perf_hooks";
import os5 from "node:os";
import { SevereServiceError } from "webdriverio";
import * as BrowserstackLocalLauncher from "browserstack-local";

// package.json
var package_default = {
  name: "@wdio/browserstack-service",
  version: "9.20.1",
  description: "WebdriverIO service for better Browserstack integration",
  author: "Adam Bjerstedt <abjerstedt@gmail.com>",
  homepage: "https://github.com/webdriverio/webdriverio/tree/main/packages/wdio-browserstack-service",
  license: "MIT",
  engines: {
    node: ">=18.20.0"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/webdriverio/webdriverio.git",
    directory: "packages/wdio-browserstack-service"
  },
  keywords: [
    "webdriverio",
    "wdio",
    "browserstack",
    "wdio-service"
  ],
  bugs: {
    url: "https://github.com/webdriverio/webdriverio/issues"
  },
  type: "module",
  types: "./build/index.d.ts",
  exports: {
    ".": {
      types: "./build/index.d.ts",
      import: "./build/index.js"
    },
    "./cleanup": {
      import: "./build/cleanup.js",
      source: "./src/cleanup.ts"
    }
  },
  typeScriptVersion: "3.8.3",
  dependencies: {
    "@browserstack/ai-sdk-node": "1.5.17",
    "@browserstack/wdio-browserstack-service": "^2.0.0",
    "@percy/appium-app": "^2.0.9",
    "@percy/selenium-webdriver": "^2.2.2",
    "@types/gitconfiglocal": "^2.0.1",
    "@wdio/logger": "workspace:*",
    "@wdio/reporter": "workspace:*",
    "@wdio/types": "workspace:*",
    "browserstack-local": "^1.5.1",
    chalk: "^5.3.0",
    "csv-writer": "^1.6.0",
    "formdata-node": "5.0.1",
    "git-repo-info": "^2.1.1",
    gitconfiglocal: "^2.1.0",
    undici: "^6.21.3",
    uuid: "^11.1.0",
    webdriverio: "workspace:*",
    "winston-transport": "^4.5.0",
    yauzl: "^3.0.0",
    tar: "^6.1.15"
  },
  peerDependencies: {
    "@wdio/cli": "^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0 || ^9.0.0"
  },
  devDependencies: {
    "@types/node": "^20.1.0",
    "@types/yauzl": "^2.10.3",
    "@types/tar": "^6.1.13",
    "@wdio/globals": "workspace:*"
  },
  publishConfig: {
    access: "public"
  }
};

// src/constants.ts
var bstackServiceVersion = package_default.version;
var BROWSER_DESCRIPTION = [
  "device",
  "os",
  "osVersion",
  "os_version",
  "browserName",
  "browser",
  "browserVersion",
  "browser_version"
];
var VALID_APP_EXTENSION = [
  ".apk",
  ".aab",
  ".ipa"
];
var DEFAULT_OPTIONS = {
  setSessionName: true,
  setSessionStatus: true,
  testObservability: true,
  accessibility: false
};
var consoleHolder = Object.assign({}, console);
var APP_ALLY_ISSUES_ENDPOINT = "api/v1/issues";
var APP_ALLY_ISSUES_SUMMARY_ENDPOINT = "api/v1/issues-summary";
var DATA_EVENT_ENDPOINT = "api/v1/event";
var DATA_BATCH_ENDPOINT = "api/v1/batch";
var DATA_SCREENSHOT_ENDPOINT = "api/v1/screenshots";
var DATA_BATCH_SIZE = 1e3;
var DATA_BATCH_INTERVAL = 2e3;
var DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS = 5e3;
var DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS = 100;
var BSTACK_SERVICE_VERSION = bstackServiceVersion;
var NOT_ALLOWED_KEYS_IN_CAPS = ["includeTagsInTestingScope", "excludeTagsInTestingScope"];
var LOGS_FILE = "logs/bstack-wdio-service.log";
var CLI_DEBUG_LOGS_FILE = "log/sdk-cli-debug.log";
var UPLOAD_LOGS_ENDPOINT = "client-logs/upload";
var PERCY_LOGS_FILE = "logs/percy.log";
var PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS = [
  "/session/:sessionId/url",
  "/session/:sessionId/forward",
  "/session/:sessionId/back",
  "/session/:sessionId/refresh",
  "/session/:sessionId/screenshot",
  "/session/:sessionId/actions",
  "/session/:sessionId/appium/device/shake"
];
var CAPTURE_MODES = ["click", "auto", "screenshot", "manual", "testcase"];
var LOG_KIND_USAGE_MAP = {
  "TEST_LOG": "log",
  "TEST_SCREENSHOT": "screenshot",
  "TEST_STEP": "step",
  "HTTP": "http"
};
var SUPPORTED_BROWSERS_FOR_AI = ["chrome", "microsoftedge", "firefox"];
var TCG_URL = "https://tcg.browserstack.com";
var TCG_INFO = {
  tcgRegion: "use",
  tcgUrl: TCG_URL
};
var BROWSERSTACK_TESTHUB_JWT = "BROWSERSTACK_TESTHUB_JWT";
var BSTACK_TCG_AUTH_RESULT = "BSTACK_TCG_AUTH_RESULT";
var TESTOPS_SCREENSHOT_ENV = "BS_TESTOPS_ALLOW_SCREENSHOTS";
var BROWSERSTACK_TESTHUB_UUID = "BROWSERSTACK_TESTHUB_UUID";
var TEST_ANALYTICS_ID = "TEST_ANALYTICS_ID";
var PERF_MEASUREMENT_ENV = "BROWSERSTACK_O11Y_PERF_MEASUREMENT";
var RERUN_TESTS_ENV = "BROWSERSTACK_RERUN_TESTS";
var RERUN_ENV = "BROWSERSTACK_RERUN";
var TESTOPS_BUILD_COMPLETED_ENV = "BS_TESTOPS_BUILD_COMPLETED";
var BROWSERSTACK_PERCY = "BROWSERSTACK_PERCY";
var BROWSERSTACK_ACCESSIBILITY = "BROWSERSTACK_ACCESSIBILITY";
var BROWSERSTACK_OBSERVABILITY = "BROWSERSTACK_OBSERVABILITY";
var BROWSERSTACK_TEST_REPORTING = "BROWSERSTACK_TEST_REPORTING";
var TEST_REPORTING_PROJECT_NAME = "TEST_REPORTING_PROJECT_NAME";
var MAX_GIT_META_DATA_SIZE_IN_BYTES = 64 * 1024;
var GIT_META_DATA_TRUNCATED = "...[TRUNCATED]";
var CLI_STOP_TIMEOUT = 5e3;
var WDIO_NAMING_PREFIX = "WebdriverIO-";
var PERF_METRICS_WAIT_TIME = 2e3;
var UPDATED_CLI_ENDPOINT = "sdk/v1/update_cli";

// src/bstackLogger.ts
import path4 from "node:path";
import fs4 from "node:fs";
import chalk from "chalk";
import logger from "@wdio/logger";

// src/util.ts
import { hostname as hostname2, platform as platform2, type as type2, version as version2, arch as arch2, tmpdir } from "node:os";
import crypto from "node:crypto";
import fs3 from "node:fs";
import zlib from "node:zlib";
import { format, promisify } from "node:util";
import path3 from "node:path";
import util2 from "node:util";
import gitRepoInfo from "git-repo-info";
import gitconfig from "gitconfiglocal";
import { FormData as FormData2 } from "formdata-node";
import { performance as performance2 } from "node:perf_hooks";

// src/logPatcher.ts
import Transport from "winston-transport";
var LOG_LEVELS = {
  INFO: "INFO",
  ERROR: "ERROR",
  DEBUG: "DEBUG",
  TRACE: "TRACE",
  WARN: "WARN"
};
var logPatcher = class extends Transport {
  logToTestOps = (level = LOG_LEVELS.INFO, message = [""]) => {
    process.emit(`bs:addLog:${process.pid}`, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: level.toUpperCase(),
      message: `"${message.join(", ")}"`,
      kind: "TEST_LOG",
      http_response: {}
    });
  };
  /* Patching this would show user an extended trace on their cli */
  trace = (...message) => {
    this.logToTestOps(LOG_LEVELS.TRACE, message);
  };
  debug = (...message) => {
    this.logToTestOps(LOG_LEVELS.DEBUG, message);
  };
  info = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
  warn = (...message) => {
    this.logToTestOps(LOG_LEVELS.WARN, message);
  };
  error = (...message) => {
    this.logToTestOps(LOG_LEVELS.ERROR, message);
  };
  log = (...message) => {
    this.logToTestOps(LOG_LEVELS.INFO, message);
  };
};
var logPatcher_default = logPatcher;

// src/instrumentation/performance/performance-tester.ts
import { createObjectCsvWriter } from "csv-writer";
import fs from "node:fs";
import fsPromise from "node:fs/promises";
import { performance, PerformanceObserver } from "node:perf_hooks";
import util from "node:util";
import worker from "node:worker_threads";
import path from "node:path";
import { arch, hostname, platform, type, version } from "node:os";

// src/cli/apiUtils.ts
var APIUtils = class {
  static FUNNEL_INSTRUMENTATION_URL = "https://api.browserstack.com/sdk/v1/event";
  static BROWSERSTACK_AUTOMATE_API_URL = "https://api.browserstack.com";
  static BROWSERSTACK_AA_API_URL = "https://api.browserstack.com";
  static BROWSERSTACK_PERCY_API_URL = "https://api.browserstack.com";
  static BROWSERSTACK_AUTOMATE_API_CLOUD_URL = "https://api-cloud.browserstack.com";
  static BROWSERSTACK_AA_API_CLOUD_URL = "https://api-cloud.browserstack.com";
  static APP_ALLY_ENDPOINT = "https://app-accessibility.browserstack.com/automate";
  static DATA_ENDPOINT = "https://collector-observability.browserstack.com";
  static UPLOAD_LOGS_ADDRESS = "https://upload-observability.browserstack.com";
  static EDS_URL = "https://eds.browserstack.com";
  static updateURLSForGRR(apis) {
    this.FUNNEL_INSTRUMENTATION_URL = `${apis.automate.api}/sdk/v1/event`;
    this.BROWSERSTACK_AUTOMATE_API_URL = apis.automate.api;
    this.BROWSERSTACK_AA_API_URL = apis.appAutomate.api;
    this.BROWSERSTACK_PERCY_API_URL = apis.percy.api;
    this.BROWSERSTACK_AUTOMATE_API_CLOUD_URL = apis.automate.upload;
    this.BROWSERSTACK_AA_API_CLOUD_URL = apis.appAutomate.upload;
    this.APP_ALLY_ENDPOINT = `${apis.appAccessibility.api}/automate`;
    this.DATA_ENDPOINT = apis.observability.api;
    this.UPLOAD_LOGS_ADDRESS = apis.observability.upload;
    this.EDS_URL = apis.edsInstrumentation.api;
  }
};

// src/fetchWrapper.ts
import { fetch as undiciFetch, ProxyAgent } from "undici";
var ResponseError = class extends Error {
  response;
  constructor(message, res) {
    super(message);
    this.response = res;
  }
};
async function fetchWrap(input, init) {
  const res = await _fetch(input, init);
  if (!res.ok) {
    throw new ResponseError(`Error response from server ${res.status}:  ${await res.text()}`, res);
  }
  return res;
}
function _fetch(input, init) {
  const proxyUrl = process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
  if (proxyUrl) {
    const noProxy = process.env.NO_PROXY && process.env.NO_PROXY.trim() ? process.env.NO_PROXY.trim().split(/[\s,;]+/) : [];
    const request = new Request(input);
    const url3 = new URL(request.url);
    if (!noProxy.some((str) => url3.hostname.endsWith(str))) {
      return undiciFetch(
        request.url,
        { ...init, dispatcher: new ProxyAgent(proxyUrl) }
      );
    }
  }
  return fetch(input, init);
}

// src/instrumentation/performance/performance-tester.ts
var PerformanceTester = class _PerformanceTester {
  static _observer;
  static _csvWriter;
  static _events = [];
  static _measuredEvents = [];
  static started = false;
  static details = {};
  static eventsMap = {};
  static browser;
  static scenarioThatRan;
  static jsonReportDirName = "performance-report";
  static jsonReportDirPath = path.join(process.cwd(), "logs", this.jsonReportDirName);
  static jsonReportFileName = `${this.jsonReportDirPath}/performance-report-${_PerformanceTester.getProcessId()}.json`;
  static startMonitoring(csvName = "performance-report.csv") {
    if (!fs.existsSync(this.jsonReportDirPath)) {
      fs.mkdirSync(this.jsonReportDirPath, { recursive: true });
    }
    this._observer = new PerformanceObserver((list) => {
      list.getEntries().filter((entry) => entry.entryType === "measure").forEach(
        (entry) => {
          let finalEntry = entry;
          finalEntry = entry.toJSON();
          if (this.details[entry.name]) {
            finalEntry = Object.assign(finalEntry, this.details[entry.name]);
          }
          delete this.details[entry.name];
          this._measuredEvents.push(finalEntry);
        }
      );
      if (process.env[PERF_MEASUREMENT_ENV]) {
        list.getEntries().forEach((entry) => this._events.push(entry));
      }
    });
    const entryTypes = ["measure"];
    if (process.env[PERF_MEASUREMENT_ENV]) {
      entryTypes.push("function");
    }
    this._observer.observe({ buffered: true, entryTypes });
    this.started = true;
    if (process.env[PERF_MEASUREMENT_ENV]) {
      this._csvWriter = createObjectCsvWriter({
        path: csvName,
        header: [
          { id: "name", title: "Function Name" },
          { id: "time", title: "Execution Time (ms)" }
        ]
      });
    }
  }
  static calculateTimes(methods) {
    const times = {};
    this._events.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
    });
    const timeTaken = methods.reduce((a, c) => {
      return times[c] + (a || 0);
    }, 0);
    BStackLogger.debug(`Time for ${methods} is ${timeTaken}`);
    return timeTaken;
  }
  static async stopAndGenerate(filename = "performance-own.html") {
    if (!this.started) {
      return;
    }
    await _PerformanceTester.sleep(PERF_METRICS_WAIT_TIME);
    try {
      const eventsJson = JSON.stringify(this._measuredEvents);
      const finalJSONStr = eventsJson.slice(1, -1) + ",";
      await fsPromise.appendFile(this.jsonReportFileName, finalJSONStr);
    } catch (er) {
      BStackLogger.debug(`Failed to write events of the worker to ${this.jsonReportFileName}: ${util.format(er)}`);
    }
    this._observer.disconnect();
    if (!process.env[PERF_MEASUREMENT_ENV]) {
      return;
    }
    await _PerformanceTester.sleep(PERF_METRICS_WAIT_TIME);
    this.started = false;
    this.generateCSV(this._events);
    const content = this.generateReport(this._events);
    const dir = path.join(process.cwd(), filename);
    try {
      await fsPromise.writeFile(dir, content);
      BStackLogger.info(`Performance report is at ${path}`);
    } catch (err) {
      BStackLogger.error(`Error in writing html ${util.format(err)}`);
    }
  }
  static generateReport(entries) {
    let html = "<!DOCTYPE html><html><head><title>Performance Report</title></head><body>";
    html += "<h1>Performance Report</h1>";
    html += "<table><thead><tr><th>Function Name</th><th>Duration (ms)</th></tr></thead><tbody>";
    entries.forEach((entry) => {
      html += `<tr><td>${entry.name}</td><td>${entry.duration}</td></tr>`;
    });
    html += "</tbody></table></body></html>";
    return html;
  }
  static generateCSV(entries) {
    const times = {};
    entries.map((entry) => {
      if (!times[entry.name]) {
        times[entry.name] = 0;
      }
      times[entry.name] += entry.duration;
      return {
        name: entry.name,
        time: entry.duration
      };
    });
    const dat = Object.entries(times).map(([key, value]) => {
      return {
        name: key,
        time: value
      };
    });
    this._csvWriter.writeRecords(dat).then(() => BStackLogger.info("Performance CSV report generated successfully")).catch((error) => console.error(error));
  }
  static Measure(label, details = {}) {
    const self = this;
    return (target, key, descriptor) => {
      const originalMethod = descriptor.value;
      if (descriptor.value) {
        descriptor.value = function(...args) {
          return _PerformanceTester.measure.apply(self, [label, originalMethod, { methodName: key.toString(), ...details }, args, this]);
        };
      }
    };
  }
  static measureWrapper(name, fn, details = {}) {
    const self = this;
    details.worker = _PerformanceTester.getProcessId();
    details.testName = _PerformanceTester.scenarioThatRan && _PerformanceTester.scenarioThatRan[_PerformanceTester.scenarioThatRan.length - 1];
    details.platform = _PerformanceTester.browser?.sessionId;
    return function(...args) {
      return self.measure(name, fn, details, args);
    };
  }
  static isEnabled() {
    return !(process.env.BROWSERSTACK_SDK_INSTRUMENTATION === "false");
  }
  static measure(label, fn, details = {}, args, thisArg = null) {
    if (!this.started || !this.isEnabled()) {
      return fn.apply(thisArg, args);
    }
    _PerformanceTester.start(label);
    if (this.details) {
      this.details[label] = details;
    }
    try {
      const returnVal = fn.apply(thisArg, args);
      if (returnVal instanceof Promise) {
        return new Promise((resolve, reject) => {
          returnVal.then((v) => {
            _PerformanceTester.end(label);
            resolve(v);
          }).catch((e) => {
            _PerformanceTester.end(label, false, util.format(e));
            reject(e);
          });
        });
      }
      _PerformanceTester.end(label);
      return returnVal;
    } catch (er) {
      _PerformanceTester.end(label, false, util.format(er));
      throw er;
    }
  }
  static start(event) {
    const finalEvent = event + "-start";
    if (this.eventsMap[finalEvent]) {
      return;
    }
    performance.mark(finalEvent);
    this.eventsMap[finalEvent] = 1;
  }
  static end(event, success = true, failure, details = {}) {
    performance.mark(event + "-end");
    performance.measure(event, event + "-start", event + "-end");
    this.details[event] = Object.assign({ success, failure: util.format(failure) }, Object.assign(Object.assign({
      worker: _PerformanceTester.getProcessId(),
      platform: _PerformanceTester.browser?.sessionId,
      testName: _PerformanceTester.scenarioThatRan && _PerformanceTester.scenarioThatRan[_PerformanceTester.scenarioThatRan.length - 1]
    }, details), this.details[event] || {}));
  }
  static getProcessId() {
    return `${process.pid}-${worker.threadId}`;
  }
  static sleep = (ms = 100) => new Promise((resolve) => setTimeout(resolve, ms));
  static async uploadEventsData() {
    try {
      let measures = [];
      if (await fsPromise.access(this.jsonReportDirPath).then(() => true).catch(() => false)) {
        const files = (await fsPromise.readdir(this.jsonReportDirPath)).map((file) => path.resolve(this.jsonReportDirPath, file));
        measures = (await Promise.all(files.map((file) => fsPromise.readFile(file, "utf-8")))).map((el) => `[${el.slice(0, -1)}]`).map((el) => JSON.parse(el)).flat();
      }
      if (this._measuredEvents.length > 0) {
        measures = measures.concat(this._measuredEvents);
      }
      const date = /* @__PURE__ */ new Date();
      const options = {
        timeZone: "UTC",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        // To include microseconds
        hour12: false
      };
      const formattedDate = new Intl.DateTimeFormat("en-GB", options).formatToParts(date).map(({ type: type3, value }) => type3 === "timeZoneName" ? "Z" : value).join("").replace(",", "T");
      const payload = {
        event_type: "sdk_events",
        data: {
          testhub_uuid: process.env.PERF_TESTHUB_UUID || process.env.SDK_RUN_ID,
          created_day: formattedDate,
          event_name: "SDKFeaturePerformance",
          user_data: process.env.PERF_USER_NAME,
          host_info: JSON.stringify({
            hostname: hostname(),
            platform: platform(),
            type: type(),
            version: version(),
            arch: arch()
          }),
          event_json: { measures, sdkRunId: process.env.SDK_RUN_ID }
        }
      };
      const result = await fetchWrap(`${APIUtils.EDS_URL}/send_sdk_events`, {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      BStackLogger.debug(`Successfully uploaded performance events ${util.format(await result.text())}`);
    } catch (er) {
      BStackLogger.debug(`Failed to upload performance events ${util.format(er)}`);
    }
    try {
      if (await fsPromise.access(this.jsonReportDirPath).then(() => true, () => false)) {
        const files = await fsPromise.readdir(this.jsonReportDirPath);
        for (const file of files) {
          await fsPromise.unlink(path.join(this.jsonReportDirPath, file));
        }
      }
    } catch (er) {
      BStackLogger.debug(`Failed to delete performance related files ${util.format(er)}`);
    }
  }
};

// src/instrumentation/performance/constants.ts
var EVENTS = {
  SDK_SETUP: "sdk:setup",
  SDK_CLEANUP: "sdk:cleanup",
  SDK_PRE_TEST: "sdk:pre-test",
  SDK_TEST: "sdk:test",
  SDK_POST_TEST: "sdk:post-test",
  SDK_HOOK: "sdk:hook",
  SDK_DRIVER: "sdk:driver",
  SDK_A11Y: "sdk:a11y",
  SDK_O11Y: "sdk:o11y",
  SDK_AUTO_CAPTURE: "sdk:auto-capture",
  SDK_PROXY_SETUP: "sdk:proxy-setup",
  SDK_TESTHUB: "sdk:testhub",
  SDK_AUTOMATE: "sdk:automate",
  SDK_APP_AUTOMATE: "sdk:app-automate",
  SDK_TURBOSCALE: "sdk:turboscale",
  SDK_PERCY: "sdk:percy",
  SDK_PRE_INITIALIZE: "sdk:driver:pre-initialization",
  SDK_POST_INITIALIZE: "sdk:driver:post-initialization",
  SDK_CLI_CHECK_UPDATE: "sdk:cli:check-update",
  SDK_CLI_DOWNLOAD: "sdk:cli:download",
  SDK_CLI_ON_BOOTSTRAP: "sdk:cli:on-bootstrap",
  SDK_CLI_ON_CONNECT: "sdk:cli:on-connect",
  SDK_CLI_START: "sdk:cli:start",
  SDK_CLI_ON_STOP: "sdk:cli:on-stop",
  SDK_CONNECT_BIN_SESSION: "sdk:connectBinSession",
  SDK_START_BIN_SESSION: "sdk:startBinSession"
};
var TESTHUB_EVENTS = {
  START: `${EVENTS.SDK_TESTHUB}:start`,
  STOP: `${EVENTS.SDK_TESTHUB}:stop`
};
var AUTOMATE_EVENTS = {
  KEEP_ALIVE: `${EVENTS.SDK_AUTOMATE}:keep-alive`,
  HUB_MANAGEMENT: `${EVENTS.SDK_AUTOMATE}:hub-management`,
  LOCAL_START: `${EVENTS.SDK_AUTOMATE}:local-start`,
  LOCAL_STOP: `${EVENTS.SDK_AUTOMATE}:local-stop`,
  DRIVER_MANAGE: `${EVENTS.SDK_AUTOMATE}:driver-manage`,
  SESSION_NAME: `${EVENTS.SDK_AUTOMATE}:session-name`,
  SESSION_STATUS: `${EVENTS.SDK_AUTOMATE}:session-status`,
  SESSION_ANNOTATION: `${EVENTS.SDK_AUTOMATE}:session-annotation`,
  IDLE_TIMEOUT: `${EVENTS.SDK_AUTOMATE}:idle-timeout`,
  GENERATE_CI_ARTIFACT: `${EVENTS.SDK_AUTOMATE}:ci-artifacts`,
  PRINT_BUILDLINK: `${EVENTS.SDK_AUTOMATE}:print-buildlink`
};
var A11Y_EVENTS = {
  PERFORM_SCAN: `${EVENTS.SDK_A11Y}:driver-performscan`,
  SAVE_RESULTS: `${EVENTS.SDK_A11Y}:save-results`,
  GET_RESULTS: `${EVENTS.SDK_A11Y}:get-accessibility-results`,
  GET_RESULTS_SUMMARY: `${EVENTS.SDK_A11Y}:get-accessibility-results-summary`
};
var PERCY_EVENTS = {
  DOWNLOAD: `${EVENTS.SDK_PERCY}:download`,
  SCREENSHOT: `${EVENTS.SDK_PERCY}:screenshot`,
  START: `${EVENTS.SDK_PERCY}:start`,
  STOP: `${EVENTS.SDK_PERCY}:stop`,
  AUTO_CAPTURE: `${EVENTS.SDK_PERCY}:auto-capture`,
  SNAPSHOT: `${EVENTS.SDK_PERCY}:snapshot`,
  SCREENSHOT_APP: `${EVENTS.SDK_PERCY}:screenshot-app`
};
var O11Y_EVENTS = {
  SYNC: `${EVENTS.SDK_O11Y}:sync`,
  TAKE_SCREENSHOT: `${EVENTS.SDK_O11Y}:driver-takeScreenShot`,
  PRINT_BUILDLINK: `${EVENTS.SDK_O11Y}:print-buildlink`
};
var HOOK_EVENTS = {
  BEFORE_EACH: `${EVENTS.SDK_HOOK}:before-each`,
  AFTER_EACH: `${EVENTS.SDK_HOOK}:after-each`,
  AFTER_ALL: `${EVENTS.SDK_HOOK}:after-all`,
  BEFORE_ALL: `${EVENTS.SDK_HOOK}:before-all`,
  BEFORE: `${EVENTS.SDK_HOOK}:before`,
  AFTER: `${EVENTS.SDK_HOOK}:after`
};
var TURBOSCALE_EVENTS = {
  HUB_MANAGEMENT: `${EVENTS.SDK_TURBOSCALE}:hub-management`,
  PRINT_BUILDLINK: `${EVENTS.SDK_TURBOSCALE}:print-buildlink`
};
var APP_AUTOMATE_EVENTS = {
  APP_UPLOAD: `${EVENTS.SDK_APP_AUTOMATE}:app-upload`
};
var DRIVER_EVENT = {
  QUIT: `${EVENTS.SDK_DRIVER}:quit`,
  GET: `${EVENTS.SDK_DRIVER}:get`,
  PRE_EXECUTE: `${EVENTS.SDK_DRIVER}:pre-execute`,
  POST_EXECUTE: `${EVENTS.SDK_DRIVER}:post-execute`
};

// src/crash-reporter.ts
var CrashReporter = class {
  /* User test config for build run minus PII */
  static userConfigForReporting = {};
  /* User credentials used for reporting crashes in browserstack service */
  static credentialsForCrashReportUpload = {};
  static setCredentialsForCrashReportUpload(options, config) {
    this.credentialsForCrashReportUpload = {
      username: getObservabilityUser(options, config),
      password: getObservabilityKey(options, config)
    };
    process.env.CREDENTIALS_FOR_CRASH_REPORTING = JSON.stringify(this.credentialsForCrashReportUpload);
  }
  static setConfigDetails(userConfig, capabilities, options) {
    const configWithoutPII = this.filterPII(userConfig);
    const filteredCapabilities = this.filterCapabilities(capabilities);
    this.userConfigForReporting = {
      framework: userConfig.framework,
      services: configWithoutPII.services,
      capabilities: filteredCapabilities,
      env: {
        "BROWSERSTACK_BUILD": process.env.BROWSERSTACK_BUILD,
        "BROWSERSTACK_BUILD_NAME": process.env.BROWSERSTACK_BUILD_NAME,
        "BUILD_TAG": process.env.BUILD_TAG
      }
    };
    process.env.USER_CONFIG_FOR_REPORTING = JSON.stringify(this.userConfigForReporting);
    this.setCredentialsForCrashReportUpload(options, userConfig);
  }
  static async uploadCrashReport(exception, stackTrace) {
    try {
      if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
        this.credentialsForCrashReportUpload = process.env.CREDENTIALS_FOR_CRASH_REPORTING !== void 0 ? JSON.parse(process.env.CREDENTIALS_FOR_CRASH_REPORTING) : this.credentialsForCrashReportUpload;
      }
    } catch (error) {
      return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user credentials while reporting crash due to ${error}`);
    }
    if (!this.credentialsForCrashReportUpload.username || !this.credentialsForCrashReportUpload.password) {
      return BStackLogger.error("[Crash_Report_Upload] Failed to parse user credentials while reporting crash");
    }
    try {
      if (Object.keys(this.userConfigForReporting).length === 0) {
        this.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
      }
    } catch (error) {
      BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while reporting crash due to ${error}`);
      this.userConfigForReporting = {};
    }
    const data = {
      hashed_id: process.env[BROWSERSTACK_TESTHUB_UUID],
      observability_version: {
        frameworkName: WDIO_NAMING_PREFIX + (this.userConfigForReporting.framework || "null"),
        sdkVersion: BSTACK_SERVICE_VERSION
      },
      exception: {
        error: exception.toString(),
        stackTrace
      },
      config: this.userConfigForReporting
    };
    const url3 = `${APIUtils.DATA_ENDPOINT}/api/v1/analytics`;
    const encodedAuth = Buffer.from(`${this.credentialsForCrashReportUpload.username}:${this.credentialsForCrashReportUpload.password}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await _fetch(url3, {
      method: "POST",
      body: JSON.stringify(data),
      headers
    });
    if (response.ok) {
      BStackLogger.debug(`[Crash_Report_Upload] Success response: ${JSON.stringify(await response.json())}`);
    } else {
      BStackLogger.error(`[Crash_Report_Upload] Failed due to ${response.body}`);
    }
  }
  static recursivelyRedactKeysFromObject(obj, keys) {
    if (!obj) {
      return;
    }
    if (Array.isArray(obj)) {
      obj.map((ele) => this.recursivelyRedactKeysFromObject(ele, keys));
    } else {
      for (const prop in obj) {
        if (keys.includes(prop.toLowerCase())) {
          obj[prop] = "[REDACTED]";
        } else if (typeof obj[prop] === "object") {
          this.recursivelyRedactKeysFromObject(obj[prop], keys);
        }
      }
    }
  }
  static deletePIIKeysFromObject(obj) {
    if (!obj) {
      return;
    }
    ["user", "username", "key", "accessKey"].forEach((key) => delete obj[key]);
  }
  static filterCapabilities(capabilities) {
    const capsCopy = JSON.parse(JSON.stringify(capabilities));
    this.recursivelyRedactKeysFromObject(capsCopy, ["extensions"]);
    return capsCopy;
  }
  static filterPII(userConfig) {
    const configWithoutPII = JSON.parse(JSON.stringify(userConfig));
    this.deletePIIKeysFromObject(configWithoutPII);
    const finalServices = [];
    const initialServices = configWithoutPII.services;
    delete configWithoutPII.services;
    try {
      for (const serviceArray of initialServices) {
        if (Array.isArray(serviceArray) && serviceArray.length >= 2 && serviceArray[0] === "browserstack") {
          for (let idx = 1; idx < serviceArray.length; idx++) {
            this.deletePIIKeysFromObject(serviceArray[idx]);
            if (serviceArray[idx]) {
              this.deletePIIKeysFromObject(serviceArray[idx].testReportingOptions);
              this.deletePIIKeysFromObject(serviceArray[idx].testObservabilityOptions);
            }
          }
          finalServices.push(serviceArray);
          break;
        }
      }
    } catch (err) {
      BStackLogger.error(`Error in parsing user config PII with error ${err ? err.stack || err : err}`);
      return configWithoutPII;
    }
    configWithoutPII.services = finalServices;
    return configWithoutPII;
  }
};

// src/testOps/featureStats.ts
var FeatureStats = class _FeatureStats {
  triggeredCount = 0;
  sentCount = 0;
  failedCount = 0;
  groups = {};
  mark(status, groupId) {
    switch (status) {
      case "triggered":
        this.triggered(groupId);
        break;
      case "success":
      case "sent":
        this.sent(groupId);
        break;
      case "failed":
        this.failed(groupId);
        break;
      default:
        BStackLogger.debug("Request to mark usage for unknown status - " + status);
        break;
    }
  }
  triggered(groupId) {
    this.triggeredCount += 1;
    if (groupId) {
      this.createGroup(groupId).triggered();
    }
  }
  sent(groupId) {
    this.sentCount += 1;
    if (groupId) {
      this.createGroup(groupId).sent();
    }
  }
  failed(groupId) {
    this.failedCount += 1;
    if (groupId) {
      this.createGroup(groupId).failed();
    }
  }
  success(groupId) {
    this.sent(groupId);
  }
  createGroup(groupId) {
    if (!this.groups[groupId]) {
      this.groups[groupId] = new _FeatureStats();
    }
    return this.groups[groupId];
  }
  getTriggeredCount() {
    return this.triggeredCount;
  }
  getSentCount() {
    return this.sentCount;
  }
  getFailedCount() {
    return this.failedCount;
  }
  getUsageForGroup(groupId) {
    return this.groups[groupId] || new _FeatureStats();
  }
  getOverview() {
    return { triggeredCount: this.triggeredCount, sentCount: this.sentCount, failedCount: this.failedCount };
  }
  getGroups() {
    return this.groups;
  }
  add(featureStats) {
    this.triggeredCount += featureStats.getTriggeredCount();
    this.sentCount += featureStats.getSentCount();
    this.failedCount += featureStats.getFailedCount();
    Object.entries(featureStats.getGroups()).forEach(([groupId, group]) => {
      this.createGroup(groupId).add(group);
    });
  }
  // omitGroups: true/false -> Include groups or not
  // onlyGroups: true/false -> data includes only groups
  // nestedGroups: true/false -> groups will be nested in groups if true
  toJSON(config = {}) {
    const overviewData = !config.onlyGroups ? {
      triggeredCount: this.triggeredCount,
      sentCount: this.sentCount,
      failedCount: this.failedCount
    } : {};
    const groupsData = {};
    if (!config.omitGroups) {
      Object.entries(this.groups).forEach(([groupId, group2]) => {
        groupsData[groupId] = group2.toJSON();
      });
    }
    const group = config.nestedGroups ? { groups: groupsData } : groupsData;
    return {
      ...overviewData,
      ...group
    };
  }
  static fromJSON(json) {
    const stats = new _FeatureStats();
    if (!json || isObjectEmpty(json)) {
      return stats;
    }
    stats.triggeredCount = json.triggeredCount;
    stats.sentCount = json.sentCount;
    stats.failedCount = json.failedCount;
    if (!json.groups) {
      return stats;
    }
    Object.entries(json.groups).forEach(([groupId, group]) => {
      stats.groups[groupId] = _FeatureStats.fromJSON(group);
    });
    return stats;
  }
};
var featureStats_default = FeatureStats;

// src/testOps/featureUsage.ts
var FeatureUsage = class {
  isTriggered;
  status;
  error;
  constructor(isTriggered) {
    if (isTriggered !== void 0) {
      this.isTriggered = isTriggered;
    }
  }
  getTriggered() {
    return this.isTriggered;
  }
  setTriggered(triggered) {
    this.isTriggered = triggered;
  }
  setStatus(status) {
    this.status = status;
  }
  setError(error) {
    this.error = error;
  }
  triggered() {
    this.isTriggered = true;
  }
  failed(e) {
    this.status = "failed";
    this.error = getErrorString(e);
  }
  success() {
    this.status = "success";
  }
  getStatus() {
    return this.status;
  }
  getError() {
    return this.error;
  }
  toJSON() {
    return {
      isTriggered: this.isTriggered,
      status: this.status,
      error: this.error
    };
  }
};
var featureUsage_default = FeatureUsage;

// src/testOps/testOpsConfig.ts
var TestOpsConfig = class _TestOpsConfig {
  constructor(enabled = true, manuallySet = false) {
    this.enabled = enabled;
    this.manuallySet = manuallySet;
    _TestOpsConfig._instance = this;
  }
  static _instance;
  buildStopped = false;
  buildHashedId;
  static getInstance(...args) {
    if (!this._instance) {
      this._instance = new _TestOpsConfig(...args);
    }
    return this._instance;
  }
};
var testOpsConfig_default = TestOpsConfig;

// src/testOps/usageStats.ts
var UsageStats = class _UsageStats {
  static instance;
  testStartedStats;
  testFinishedStats;
  hookStartedStats;
  hookFinishedStats;
  cbtSessionStats;
  logStats;
  launchBuildUsage;
  stopBuildUsage;
  static getInstance() {
    if (!_UsageStats.instance) {
      _UsageStats.instance = new _UsageStats();
    }
    return _UsageStats.instance;
  }
  constructor() {
    this.testStartedStats = new featureStats_default();
    this.testFinishedStats = new featureStats_default();
    this.hookStartedStats = new featureStats_default();
    this.hookFinishedStats = new featureStats_default();
    this.cbtSessionStats = new featureStats_default();
    this.logStats = new featureStats_default();
    this.launchBuildUsage = new featureUsage_default();
    this.stopBuildUsage = new featureUsage_default();
  }
  add(usageStats) {
    this.testStartedStats.add(usageStats.testStartedStats);
    this.testFinishedStats.add(usageStats.testFinishedStats);
    this.hookStartedStats.add(usageStats.hookStartedStats);
    this.hookFinishedStats.add(usageStats.hookFinishedStats);
    this.cbtSessionStats.add(usageStats.cbtSessionStats);
    this.logStats.add(usageStats.logStats);
  }
  getFormattedData(workersData) {
    this.addDataFromWorkers(workersData);
    const testOpsConfig = testOpsConfig_default.getInstance();
    const usage = {
      enabled: testOpsConfig.enabled,
      manuallySet: testOpsConfig.manuallySet,
      buildHashedId: testOpsConfig.buildHashedId
    };
    if (!usage.enabled) {
      return usage;
    }
    try {
      usage.events = this.getEventsData();
    } catch (e) {
      BStackLogger.debug("exception in getFormattedData: " + e);
    }
    return usage;
  }
  addDataFromWorkers(workersData) {
    workersData.map((workerData) => {
      try {
        const usageStatsForWorker = _UsageStats.fromJSON(workerData.usageStats);
        this.add(usageStatsForWorker);
      } catch (e) {
        BStackLogger.debug("Exception in adding workerData: " + e);
      }
    });
  }
  getEventsData() {
    return {
      buildEvents: {
        started: this.launchBuildUsage.toJSON(),
        finished: this.stopBuildUsage.toJSON()
      },
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ omitGroups: true }),
        ...this.testFinishedStats.toJSON({ onlyGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ omitGroups: true }),
        ...this.hookFinishedStats.toJSON({ onlyGroups: true })
      },
      logEvents: this.logStats.toJSON(),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  getDataToSave() {
    return {
      testEvents: {
        started: this.testStartedStats.toJSON(),
        finished: this.testFinishedStats.toJSON({ nestedGroups: true })
      },
      hookEvents: {
        started: this.hookStartedStats.toJSON(),
        finished: this.hookFinishedStats.toJSON({ nestedGroups: true })
      },
      logEvents: this.logStats.toJSON({ nestedGroups: true }),
      cbtSessionEvents: this.cbtSessionStats.toJSON()
    };
  }
  static fromJSON(data) {
    const usageStats = new _UsageStats();
    usageStats.testStartedStats = featureStats_default.fromJSON(data.testEvents.started);
    usageStats.testFinishedStats = featureStats_default.fromJSON(data.testEvents.finished);
    usageStats.hookStartedStats = featureStats_default.fromJSON(data.hookEvents.started);
    usageStats.hookFinishedStats = featureStats_default.fromJSON(data.hookEvents.finished);
    usageStats.logStats = featureStats_default.fromJSON(data.logEvents);
    usageStats.cbtSessionStats = featureStats_default.fromJSON(data.cbtSessionStats);
    return usageStats;
  }
};
var usageStats_default = UsageStats;

// src/util.ts
import tar from "tar";
import { fileFromPath } from "formdata-node/file-from-path";

// src/scripts/accessibility-scripts.ts
import path2 from "node:path";
import fs2 from "node:fs";
import os from "node:os";
var AccessibilityScripts = class _AccessibilityScripts {
  static instance = null;
  performScan = null;
  getResults = null;
  getResultsSummary = null;
  saveTestResults = null;
  commandsToWrap = null;
  ChromeExtension = {};
  browserstackFolderPath = "";
  commandsPath = "";
  // don't allow to create instances from it other than through `checkAndGetInstance`
  constructor() {
    this.browserstackFolderPath = this.getWritableDir();
    this.commandsPath = path2.join(this.browserstackFolderPath, "commands.json");
  }
  static checkAndGetInstance() {
    if (!_AccessibilityScripts.instance) {
      _AccessibilityScripts.instance = new _AccessibilityScripts();
      _AccessibilityScripts.instance.readFromExistingFile();
    }
    return _AccessibilityScripts.instance;
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  getWritableDir() {
    const orderedPaths = [
      path2.join(os.homedir(), ".browserstack"),
      process.cwd(),
      os.tmpdir()
    ];
    for (const orderedPath of orderedPaths) {
      try {
        if (fs2.existsSync(orderedPath)) {
          fs2.accessSync(orderedPath);
          return orderedPath;
        }
        fs2.mkdirSync(orderedPath, { recursive: true });
        return orderedPath;
      } catch (error) {
      }
    }
    return "";
  }
  readFromExistingFile() {
    try {
      if (fs2.existsSync(this.commandsPath)) {
        const data = fs2.readFileSync(this.commandsPath, "utf8");
        if (data) {
          this.update(JSON.parse(data));
        }
      }
    } catch {
    }
  }
  update(data) {
    if (data.scripts) {
      this.performScan = data.scripts.scan;
      this.getResults = data.scripts.getResults;
      this.getResultsSummary = data.scripts.getResultsSummary;
      this.saveTestResults = data.scripts.saveResults;
    }
    if (data.commands && data.commands.length) {
      this.commandsToWrap = data.commands;
    }
    if (data.nonBStackInfraA11yChromeOptions) {
      this.ChromeExtension = data.nonBStackInfraA11yChromeOptions;
    }
  }
  store() {
    if (!fs2.existsSync(this.browserstackFolderPath)) {
      fs2.mkdirSync(this.browserstackFolderPath);
    }
    fs2.writeFileSync(this.commandsPath, JSON.stringify({
      commands: this.commandsToWrap,
      scripts: {
        scan: this.performScan,
        getResults: this.getResults,
        getResultsSummary: this.getResultsSummary,
        saveResults: this.saveTestResults
      },
      nonBStackInfraA11yChromeOptions: this.ChromeExtension
    }));
  }
};
var accessibility_scripts_default = AccessibilityScripts.checkAndGetInstance();

// src/util.ts
var pGitconfig = promisify(gitconfig);
var DEFAULT_REQUEST_CONFIG = {
  headers: {
    "Content-Type": "application/json",
    "X-BSTACK-OBS": "true"
  }
};
var COLORS = {
  error: "red",
  warn: "yellow",
  info: "cyanBright",
  debug: "green",
  trace: "cyan",
  progress: "magenta"
};
function getBrowserDescription(cap) {
  cap = cap || {};
  if (cap["bstack:options"]) {
    cap = { ...cap, ...cap["bstack:options"] };
  }
  return BROWSER_DESCRIPTION.map((k) => cap[k]).filter(Boolean).join(" ");
}
function getBrowserCapabilities(browser, caps, browserName) {
  if (!browser.isMultiremote) {
    return { ...browser.capabilities, ...caps };
  }
  const multiCaps = caps;
  const globalCap = browserName && browser.getInstance(browserName) ? browser.getInstance(browserName).capabilities : {};
  const cap = browserName && multiCaps[browserName] ? multiCaps[browserName].capabilities : {};
  return { ...globalCap, ...cap };
}
function isBrowserstackCapability(cap) {
  return Boolean(
    cap && cap["bstack:options"] && // return false if the only cap in bstack:options is wdioService,
    // as that is added by the service and not present in user passed caps
    !(Object.keys(cap["bstack:options"]).length === 1 && cap["bstack:options"].wdioService)
  );
}
function getParentSuiteName(fullTitle, testSuiteTitle) {
  const fullTitleWords = fullTitle.split(" ");
  const testSuiteTitleWords = testSuiteTitle.split(" ");
  const shortestLength = Math.min(fullTitleWords.length, testSuiteTitleWords.length);
  let c = 0;
  let parentSuiteName = "";
  while (c < shortestLength && fullTitleWords[c] === testSuiteTitleWords[c]) {
    parentSuiteName += fullTitleWords[c++] + " ";
  }
  return parentSuiteName.trim();
}
function processError(error, fn, args) {
  BStackLogger.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
  let argsString;
  try {
    argsString = JSON.stringify(args);
  } catch {
    argsString = util2.inspect(args, { depth: 2 });
  }
  CrashReporter.uploadCrashReport(`Error in executing ${fn.name} with args ${argsString} : ${error}`, error && error.stack || "unknown error");
}
function o11yErrorHandler(fn) {
  return function(...args) {
    try {
      let functionToHandle = fn;
      if (process.env[PERF_MEASUREMENT_ENV]) {
        functionToHandle = performance2.timerify(functionToHandle);
      }
      const result = functionToHandle(...args);
      if (result instanceof Promise) {
        return result.catch((error) => processError(error, fn, args));
      }
      return result;
    } catch (error) {
      processError(error, fn, args);
    }
  };
}
async function nodeRequest(requestType, apiEndpoint, options, apiUrl, timeout = 12e4) {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    const response = await _fetch(`${apiUrl}/${apiEndpoint}`, {
      method: requestType,
      signal: controller.signal,
      ...options
    });
    clearTimeout(timeoutId);
    return await response.json();
  } catch (error) {
    BStackLogger.debug(`Error in firing request ${apiUrl}/${apiEndpoint}: ${format(error)}`);
    const isLogUpload = apiEndpoint === UPLOAD_LOGS_ENDPOINT;
    if (error && error.response) {
      const errorMessageJson = error.response.body ? JSON.parse(error.response.body.toString()) : null;
      const errorMessage = errorMessageJson ? errorMessageJson.message : null;
      if (errorMessage) {
        const message = `${errorMessage} - ${error.stack}`;
        if (isLogUpload) {
          BStackLogger.debug(message);
        } else {
          BStackLogger.error(message);
        }
      }
      if (isLogUpload) {
        return;
      }
      throw error;
    } else {
      if (isLogUpload) {
        BStackLogger.debug(`Failed to fire api request due to ${error} - ${error.stack}`);
        return;
      }
      BStackLogger.debug(`Failed to fire api request due to ${error} - ${error.stack}`);
      throw error;
    }
  }
}
function o11yClassErrorHandler(errorClass) {
  const prototype = errorClass.prototype;
  if (Object.getOwnPropertyNames(prototype).length < 2) {
    return errorClass;
  }
  Object.getOwnPropertyNames(prototype).forEach((methodName) => {
    const method = prototype[methodName];
    if (typeof method === "function" && methodName !== "constructor" && methodName !== "commandWrapper") {
      Object.defineProperty(prototype, methodName, {
        writable: true,
        value: function(...args) {
          try {
            const result = (process.env[PERF_MEASUREMENT_ENV] ? performance2.timerify(method) : method).call(this, ...args);
            if (result instanceof Promise) {
              return result.catch((error) => processError(error, method, args));
            }
            return result;
          } catch (err) {
            processError(err, method, args);
          }
        }
      });
    }
  });
  return errorClass;
}
var processTestObservabilityResponse = (response) => {
  if (!response.observability) {
    handleErrorForObservability(null);
    return;
  }
  if (!response.observability.success) {
    handleErrorForObservability(response.observability);
    return;
  }
  process.env[BROWSERSTACK_OBSERVABILITY] = "true";
  if (response.observability.options.allow_screenshots) {
    process.env[TESTOPS_SCREENSHOT_ENV] = response.observability.options.allow_screenshots.toString();
  }
};
var jsonifyAccessibilityArray = (dataArray, keyName, valueName) => {
  const result = {};
  dataArray.forEach((element) => {
    result[element[keyName]] = element[valueName];
  });
  return result;
};
var processAccessibilityResponse = (response, options) => {
  if (!response.accessibility) {
    if (options.accessibility === true) {
      handleErrorForAccessibility(null);
    }
    return;
  }
  if (!response.accessibility.success) {
    handleErrorForAccessibility(response.accessibility);
    return;
  }
  if (response.accessibility.options) {
    const { accessibilityToken, pollingTimeout, scannerVersion } = jsonifyAccessibilityArray(response.accessibility.options.capabilities, "name", "value");
    const result = jsonifyAccessibilityArray(response.accessibility.options.capabilities, "name", "value");
    const scriptsJson = {
      "scripts": jsonifyAccessibilityArray(response.accessibility.options.scripts, "name", "command"),
      "commands": response.accessibility.options.commandsToWrap?.commands ?? [],
      "nonBStackInfraA11yChromeOptions": result["goog:chromeOptions"]
    };
    if (scannerVersion) {
      process.env.BSTACK_A11Y_SCANNER_VERSION = scannerVersion;
      BStackLogger.debug(`Accessibility scannerVersion ${scannerVersion}`);
    }
    if (accessibilityToken) {
      process.env.BSTACK_A11Y_JWT = accessibilityToken;
      process.env[BROWSERSTACK_ACCESSIBILITY] = "true";
    }
    if (pollingTimeout) {
      process.env.BSTACK_A11Y_POLLING_TIMEOUT = pollingTimeout;
    }
    if (scriptsJson) {
      accessibility_scripts_default.update(scriptsJson);
      accessibility_scripts_default.store();
    }
  }
};
var processLaunchBuildResponse = (response, options) => {
  if (options.testObservability) {
    processTestObservabilityResponse(response);
  }
  processAccessibilityResponse(response, options);
};
var launchTestSession = PerformanceTester.measureWrapper(TESTHUB_EVENTS.START, o11yErrorHandler(async function launchTestSession2(options, config, bsConfig, bStackConfig, accessibilityAutomation) {
  const launchBuildUsage = usageStats_default.getInstance().launchBuildUsage;
  launchBuildUsage.triggered();
  const data = {
    format: "json",
    project_name: getObservabilityProject(options, bsConfig.projectName),
    name: getObservabilityBuild(options, bsConfig.buildName),
    build_identifier: bsConfig.buildIdentifier,
    started_at: (/* @__PURE__ */ new Date()).toISOString(),
    tags: getObservabilityBuildTags(options, bsConfig.buildTag),
    host_info: {
      hostname: hostname2(),
      platform: platform2(),
      type: type2(),
      version: version2(),
      arch: arch2()
    },
    ci_info: getCiInfo(),
    build_run_identifier: process.env.BROWSERSTACK_BUILD_RUN_IDENTIFIER,
    failed_tests_rerun: process.env[RERUN_ENV] || false,
    version_control: await getGitMetaData(),
    accessibility: {
      settings: options.accessibilityOptions
    },
    browserstackAutomation: shouldAddServiceVersion(config, options.testObservability),
    framework_details: {
      frameworkName: WDIO_NAMING_PREFIX + config.framework,
      frameworkVersion: bsConfig.bstackServiceVersion,
      sdkVersion: bsConfig.bstackServiceVersion,
      language: "ECMAScript",
      testFramework: {
        name: "WebdriverIO",
        version: bsConfig.bstackServiceVersion
      }
    },
    product_map: getProductMapForBuildStartCall(bStackConfig, accessibilityAutomation),
    config: {}
  };
  if (accessibilityAutomation && (isTurboScale(options) || data.browserstackAutomation === false)) {
    data.accessibility.settings ??= {};
    data.accessibility.settings["includeEncodedExtension"] = true;
  }
  try {
    if (Object.keys(CrashReporter.userConfigForReporting).length === 0) {
      CrashReporter.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== void 0 ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
    }
  } catch (error) {
    return BStackLogger.error(`[Crash_Report_Upload] Failed to parse user config while sending build start event due to ${error}`);
  }
  data.config = CrashReporter.userConfigForReporting;
  try {
    const url3 = `${APIUtils.DATA_ENDPOINT}/api/v2/builds`;
    const encodedAuth = Buffer.from(`${getObservabilityUser(options, config)}:${getObservabilityKey(options, config)}`, "utf8").toString("base64");
    const headers = {
      ...DEFAULT_REQUEST_CONFIG.headers,
      Authorization: `Basic ${encodedAuth}`
    };
    const response = await _fetch(url3, {
      method: "POST",
      headers,
      body: JSON.stringify(data)
    });
    const jsonResponse = await response.json();
    delete data?.accessibility?.settings?.includeEncodedExtension;
    BStackLogger.debug(`[Start_Build] Success response: ${JSON.stringify(jsonResponse)}`);
    process.env[TESTOPS_BUILD_COMPLETED_ENV] = "true";
    if (jsonResponse.jwt) {
      process.env[BROWSERSTACK_TESTHUB_JWT] = jsonResponse.jwt;
    }
    if (jsonResponse.build_hashed_id) {
      process.env[BROWSERSTACK_TESTHUB_UUID] = jsonResponse.build_hashed_id;
      testOpsConfig_default.getInstance().buildHashedId = jsonResponse.build_hashed_id;
      BStackLogger.info(`Testhub started with id: ${testOpsConfig_default.getInstance()?.buildHashedId}`);
    }
    processLaunchBuildResponse(jsonResponse, options);
    launchBuildUsage.success();
    return jsonResponse;
  } catch (error) {
    BStackLogger.debug(`TestHub build start failed: ${format(error)}`);
    if (!error.success) {
      launchBuildUsage.failed(error);
      logBuildError(error);
      return null;
    }
  }
}));
var validateCapsWithAppA11y = (platformMeta) => {
  if (platformMeta?.platform_name && String(platformMeta?.platform_name).toLowerCase() === "android" && (platformMeta?.platform_version && parseInt(platformMeta?.platform_version?.toString()) < 11)) {
    BStackLogger.warn("App Accessibility Automation tests are supported on OS version 11 and above for Android devices.");
    return false;
  }
  return true;
};
var validateCapsWithA11y = (deviceName, platformMeta, chromeOptions) => {
  try {
    if (deviceName) {
      BStackLogger.warn("Accessibility Automation will run only on Desktop browsers.");
      return false;
    }
    if (platformMeta?.browser_name?.toLowerCase() !== "chrome") {
      BStackLogger.warn("Accessibility Automation will run only on Chrome browsers.");
      return false;
    }
    const browserVersion = platformMeta?.browser_version;
    if (!isUndefined(browserVersion) && !(browserVersion === "latest" || parseFloat(browserVersion + "") > 94)) {
      BStackLogger.warn("Accessibility Automation will run only on Chrome browser version greater than 94.");
      return false;
    }
    if (chromeOptions?.args?.includes("--headless")) {
      BStackLogger.warn("Accessibility Automation will not run on legacy headless mode. Switch to new headless mode or avoid using headless mode.");
      return false;
    }
    return true;
  } catch (error) {
    BStackLogger.debug(`Exception in checking capabilities compatibility with Accessibility. Error: ${error}`);
  }
  return false;
};
var validateCapsWithNonBstackA11y = (browserName, browserVersion) => {
  if (browserName?.toLowerCase() !== "chrome") {
    BStackLogger.warn("Accessibility Automation will run only on Chrome browsers.");
    return false;
  }
  if (!isUndefined(browserVersion) && !(browserVersion === "latest" || parseFloat(browserVersion + "") > 100)) {
    BStackLogger.warn("Accessibility Automation will run only on Chrome browser version greater than 100.");
    return false;
  }
  return true;
};
var shouldScanTestForAccessibility = (suiteTitle, testTitle, accessibilityOptions, world, isCucumber) => {
  try {
    const includeTags = Array.isArray(accessibilityOptions?.includeTagsInTestingScope) ? accessibilityOptions?.includeTagsInTestingScope : [];
    const excludeTags = Array.isArray(accessibilityOptions?.excludeTagsInTestingScope) ? accessibilityOptions?.excludeTagsInTestingScope : [];
    if (isCucumber) {
      const tagsList = [];
      world?.pickle?.tags.map((tag) => tagsList.push(tag.name));
      const excluded2 = excludeTags?.some((exclude) => tagsList.includes(exclude));
      const included2 = includeTags?.length === 0 || includeTags?.some((include) => tagsList.includes(include));
      return !excluded2 && included2;
    }
    const fullTestName = suiteTitle + " " + testTitle;
    const excluded = excludeTags?.some((exclude) => fullTestName.includes(exclude));
    const included = includeTags?.length === 0 || includeTags?.some((include) => fullTestName.includes(include));
    return !excluded && included;
  } catch (error) {
    BStackLogger.debug(`Error while validating test case for accessibility before scanning. Error : ${error}`);
  }
  return false;
};
var isAccessibilityAutomationSession = (accessibilityFlag) => {
  try {
    const hasA11yJwtToken = typeof process.env.BSTACK_A11Y_JWT === "string" && process.env.BSTACK_A11Y_JWT.length > 0 && process.env.BSTACK_A11Y_JWT !== "null" && process.env.BSTACK_A11Y_JWT !== "undefined";
    return accessibilityFlag && hasA11yJwtToken;
  } catch (error) {
    BStackLogger.debug(`Exception in verifying the Accessibility session with error : ${error}`);
  }
  return false;
};
var isAppAccessibilityAutomationSession = (accessibilityFlag, isAppAutomate) => {
  const accessibilityAutomation = isAccessibilityAutomationSession(accessibilityFlag);
  return accessibilityAutomation && isAppAutomate;
};
var formatString = (template, ...values) => {
  let i = 0;
  if (template === null) {
    return "";
  }
  return template.replace(/%s/g, () => {
    const value = values[i++];
    return value !== null && value !== void 0 ? value : "";
  });
};
var _getParamsForAppAccessibility = (commandName) => {
  return {
    "thTestRunUuid": process.env.TEST_ANALYTICS_ID,
    "thBuildUuid": process.env.BROWSERSTACK_TESTHUB_UUID,
    "thJwtToken": process.env.BROWSERSTACK_TESTHUB_JWT,
    "authHeader": process.env.BSTACK_A11Y_JWT,
    "scanTimestamp": Date.now(),
    "method": commandName
  };
};
var performA11yScan = async (isAppAutomate, browser, isBrowserStackSession, isAccessibility, commandName) => {
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot perform Accessibility scan.");
    return;
  }
  try {
    if (isAppAccessibilityAutomationSession(isAccessibility, isAppAutomate)) {
      const results = await browser.execute(formatString(accessibility_scripts_default.performScan, JSON.stringify(_getParamsForAppAccessibility(commandName))), {});
      BStackLogger.debug(util2.format(results));
      return results;
    }
    if (accessibility_scripts_default.performScan) {
      const results = await executeAccessibilityScript(browser, accessibility_scripts_default.performScan, { method: commandName || "" });
      return results;
    }
    BStackLogger.error("AccessibilityScripts.performScan is null");
    return;
  } catch (err) {
    BStackLogger.error("Accessibility Scan could not be performed : " + err);
    return;
  }
};
var getA11yResults = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility) => {
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results.");
    return [];
  }
  try {
    BStackLogger.debug("Performing scan before getting results");
    await performA11yScan(isAppAutomate, browser, isBrowserStackSession, isAccessibility);
    if (accessibility_scripts_default.getResults) {
      const results = await executeAccessibilityScript(browser, accessibility_scripts_default.getResults);
      return results;
    }
    BStackLogger.error("AccessibilityScripts.getResults is null");
    return [];
  } catch (error) {
    BStackLogger.error("No accessibility results were found.");
    BStackLogger.debug(`getA11yResults Failed. Error: ${error}`);
    return [];
  }
});
var getAppA11yResults = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId) => {
  if (!isBrowserStackSession) {
    return [];
  }
  if (!isAppAccessibilityAutomationSession(isAccessibility, isAppAutomate)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return [];
  }
  try {
    const apiUrl = `${APIUtils.APP_ALLY_ENDPOINT}/${APP_ALLY_ISSUES_ENDPOINT}`;
    const apiRespone = await getAppA11yResultResponse(apiUrl, isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId);
    const result = apiRespone?.data?.data?.issues;
    BStackLogger.debug(`Polling Result: ${JSON.stringify(result)}`);
    return result;
  } catch (error) {
    BStackLogger.error("No accessibility summary was found.");
    BStackLogger.debug(`getAppA11yResults Failed. Error: ${error}`);
    return [];
  }
});
var getAppA11yResultsSummary = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS_SUMMARY, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId) => {
  if (!isBrowserStackSession) {
    return {};
  }
  if (!isAppAccessibilityAutomationSession(isAccessibility, isAppAutomate)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return {};
  }
  try {
    const apiUrl = `${APIUtils.APP_ALLY_ENDPOINT}/${APP_ALLY_ISSUES_SUMMARY_ENDPOINT}`;
    const apiRespone = await getAppA11yResultResponse(apiUrl, isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId);
    const result = apiRespone?.data?.data?.summary;
    BStackLogger.debug(`Polling Result: ${JSON.stringify(result)}`);
    return result;
  } catch {
    BStackLogger.error("No accessibility summary was found.");
    return {};
  }
});
var getAppA11yResultResponse = async (apiUrl, isAppAutomate, browser, isBrowserStackSession, isAccessibility, sessionId) => {
  BStackLogger.debug("Performing scan before getting results summary");
  await performA11yScan(isAppAutomate, browser, isBrowserStackSession, isAccessibility);
  const upperTimeLimit = process.env.BSTACK_A11Y_POLLING_TIMEOUT ? Date.now() + parseInt(process.env.BSTACK_A11Y_POLLING_TIMEOUT) * 1e3 : Date.now() + 3e4;
  const params = { test_run_uuid: process.env.TEST_ANALYTICS_ID, session_id: sessionId, timestamp: Date.now() };
  const header = { Authorization: `Bearer ${process.env.BSTACK_A11Y_JWT}` };
  const apiRespone = await pollApi(apiUrl, params, header, upperTimeLimit);
  BStackLogger.debug(`Polling Result: ${JSON.stringify(apiRespone)}`);
  return apiRespone;
};
var getA11yResultsSummary = PerformanceTester.measureWrapper(A11Y_EVENTS.GET_RESULTS_SUMMARY, async (isAppAutomate, browser, isBrowserStackSession, isAccessibility) => {
  if (!isAccessibilityAutomationSession(isAccessibility)) {
    BStackLogger.warn("Not an Accessibility Automation session, cannot retrieve Accessibility results summary.");
    return {};
  }
  try {
    BStackLogger.debug("Performing scan before getting results summary");
    await performA11yScan(isAppAutomate, browser, isBrowserStackSession, isAccessibility);
    if (accessibility_scripts_default.getResultsSummary) {
      const summaryResults = await executeAccessibilityScript(browser, accessibility_scripts_default.getResultsSummary);
      return summaryResults;
    }
    BStackLogger.error("AccessibilityScripts.getResultsSummary is null");
    return {};
  } catch {
    BStackLogger.error("No accessibility summary was found.");
    return {};
  }
});
var stopBuildUpstream = PerformanceTester.measureWrapper(TESTHUB_EVENTS.STOP, o11yErrorHandler(async function stopBuildUpstream2() {
  const stopBuildUsage = usageStats_default.getInstance().stopBuildUsage;
  stopBuildUsage.triggered();
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    stopBuildUsage.failed("Build is not completed yet");
    return {
      status: "error",
      message: "Build is not completed yet"
    };
  }
  if (!process.env[BROWSERSTACK_TESTHUB_JWT]) {
    stopBuildUsage.failed("Token/buildID is undefined, build creation might have failed");
    BStackLogger.debug("[STOP_BUILD] Missing Authentication Token/ Build ID");
    return {
      status: "error",
      message: "Token/buildID is undefined, build creation might have failed"
    };
  }
  const data = {
    "stop_time": (/* @__PURE__ */ new Date()).toISOString()
  };
  try {
    const url3 = `${APIUtils.DATA_ENDPOINT}/api/v1/builds/${process.env[BROWSERSTACK_TESTHUB_UUID]}/stop`;
    const response = await _fetch(url3, {
      method: "PUT",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${process.env[BROWSERSTACK_TESTHUB_JWT]}`
      },
      body: JSON.stringify(data)
    });
    BStackLogger.debug(`[STOP_BUILD] Success response: ${await response.text()}`);
    stopBuildUsage.success();
    return {
      status: "success",
      message: ""
    };
  } catch (error) {
    stopBuildUsage.failed(error);
    BStackLogger.debug(`[STOP_BUILD] Failed. Error: ${error}`);
    return {
      status: "error",
      message: error.message
    };
  }
}));
function getCiInfo() {
  const env = process.env;
  if (typeof env.JENKINS_URL === "string" && env.JENKINS_URL.length > 0 || typeof env.JENKINS_HOME === "string" && env.JENKINS_HOME.length > 0) {
    return {
      name: "Jenkins",
      build_url: env.BUILD_URL,
      job_name: env.JOB_NAME,
      build_number: env.BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.CIRCLECI)) {
    return {
      name: "CircleCI",
      build_url: env.CIRCLE_BUILD_URL,
      job_name: env.CIRCLE_JOB,
      build_number: env.CIRCLE_BUILD_NUM
    };
  }
  if (isTrue(env.CI) && isTrue(env.TRAVIS)) {
    return {
      name: "Travis CI",
      build_url: env.TRAVIS_BUILD_WEB_URL,
      job_name: env.TRAVIS_JOB_NAME,
      build_number: env.TRAVIS_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && env.CI_NAME === "codeship") {
    return {
      name: "Codeship",
      build_url: null,
      job_name: null,
      build_number: null
    };
  }
  if (env.BITBUCKET_BRANCH && env.BITBUCKET_COMMIT) {
    return {
      name: "Bitbucket",
      build_url: env.BITBUCKET_GIT_HTTP_ORIGIN,
      job_name: null,
      build_number: env.BITBUCKET_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.DRONE)) {
    return {
      name: "Drone",
      build_url: env.DRONE_BUILD_LINK,
      job_name: null,
      build_number: env.DRONE_BUILD_NUMBER
    };
  }
  if (isTrue(env.CI) && isTrue(env.SEMAPHORE)) {
    return {
      name: "Semaphore",
      build_url: env.SEMAPHORE_ORGANIZATION_URL,
      job_name: env.SEMAPHORE_JOB_NAME,
      build_number: env.SEMAPHORE_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.GITLAB_CI)) {
    return {
      name: "GitLab",
      build_url: env.CI_JOB_URL,
      job_name: env.CI_JOB_NAME,
      build_number: env.CI_JOB_ID
    };
  }
  if (isTrue(env.CI) && isTrue(env.BUILDKITE)) {
    return {
      name: "Buildkite",
      build_url: env.BUILDKITE_BUILD_URL,
      job_name: env.BUILDKITE_LABEL || env.BUILDKITE_PIPELINE_NAME,
      build_number: env.BUILDKITE_BUILD_NUMBER
    };
  }
  if (isTrue(env.TF_BUILD) && env.TF_BUILD_BUILDNUMBER) {
    return {
      name: "Visual Studio Team Services",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
      job_name: env.SYSTEM_DEFINITIONID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (isTrue(env.APPVEYOR)) {
    return {
      name: "Appveyor",
      build_url: `${env.APPVEYOR_URL}/project/${env.APPVEYOR_ACCOUNT_NAME}/${env.APPVEYOR_PROJECT_SLUG}/builds/${env.APPVEYOR_BUILD_ID}`,
      job_name: env.APPVEYOR_JOB_NAME,
      build_number: env.APPVEYOR_BUILD_NUMBER
    };
  }
  if (env.AZURE_HTTP_USER_AGENT && env.TF_BUILD) {
    return {
      name: "Azure CI",
      build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
      job_name: env.BUILD_BUILDID,
      build_number: env.BUILD_BUILDID
    };
  }
  if (env.CODEBUILD_BUILD_ID || env.CODEBUILD_RESOLVED_SOURCE_VERSION || env.CODEBUILD_SOURCE_VERSION) {
    return {
      name: "AWS CodeBuild",
      build_url: env.CODEBUILD_PUBLIC_BUILD_URL,
      job_name: env.CODEBUILD_BUILD_ID,
      build_number: env.CODEBUILD_BUILD_ID
    };
  }
  if (env.bamboo_buildNumber) {
    return {
      name: "Bamboo",
      build_url: env.bamboo_buildResultsUrl,
      job_name: env.bamboo_shortJobName,
      build_number: env.bamboo_buildNumber
    };
  }
  if (env.WERCKER || env.WERCKER_MAIN_PIPELINE_STARTED) {
    return {
      name: "Wercker",
      build_url: env.WERCKER_BUILD_URL,
      job_name: env.WERCKER_MAIN_PIPELINE_STARTED ? "Main Pipeline" : null,
      build_number: env.WERCKER_GIT_COMMIT
    };
  }
  if (env.GCP_PROJECT || env.GCLOUD_PROJECT || env.GOOGLE_CLOUD_PROJECT) {
    return {
      name: "Google Cloud",
      build_url: null,
      job_name: env.PROJECT_ID,
      build_number: env.BUILD_ID
    };
  }
  if (env.SHIPPABLE) {
    return {
      name: "Shippable",
      build_url: env.SHIPPABLE_BUILD_URL,
      job_name: env.SHIPPABLE_JOB_ID ? `Job #${env.SHIPPABLE_JOB_ID}` : null,
      build_number: env.SHIPPABLE_BUILD_NUMBER
    };
  }
  if (isTrue(env.NETLIFY)) {
    return {
      name: "Netlify",
      build_url: env.DEPLOY_URL,
      job_name: env.SITE_NAME,
      build_number: env.BUILD_ID
    };
  }
  if (isTrue(env.GITHUB_ACTIONS)) {
    return {
      name: "GitHub Actions",
      build_url: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}`,
      job_name: env.GITHUB_WORKFLOW,
      build_number: env.GITHUB_RUN_ID
    };
  }
  if (isTrue(env.CI) && env.VERCEL === "1") {
    return {
      name: "Vercel",
      build_url: `http://${env.VERCEL_URL}`,
      job_name: null,
      build_number: null
    };
  }
  if (env.TEAMCITY_VERSION) {
    return {
      name: "Teamcity",
      build_url: null,
      job_name: null,
      build_number: env.BUILD_NUMBER
    };
  }
  if (env.CONCOURSE || env.CONCOURSE_URL || env.CONCOURSE_USERNAME || env.CONCOURSE_TEAM) {
    return {
      name: "Concourse",
      build_url: null,
      job_name: env.BUILD_JOB_NAME || null,
      build_number: env.BUILD_ID || null
    };
  }
  if (env.GO_JOB_NAME) {
    return {
      name: "GoCD",
      build_url: null,
      job_name: env.GO_JOB_NAME,
      build_number: env.GO_PIPELINE_COUNTER
    };
  }
  if (env.CF_BUILD_ID) {
    return {
      name: "CodeFresh",
      build_url: env.CF_BUILD_URL,
      job_name: env.CF_PIPELINE_NAME,
      build_number: env.CF_BUILD_ID
    };
  }
  return null;
}
async function getGitMetaData() {
  const info = gitRepoInfo();
  if (!info.commonGitDir) {
    return;
  }
  const { remote } = await pGitconfig(info.commonGitDir);
  const remotes = remote ? Object.keys(remote).map((remoteName) => ({ name: remoteName, url: remote[remoteName].url })) : [];
  let gitMetaData = {
    name: "git",
    sha: info.sha,
    short_sha: info.abbreviatedSha,
    branch: info.branch,
    tag: info.tag,
    committer: info.committer,
    committer_date: info.committerDate,
    author: info.author,
    author_date: info.authorDate,
    commit_message: info.commitMessage,
    root: info.root,
    common_git_dir: info.commonGitDir,
    worktree_git_dir: info.worktreeGitDir,
    last_tag: info.lastTag,
    commits_since_last_tag: info.commitsSinceLastTag,
    remotes
  };
  gitMetaData = checkAndTruncateVCSInfo(gitMetaData);
  return gitMetaData;
}
function getUniqueIdentifier(test, framework) {
  if (framework === "jasmine") {
    return test.fullName;
  }
  let parentTitle = test.parent;
  if (typeof parentTitle === "object") {
    parentTitle = parentTitle.title;
  }
  return `${parentTitle} - ${test.title}`;
}
function getUniqueIdentifierForCucumber(world) {
  return world.pickle.uri + "_" + world.pickle.astNodeIds.join(",");
}
function getCloudProvider(browser) {
  if (browser.options && browser.options.hostname && browser.options.hostname.includes("browserstack")) {
    return "browserstack";
  }
  return "unknown_grid";
}
function isBrowserstackSession(browser) {
  return browser && getCloudProvider(browser).toLowerCase() === "browserstack";
}
function getScenarioExamples(world) {
  const scenario = world.pickle;
  if (scenario.astNodeIds && scenario.astNodeIds.length <= 1 || scenario.astNodeIds === void 0) {
    return;
  }
  const pickleId = scenario.astNodeIds[0];
  const examplesId = scenario.astNodeIds[1];
  const gherkinDocumentChildren = world.gherkinDocument.feature?.children;
  let examples = [];
  gherkinDocumentChildren?.forEach((child) => {
    if (child.rule) {
      child.rule.children.forEach((childLevel2) => {
        if (childLevel2.scenario && childLevel2.scenario.id === pickleId && childLevel2.scenario.examples) {
          const passedExamples = childLevel2.scenario.examples.flatMap((val) => val.tableBody).find((item) => item.id === examplesId)?.cells.map((val) => val.value);
          if (passedExamples) {
            examples = passedExamples;
          }
        }
      });
    } else if (child.scenario && child.scenario.id === pickleId && child.scenario.examples) {
      const passedExamples = child.scenario.examples.flatMap((val) => val.tableBody).find((item) => item.id === examplesId)?.cells.map((val) => val.value);
      if (passedExamples) {
        examples = passedExamples;
      }
    }
  });
  if (examples.length) {
    return examples;
  }
  return;
}
function removeAnsiColors(message) {
  if (!message) {
    return "";
  }
  return message.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, "");
}
function getLogTag(eventType) {
  if (eventType === "TestRunStarted" || eventType === "TestRunFinished") {
    return "Test_Upload";
  } else if (eventType === "HookRunStarted" || eventType === "HookRunFinished") {
    return "Hook_Upload";
  } else if (eventType === "ScreenshotCreated") {
    return "Screenshot_Upload";
  } else if (eventType === "LogCreated") {
    return "Log_Upload";
  }
  return "undefined";
}
function getHookType(hookName) {
  if (hookName.startsWith('"before each"')) {
    return "BEFORE_EACH";
  } else if (hookName.startsWith('"before all"')) {
    return "BEFORE_ALL";
  } else if (hookName.startsWith('"after each"')) {
    return "AFTER_EACH";
  } else if (hookName.startsWith('"after all"')) {
    return "AFTER_ALL";
  }
  return "unknown";
}
function isScreenshotCommand(args) {
  return args.endpoint && args.endpoint.includes("/screenshot");
}
function isBStackSession(config) {
  if (typeof config.user === "string" && typeof config.key === "string" && config.key.length === 20) {
    return true;
  }
  return false;
}
function isBrowserstackInfra(config, caps) {
  const isBrowserstack = (str) => {
    return str === "browserstack.com" || str.endsWith(".browserstack.com");
  };
  if (config.hostname && !isBrowserstack(config.hostname)) {
    return false;
  }
  if (caps && typeof caps === "object") {
    if (Array.isArray(caps)) {
      for (const capability of caps) {
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    } else {
      for (const key in caps) {
        const capability = caps[key];
        if (capability.hostname && !isBrowserstack(capability.hostname)) {
          return false;
        }
      }
    }
  }
  if (!isBStackSession(config)) {
    return false;
  }
  return true;
}
function getBrowserStackUserAndKey(config, options) {
  const envOrServiceVariables = {
    user: getBrowserStackUser(options),
    key: getBrowserStackKey(options)
  };
  if (envOrServiceVariables.user && envOrServiceVariables.key) {
    return envOrServiceVariables;
  }
  const o11yVariables = {
    user: getObservabilityUser(options, config),
    key: getObservabilityKey(options, config)
  };
  return o11yVariables;
}
function shouldAddServiceVersion(config, testObservability, caps) {
  if (config.services && config.services.toString().includes("chromedriver") && testObservability !== false || !isBrowserstackInfra(config, caps)) {
    return false;
  }
  return true;
}
async function batchAndPostEvents(eventUrl, kind, data) {
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    throw new Error("Build not completed yet");
  }
  const jwtToken = process.env[BROWSERSTACK_TESTHUB_JWT];
  if (!jwtToken) {
    throw new Error("Missing authentication Token");
  }
  try {
    const url3 = `${APIUtils.DATA_ENDPOINT}/${eventUrl}`;
    const response = await _fetch(url3, {
      method: "POST",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${jwtToken}`
      },
      body: JSON.stringify(data)
    });
    BStackLogger.debug(`[${kind}] Success response: ${JSON.stringify(await response.json())}`);
  } catch (error) {
    BStackLogger.debug(`[${kind}] EXCEPTION IN ${kind} REQUEST TO TEST REPORTING AND ANALYTICS : ${error}`);
    throw new Error("Exception in request " + error);
  }
}
function getObservabilityUser(options, config) {
  if (process.env.BROWSERSTACK_USERNAME) {
    return process.env.BROWSERSTACK_USERNAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.user) {
    return options.testObservabilityOptions.user;
  }
  return config.user;
}
function getObservabilityKey(options, config) {
  if (process.env.BROWSERSTACK_ACCESS_KEY) {
    return process.env.BROWSERSTACK_ACCESS_KEY;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.key) {
    return options.testObservabilityOptions.key;
  }
  return config.key;
}
function getObservabilityProject(options, bstackProjectName) {
  if (process.env.TEST_OBSERVABILITY_PROJECT_NAME) {
    return process.env.TEST_OBSERVABILITY_PROJECT_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.projectName) {
    return options.testObservabilityOptions.projectName;
  }
  return bstackProjectName;
}
function getObservabilityBuild(options, bstackBuildName) {
  if (process.env.TEST_OBSERVABILITY_BUILD_NAME) {
    return process.env.TEST_OBSERVABILITY_BUILD_NAME;
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildName) {
    return options.testObservabilityOptions.buildName;
  }
  return bstackBuildName || path3.basename(path3.resolve(process.cwd()));
}
function getObservabilityBuildTags(options, bstackBuildTag) {
  if (process.env.TEST_OBSERVABILITY_BUILD_TAG) {
    return process.env.TEST_OBSERVABILITY_BUILD_TAG.split(",");
  }
  if (options.testObservabilityOptions && options.testObservabilityOptions.buildTag) {
    return options.testObservabilityOptions.buildTag;
  }
  if (bstackBuildTag) {
    return [bstackBuildTag];
  }
  return [];
}
function getBrowserStackUser(config) {
  if (process.env.BROWSERSTACK_USERNAME) {
    return process.env.BROWSERSTACK_USERNAME;
  }
  return config.user;
}
function getBrowserStackKey(config) {
  if (process.env.BROWSERSTACK_ACCESS_KEY) {
    return process.env.BROWSERSTACK_ACCESS_KEY;
  }
  return config.key;
}
function isUndefined(value) {
  let res = value === void 0 || value === null;
  if (typeof value === "string") {
    res = res || value === "";
  }
  return res;
}
function isTrue(value) {
  return (value + "").toLowerCase() === "true";
}
function isFalse(value) {
  return (value + "").toLowerCase() === "false";
}
function frameworkSupportsHook(hook, framework) {
  if (framework === "mocha" && (hook === "before" || hook === "after" || hook === "beforeEach" || hook === "afterEach")) {
    return true;
  }
  if (framework === "cucumber") {
    return true;
  }
  return false;
}
var patchConsoleLogs = o11yErrorHandler(() => {
  const BSTestOpsPatcher = new logPatcher_default({});
  Object.keys(consoleHolder).forEach((method) => {
    if (!(method in console) || method === "Console" || typeof console[method] !== "function") {
      BStackLogger.debug(`Skipping method: ${method}, exists: ${method in console}, type: ${typeof console[method]}`);
      return;
    }
    const origMethod = console[method].bind(console);
    console[method] = (...args) => {
      try {
        if (!Object.keys(BSTestOpsPatcher).includes(method)) {
          origMethod(...args);
        } else {
          origMethod(...args);
          BSTestOpsPatcher[method](...args);
        }
      } catch (error) {
        BStackLogger.debug(`Error while patching console logs : ${error}`);
        origMethod(...args);
      }
    };
  });
});
function getFailureObject(error) {
  const stack = error.stack;
  const message = typeof error === "string" ? error : error.message;
  const backtrace = stack ? removeAnsiColors(stack.toString()) : "";
  return {
    failure: [{ backtrace: [backtrace] }],
    failure_reason: removeAnsiColors(message.toString()),
    failure_type: message ? message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError" : null
  };
}
var sleep = (ms = 100) => new Promise((resolve) => setTimeout(resolve, ms));
async function uploadLogs(user, key, clientBuildUuid) {
  try {
    if (!user || !key) {
      BStackLogger.debug("Uploading logs failed due to no credentials");
      return;
    }
    const tmpDir = tmpdir();
    const tarPath = path3.join(tmpDir, "logs.tar");
    const tarGzPath = path3.join(tmpDir, "logs.tar.gz");
    const filesToArchive = [
      BStackLogger.logFilePath,
      CLI_DEBUG_LOGS_FILE
    ].filter((f) => fs3.existsSync(f));
    const copiedFileNames = [];
    for (const f of filesToArchive) {
      const dest = path3.join(tmpDir, path3.basename(f));
      fs3.copyFileSync(f, dest);
      copiedFileNames.push(path3.basename(f));
    }
    await tar.create(
      {
        file: tarPath,
        cwd: tmpDir,
        portable: true,
        noDirRecurse: true
      },
      copiedFileNames
    );
    await new Promise((resolve, reject) => {
      const source = fs3.createReadStream(tarPath);
      const dest = fs3.createWriteStream(tarGzPath);
      const gzip = zlib.createGzip({ level: 1 });
      source.pipe(gzip).pipe(dest);
      dest.on("finish", resolve);
      dest.on("error", reject);
    });
    const formData = new FormData2();
    const file = await fileFromPath(tarGzPath);
    formData.append("data", file, "logs.tar.gz");
    formData.append("clientBuildUuid", clientBuildUuid);
    const auth = Buffer.from(`${user}:${key}`).toString("base64");
    const requestOptions = {
      body: formData,
      headers: {
        "Authorization": `Basic ${auth}`
      }
    };
    const response = await nodeRequest(
      "POST",
      UPLOAD_LOGS_ENDPOINT,
      requestOptions,
      APIUtils.UPLOAD_LOGS_ADDRESS
    );
    fs3.unlinkSync(tarPath);
    fs3.unlinkSync(tarGzPath);
    for (const f of copiedFileNames) {
      const filePath = path3.join(tmpDir, f);
      if (fs3.existsSync(filePath)) {
        fs3.unlinkSync(filePath);
      }
    }
    if (fs3.existsSync(CLI_DEBUG_LOGS_FILE)) {
      fs3.unlinkSync(CLI_DEBUG_LOGS_FILE);
    }
    return response;
  } catch (error) {
    BStackLogger.error(`Error while uploading logs: ${getErrorString(error)}`);
    return null;
  }
}
var isObject = (object) => {
  return object !== null && typeof object === "object" && !Array.isArray(object);
};
var ObjectsAreEqual = (object1, object2) => {
  const objectKeys1 = Object.keys(object1);
  const objectKeys2 = Object.keys(object2);
  if (objectKeys1.length !== objectKeys2.length) {
    return false;
  }
  for (const key of objectKeys1) {
    const value1 = object1[key];
    const value2 = object2[key];
    const isBothAreObjects = isObject(value1) && isObject(value2);
    if (isBothAreObjects && !ObjectsAreEqual(value1, value2) || !isBothAreObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
};
var getPlatformVersion = o11yErrorHandler(function getPlatformVersion2(caps, userCaps) {
  if (!caps && !userCaps) {
    return void 0;
  }
  const bstackOptions = userCaps?.["bstack:options"];
  const keys = ["platformVersion", "platform_version", "osVersion", "os_version"];
  for (const key of keys) {
    if (caps?.[key]) {
      BStackLogger.debug(`Got ${key} from driver caps`);
      return String(caps?.[key]);
    } else if (bstackOptions && bstackOptions?.[key]) {
      BStackLogger.debug(`Got ${key} from user bstack options`);
      return String(bstackOptions?.[key]);
    } else if (userCaps[key]) {
      BStackLogger.debug(`Got ${key} from user caps`);
      return String(userCaps[key]);
    }
  }
  return void 0;
});
var getBasicAuthHeader = (username, password) => {
  const encodedAuth = Buffer.from(`${username}:${password}`, "utf8").toString("base64");
  return `Basic ${encodedAuth}`;
};
var isObjectEmpty = (objectName) => {
  return objectName && Object.keys(objectName).length === 0 && objectName.constructor === Object;
};
var getErrorString = (err) => {
  if (!err) {
    return void 0;
  }
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error) {
    return err.message;
  }
};
function truncateString(field, truncateSizeInBytes) {
  try {
    const bufferSizeInBytes = Buffer.from(GIT_META_DATA_TRUNCATED).length;
    const fieldBufferObj = Buffer.from(field);
    const lenOfFieldBufferObj = fieldBufferObj.length;
    const finalLen = Math.ceil(lenOfFieldBufferObj - truncateSizeInBytes - bufferSizeInBytes);
    if (finalLen > 0) {
      const truncatedString = fieldBufferObj.subarray(0, finalLen).toString() + GIT_META_DATA_TRUNCATED;
      return truncatedString;
    }
  } catch (error) {
    BStackLogger.debug(`Error while truncating field, nothing was truncated here: ${error}`);
  }
  return field;
}
function getSizeOfJsonObjectInBytes(jsonData) {
  try {
    const buffer = Buffer.from(JSON.stringify(jsonData));
    return buffer.length;
  } catch (error) {
    BStackLogger.debug(`Something went wrong while calculating size of JSON object: ${error}`);
  }
  return -1;
}
function checkAndTruncateVCSInfo(gitMetaData) {
  const gitMetaDataSizeInBytes = getSizeOfJsonObjectInBytes(gitMetaData);
  if (gitMetaDataSizeInBytes && gitMetaDataSizeInBytes > MAX_GIT_META_DATA_SIZE_IN_BYTES) {
    const truncateSize = gitMetaDataSizeInBytes - MAX_GIT_META_DATA_SIZE_IN_BYTES;
    const truncatedCommitMessage = truncateString(gitMetaData.commit_message, truncateSize);
    gitMetaData.commit_message = truncatedCommitMessage;
    BStackLogger.info(`The commit has been truncated. Size of commit after truncation is ${getSizeOfJsonObjectInBytes(gitMetaData) / 1024} KB`);
  }
  return gitMetaData;
}
var hasBrowserName = (cap) => {
  if (!cap || !cap.capabilities) {
    return false;
  }
  const browserStackCapabilities = cap.capabilities;
  return browserStackCapabilities.browserName !== void 0;
};
var isValidCapsForHealing = (caps) => {
  const capValues = Object.values(caps);
  return capValues.length > 0 && capValues.some(hasBrowserName);
};
function isTurboScale(options) {
  return Boolean(options?.turboScale);
}
function getObservabilityProduct(options, isAppAutomate) {
  return isAppAutomate ? "app-automate" : isTurboScale(options) ? "turboscale" : "automate";
}
async function pollApi(url3, params, headers, upperLimit, startTime = Date.now()) {
  params.timestamp = Math.round(Date.now() / 1e3);
  BStackLogger.debug(`current timestamp ${params.timestamp}`);
  try {
    const response = await makeGetRequest(url3, params, headers);
    const responseData = await response.json();
    return {
      data: responseData,
      headers: response.headers,
      message: "Polling succeeded."
    };
  } catch (error) {
    if (error.response && error.response.status === 404) {
      const nextPollTime = parseInt(error.response.headers.get("next_poll_time"), 10) * 1e3;
      BStackLogger.debug(`timeInMillis ${nextPollTime}`);
      if (isNaN(nextPollTime)) {
        BStackLogger.warn("Invalid or missing `nextPollTime` header. Stopping polling.");
        return {
          data: {},
          headers: error.response.headers,
          message: "Invalid nextPollTime header value. Polling stopped."
        };
      }
      const elapsedTime = nextPollTime - Date.now();
      BStackLogger.debug(
        `elapsedTime ${elapsedTime} timeInMillis ${nextPollTime} upperLimit ${upperLimit}`
      );
      if (nextPollTime > upperLimit) {
        BStackLogger.warn("Polling stopped due to upper time limit.");
        return {
          data: {},
          headers: error.response.headers,
          message: "Polling stopped due to upper time limit."
        };
      }
      BStackLogger.debug(`Polling again in ${elapsedTime}ms with params:`, params);
      await new Promise((resolve) => setTimeout(resolve, elapsedTime));
      return pollApi(url3, params, headers, upperLimit, startTime);
    } else if (error.response) {
      let errorMessage = error.response.statusText;
      try {
        const parsedError = JSON.parse(error.response.json());
        errorMessage = parsedError.message;
      } catch {
        BStackLogger.debug(`Error parsing pollApi request body ${error.response.body}`);
        errorMessage = "Unknown error";
      }
      throw {
        data: {},
        headers: {},
        message: errorMessage
      };
    } else {
      BStackLogger.error(`Unexpected error occurred: ${error}`);
      return { data: {}, headers: {}, message: "Unexpected error occurred." };
    }
  }
}
async function makeGetRequest(url3, params, headers) {
  const urlObj = new URL(url3);
  Object.keys(params).forEach((key) => urlObj.searchParams.append(key, params[key]));
  const response = await _fetch(urlObj.toString(), {
    method: "GET",
    headers
  });
  if (!response.ok) {
    const error = new Error("Request failed");
    error.response = response;
    throw error;
  }
  return response;
}
async function executeAccessibilityScript(browser, fnBody, arg) {
  return browser.execute(
    `return (function (...bstackSdkArgs) {
            return new Promise((resolve, reject) => {
                const data = bstackSdkArgs[0];
                bstackSdkArgs.push(resolve);
                ${fnBody.replace(/arguments/g, "bstackSdkArgs")}
            });
        })(${arg ? JSON.stringify(arg) : ""})`
  );
}
function generateHashCodeFromFields(fields) {
  const serialize = (value) => {
    if (value && typeof value === "object") {
      return JSON.stringify(value, Object.keys(value).sort());
    }
    return String(value);
  };
  const serialized = fields.map(serialize).join("|");
  return crypto.createHash("sha256").update(serialized).digest("hex");
}
function getBooleanValueFromString(value) {
  if (!value) {
    return false;
  }
  return ["true"].includes(value.trim().toLowerCase());
}
function isSafeKey(key) {
  const dangerousKeys = ["__proto__", "constructor", "prototype"];
  return !dangerousKeys.includes(key);
}
function mergeDeep(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (!isSafeKey(key)) {
        continue;
      }
      const sourceValue = source[key];
      const targetValue = target[key];
      if (isObject(sourceValue)) {
        if (!targetValue || !isObject(targetValue)) {
          target[key] = {};
        }
        mergeDeep(target[key], sourceValue);
      } else {
        target[key] = sourceValue;
      }
    }
  }
  return mergeDeep(target, ...sources);
}
function mergeChromeOptions(base, override) {
  const merged = { ...base };
  if (override.args) {
    merged.args = [...base.args || [], ...override.args];
  }
  if (override.extensions) {
    merged.extensions = [...base.extensions || [], ...override.extensions];
  }
  if (override.prefs) {
    merged.prefs = mergeDeep({ ...base.prefs || {} }, override.prefs);
  }
  return merged;
}
function isNullOrEmpty(string) {
  return !string || string.trim() === "";
}
function isHash(entity) {
  return Boolean(entity && typeof entity === "object" && !Array.isArray(entity));
}
function nestedKeyValue(hash, keys) {
  return keys.reduce((hash2, key) => isHash(hash2) ? hash2[key] : void 0, hash);
}
function removeDir(dir) {
  const list = fs3.readdirSync(dir);
  for (let i = 0; i < list.length; i++) {
    const filename = path3.join(dir, list[i]);
    const stat = fs3.statSync(filename);
    if (filename === "." || filename === "..") {
    } else if (stat.isDirectory()) {
      removeDir(filename);
    } else {
      fs3.unlinkSync(filename);
    }
  }
  fs3.rmdirSync(dir);
}
function createDir(dir) {
  if (fs3.existsSync(dir)) {
    removeDir(dir);
  }
  fs3.mkdirSync(dir, { recursive: true });
}
function isWritable(dirPath) {
  try {
    fs3.accessSync(dirPath, fs3.constants.W_OK);
    return true;
  } catch {
    return false;
  }
}
function setReadWriteAccess(dirPath) {
  try {
    fs3.chmodSync(dirPath, 438);
    BStackLogger.debug(`Directory ${dirPath} is now read/write accessible.`);
  } catch (err) {
    BStackLogger.error(`Failed to set directory access: ${err.stack}`);
  }
}
function getMochaTestHierarchy(test) {
  const value = [];
  if (test.ctx && test.ctx.test) {
    let parent = typeof test.parent === "object" ? test.parent : test.ctx.test.parent;
    while (parent && parent.title !== "") {
      value.push(parent.title);
      parent = parent.parent;
    }
  } else if (test.description && test.fullName) {
    value.push(test.description);
    value.push(test.fullName.replace(new RegExp(" " + test.description + "$"), ""));
  }
  return value.reverse();
}
var performO11ySync = async (browser) => {
  if (isBrowserstackSession(browser)) {
    await browser.execute(`browserstack_executor: ${JSON.stringify({
      action: "annotate",
      arguments: {
        data: `ObservabilitySync:${Date.now()}`,
        level: "debug"
      }
    })}`);
  }
};

// src/bstackLogger.ts
var log = logger("@wdio/browserstack-service");
var BStackLogger = class {
  static logFilePath = path4.join(process.cwd(), LOGS_FILE);
  static logFolderPath = path4.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        this.ensureLogsFolder();
        this.logFileStream = fs4.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk[COLORS[level]](level.toUpperCase())} ${chalk.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log.debug(message, param);
    } else {
      log.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs4.existsSync(this.logFilePath)) {
      fs4.truncateSync(this.logFilePath);
    }
  }
  static ensureLogsFolder() {
    if (!fs4.existsSync(this.logFolderPath)) {
      fs4.mkdirSync(this.logFolderPath);
    }
  }
};

// src/testHub/utils.ts
var getProductMap = (config) => {
  return {
    observability: config.testObservability.enabled,
    accessibility: config.accessibility,
    percy: config.percy,
    automate: config.automate,
    app_automate: config.appAutomate
  };
};
var shouldProcessEventForTesthub = (eventType) => {
  if (isTrue(process.env[BROWSERSTACK_OBSERVABILITY])) {
    return true;
  }
  if (isTrue(process.env[BROWSERSTACK_ACCESSIBILITY])) {
    return !["HookRunStarted", "HookRunFinished", "LogCreated"].includes(eventType);
  }
  if (isTrue(process.env[BROWSERSTACK_PERCY]) && eventType) {
    return false;
  }
  return Boolean(process.env[BROWSERSTACK_ACCESSIBILITY] || process.env[BROWSERSTACK_OBSERVABILITY] || process.env[BROWSERSTACK_PERCY]);
};
var handleErrorForObservability = (error) => {
  process.env[BROWSERSTACK_OBSERVABILITY] = "false";
  logBuildError(error, "Test Reporting and Analytics");
};
var handleErrorForAccessibility = (error) => {
  process.env[BROWSERSTACK_ACCESSIBILITY] = "false";
  logBuildError(error, "accessibility");
};
var logBuildError = (error, product = "") => {
  if (!error || !error.errors) {
    BStackLogger.error(`${product.toUpperCase()} Build creation failed ${error}`);
    return;
  }
  for (const errorJson of error.errors) {
    const errorType = errorJson.key;
    const errorMessage = errorJson.message;
    if (errorMessage) {
      switch (errorType) {
        case "ERROR_INVALID_CREDENTIALS":
          BStackLogger.error(errorMessage);
          break;
        case "ERROR_ACCESS_DENIED":
          BStackLogger.info(errorMessage);
          break;
        case "ERROR_SDK_DEPRECATED":
          BStackLogger.error(errorMessage);
          break;
        default:
          BStackLogger.error(errorMessage);
      }
    }
  }
};
var getProductMapForBuildStartCall = (config, accessibilityAutomation) => {
  return {
    observability: config.testObservability.enabled,
    accessibility: accessibilityAutomation,
    percy: config.percy,
    automate: config.automate,
    app_automate: config.appAutomate
  };
};

// src/Percy/PercyLogger.ts
import path5 from "node:path";
import fs5 from "node:fs";
import chalk2 from "chalk";
import logger2 from "@wdio/logger";
var log2 = logger2("@wdio/browserstack-service");
var PercyLogger = class {
  static logFilePath = path5.join(process.cwd(), PERCY_LOGS_FILE);
  static logFolderPath = path5.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        if (!fs5.existsSync(this.logFolderPath)) {
          fs5.mkdirSync(this.logFolderPath);
        }
        this.logFileStream = fs5.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log2.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk2.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk2[COLORS[level]](level.toUpperCase())} ${chalk2.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log2.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log2.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log2.debug(message, param);
    } else {
      log2.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log2.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log2.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs5.existsSync(this.logFilePath)) {
      fs5.truncateSync(this.logFilePath);
    }
  }
};

// src/Percy/Percy.ts
import fs7 from "node:fs";
import path7 from "node:path";
import os3 from "node:os";
import { spawn as spawn2 } from "node:child_process";

// src/Percy/PercyBinary.ts
import yauzl from "yauzl";
import fs6 from "node:fs";
import fsp from "node:fs/promises";
import { pipeline } from "node:stream/promises";
import path6 from "node:path";
import os2 from "node:os";
import { spawn } from "node:child_process";
var PercyBinary = class {
  #hostOS = process.platform;
  #httpPath = null;
  #binaryName = "percy";
  #orderedPaths = [
    path6.join(os2.homedir(), ".browserstack"),
    process.cwd(),
    os2.tmpdir()
  ];
  constructor() {
    const base = "https://github.com/percy/cli/releases/latest/download";
    if (this.#hostOS.match(/darwin|mac os/i)) {
      this.#httpPath = base + "/percy-osx.zip";
    } else if (this.#hostOS.match(/mswin|msys|mingw|cygwin|bccwin|wince|emc|win32/i)) {
      this.#httpPath = base + "/percy-win.zip";
      this.#binaryName = "percy.exe";
    } else {
      this.#httpPath = base + "/percy-linux.zip";
    }
  }
  async #makePath(path19) {
    if (await this.#checkPath(path19)) {
      return true;
    }
    return fsp.mkdir(path19).then(() => true).catch(() => false);
  }
  async #checkPath(path19) {
    try {
      const hasDir = await fsp.access(path19).then(() => true, () => false);
      if (hasDir) {
        return true;
      }
    } catch {
      return false;
    }
  }
  // Get the path for storing the ETag
  #getETagPath(destParentDir) {
    return path6.join(destParentDir, `${this.#binaryName}.etag`);
  }
  // Load the stored ETag if it exists
  async #loadETag(destParentDir) {
    const etagPath = this.#getETagPath(destParentDir);
    if (await this.#checkPath(etagPath)) {
      try {
        const data = await fsp.readFile(etagPath, "utf8");
        return data.trim();
      } catch (err) {
        BStackLogger.warn(`Failed to read ETag file ${err}`);
      }
    }
    return null;
  }
  // Save the ETag for future use
  async #saveETag(destParentDir, etag) {
    if (!etag) {
      return;
    }
    try {
      const etagPath = this.#getETagPath(destParentDir);
      await fsp.writeFile(etagPath, etag);
      BStackLogger.debug("Saved new ETag for percy binary");
    } catch (err) {
      BStackLogger.error(`Failed to save ETag file ${err}`);
    }
  }
  async #getAvailableDirs() {
    for (let i = 0; i < this.#orderedPaths.length; i++) {
      const path19 = this.#orderedPaths[i];
      if (await this.#makePath(path19)) {
        return path19;
      }
    }
    throw new Error("Error trying to download percy binary");
  }
  async getBinaryPath() {
    const destParentDir = await this.#getAvailableDirs();
    const binaryPath = path6.join(destParentDir, this.#binaryName);
    let response;
    if (await this.#checkPath(binaryPath)) {
      const currentETag = await this.#loadETag(destParentDir);
      if (currentETag) {
        try {
          const result = await this.#checkForUpdate(currentETag);
          if (!result.needsUpdate) {
            BStackLogger.debug("Percy binary is up to date (ETag unchanged)");
            return binaryPath;
          }
          response = result.response;
          BStackLogger.debug("New Percy binary version available, downloading update");
        } catch (err) {
          BStackLogger.warn(`Failed to check for binary updates, using existing binary ${err}`);
          return binaryPath;
        }
      }
    }
    const downloadedBinaryPath = await this.download(destParentDir, response);
    const isValid = await this.validateBinary(downloadedBinaryPath);
    if (!isValid) {
      PercyLogger.error("Corrupt percy binary, retrying");
      return await this.download(destParentDir, response);
    }
    return downloadedBinaryPath;
  }
  async #checkForUpdate(currentETag) {
    try {
      const headers = {
        "If-None-Match": currentETag
      };
      const fetchOptions = {
        method: "GET",
        headers
      };
      const response = await _fetch(this.#httpPath, fetchOptions);
      if (response.status === 304) {
        return { needsUpdate: false };
      }
      const newETag = response.headers.get("eTag");
      if (newETag) {
        await this.#saveETag(path6.dirname(this.#getETagPath(await this.#getAvailableDirs())), newETag);
      }
      return { needsUpdate: true, response };
    } catch (error) {
      BStackLogger.warn(`Error checking for Percy binary updates: ${error}`);
      throw error;
    }
  }
  async validateBinary(binaryPath) {
    const versionRegex = /^.*@percy\/cli \d.\d+.\d+/;
    return new Promise((resolve, reject) => {
      const proc = spawn(binaryPath, ["--version"]);
      proc.stdout.on("data", (data) => {
        if (versionRegex.test(data)) {
          resolve(true);
        }
      });
      proc.on("close", () => {
        resolve(false);
      });
    });
  }
  async download(destParentDir, response) {
    if (!await this.#checkPath(destParentDir)) {
      await fsp.mkdir(destParentDir);
    }
    const binaryName = this.#binaryName;
    const zipFilePath = path6.join(destParentDir, binaryName + ".zip");
    const binaryPath = path6.join(destParentDir, binaryName);
    const downloadedFileStream = fs6.createWriteStream(zipFilePath);
    if (!response) {
      response = await _fetch(this.#httpPath);
    }
    const newETag = response.headers.get("eTag");
    if (newETag) {
      await this.#saveETag(destParentDir, newETag);
    }
    await pipeline(response.body, downloadedFileStream);
    return new Promise((resolve, reject) => {
      yauzl.open(zipFilePath, { lazyEntries: true }, function(err, zipfile) {
        if (err) {
          return reject(err);
        }
        zipfile.readEntry();
        zipfile.on("entry", (entry) => {
          if (/\/$/.test(entry.fileName)) {
            zipfile.readEntry();
          } else {
            const writeStream = fs6.createWriteStream(
              path6.join(destParentDir, entry.fileName)
            );
            zipfile.openReadStream(entry, function(zipErr, readStream) {
              if (zipErr) {
                reject(err);
              }
              readStream.on("end", function() {
                writeStream.close();
                zipfile.readEntry();
              });
              readStream.pipe(writeStream);
            });
            if (entry.fileName === binaryName) {
              zipfile.close();
            }
          }
        });
        zipfile.on("error", (zipErr) => {
          reject(zipErr);
        });
        zipfile.once("end", () => {
          fs6.chmod(binaryPath, "0755", function(zipErr) {
            if (zipErr) {
              reject(zipErr);
            }
            resolve(binaryPath);
          });
          zipfile.close();
        });
      });
    });
  }
};
__decorateClass([
  PerformanceTester.Measure(PERCY_EVENTS.DOWNLOAD)
], PercyBinary.prototype, "download", 1);
var PercyBinary_default = PercyBinary;

// src/Percy/Percy.ts
var logDir = "logs";
var Percy = class {
  #logfile = path7.join(logDir, "percy.log");
  #address = process.env.PERCY_SERVER_ADDRESS || "http://127.0.0.1:5338";
  #binaryPath = null;
  #options;
  #config;
  #proc = null;
  #isApp;
  #projectName = void 0;
  isProcessRunning = false;
  percyCaptureMode;
  buildId = null;
  percyAutoEnabled = false;
  percy;
  constructor(options, config, bsConfig) {
    this.#options = options;
    this.#config = config;
    this.#isApp = Boolean(options.app);
    this.#projectName = bsConfig.projectName;
    this.percyCaptureMode = options.percyCaptureMode;
    this.percy = options.percy ?? false;
  }
  async #getBinaryPath() {
    if (!this.#binaryPath) {
      const pb = new PercyBinary_default();
      this.#binaryPath = await pb.getBinaryPath();
    }
    return this.#binaryPath;
  }
  async healthcheck() {
    try {
      const resp = await nodeRequest("GET", "percy/healthcheck", {}, this.#address);
      if (resp) {
        this.buildId = resp.build.id;
        return true;
      }
    } catch {
      return false;
    }
  }
  async start() {
    const binaryPath = await this.#getBinaryPath();
    const logStream = fs7.createWriteStream(this.#logfile, { flags: "a" });
    const token = await this.fetchPercyToken();
    const configPath = await this.createPercyConfig();
    if (!token) {
      return false;
    }
    const commandArgs = [`${this.#isApp ? "app:exec" : "exec"}:start`];
    if (configPath) {
      commandArgs.push("-c", configPath);
    }
    this.#proc = spawn2(
      binaryPath,
      commandArgs,
      { env: { ...process.env, PERCY_TOKEN: token, TH_BUILD_UUID: process.env[BROWSERSTACK_TESTHUB_UUID] } }
    );
    this.#proc.stdout.pipe(logStream);
    this.#proc.stderr.pipe(logStream);
    this.isProcessRunning = true;
    const that = this;
    this.#proc.on("close", function() {
      that.isProcessRunning = false;
    });
    do {
      const healthcheck = await this.healthcheck();
      if (healthcheck) {
        PercyLogger.debug("Percy healthcheck successful");
        return true;
      }
      await sleep(1e3);
    } while (this.isProcessRunning);
    return false;
  }
  async stop() {
    const binaryPath = await this.#getBinaryPath();
    return new Promise((resolve) => {
      const proc = spawn2(binaryPath, ["exec:stop"]);
      proc.on("close", (code) => {
        this.isProcessRunning = false;
        resolve(code);
      });
    });
  }
  isRunning() {
    return this.isProcessRunning;
  }
  async fetchPercyToken() {
    const projectName = this.#projectName;
    try {
      const type3 = this.#isApp ? "app" : "automate";
      const params = new URLSearchParams();
      if (projectName) {
        params.set("name", projectName);
      }
      if (type3) {
        params.set("type", type3);
      }
      if (this.#options.percyCaptureMode) {
        params.set("percy_capture_mode", this.#options.percyCaptureMode);
      }
      params.set("percy", String(this.#options.percy));
      const query = `api/app_percy/get_project_token?${params.toString()}`;
      const requestInit = {
        headers: {
          Authorization: `Basic ${Buffer.from(`${getBrowserStackUser(this.#config)}:${getBrowserStackKey(this.#config)}`).toString("base64")}`
        }
      };
      const response = await nodeRequest("GET", query, requestInit, APIUtils.BROWSERSTACK_PERCY_API_URL);
      if (!this.#options.percy && response.success) {
        this.percyAutoEnabled = response.success;
      }
      this.percyCaptureMode = response.percy_capture_mode;
      this.percy = response.success;
      if (response.token) {
        PercyLogger.debug("Percy fetch token success: " + response.token);
        return response.token;
      }
      PercyLogger.error("Unable to fetch percy project token");
      return null;
    } catch (err) {
      PercyLogger.error(`Percy unable to fetch project token: ${err}`);
      return null;
    }
  }
  async createPercyConfig() {
    if (!this.#options.percyOptions) {
      return null;
    }
    const configPath = path7.join(os3.tmpdir(), "percy.json");
    const percyOptions = this.#options.percyOptions;
    if (!percyOptions.version) {
      percyOptions.version = "2";
    }
    return new Promise((resolve) => {
      fs7.writeFile(
        configPath,
        JSON.stringify(
          percyOptions
        ),
        (err) => {
          if (err) {
            PercyLogger.error(`Error creating percy config: ${err}`);
            resolve(null);
          }
          PercyLogger.debug("Percy config created at " + configPath);
          resolve(configPath);
        }
      );
    });
  }
};
__decorateClass([
  PerformanceTester.Measure(PERCY_EVENTS.START)
], Percy.prototype, "start", 1);
__decorateClass([
  PerformanceTester.Measure(PERCY_EVENTS.STOP)
], Percy.prototype, "stop", 1);
var Percy_default = Percy;

// src/Percy/PercyHelper.ts
var startPercy = async (options, config, bsConfig) => {
  PercyLogger.debug("Starting percy");
  const percy = new Percy_default(options, config, bsConfig);
  const response = await percy.start();
  if (response) {
    return percy;
  }
  return void 0;
};
var stopPercy = async (percy) => {
  PercyLogger.debug("Stopping percy");
  return percy.stop();
};
var getBestPlatformForPercySnapshot = (capabilities) => {
  try {
    const percyBrowserPreference = { "chrome": 0, "firefox": 1, "edge": 2, "safari": 3 };
    let bestPlatformCaps;
    let bestBrowser;
    if (Array.isArray(capabilities)) {
      capabilities.flatMap((c) => {
        if ("alwaysMatch" in c) {
          return c.alwaysMatch;
        }
        if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
          return Object.values(c).map((o) => o.capabilities);
        }
        return c;
      }).forEach((capability) => {
        let currBrowserName = capability.browserName;
        if (capability["bstack:options"]) {
          currBrowserName = capability["bstack:options"].browserName || currBrowserName;
        }
        if (!bestBrowser || !bestPlatformCaps || (bestPlatformCaps.deviceName || bestPlatformCaps["bstack:options"]?.deviceName)) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = capability;
        } else if (currBrowserName && percyBrowserPreference[currBrowserName.toLowerCase()] < percyBrowserPreference[bestBrowser.toLowerCase()]) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = capability;
        }
      });
      return bestPlatformCaps;
    } else if (typeof capabilities === "object") {
      Object.entries(capabilities).forEach(([, caps]) => {
        let currBrowserName = caps.capabilities.browserName;
        if (caps.capabilities["bstack:options"]) {
          currBrowserName = caps.capabilities["bstack:options"]?.browserName || currBrowserName;
        }
        if (!bestBrowser || !bestPlatformCaps || (bestPlatformCaps.deviceName || bestPlatformCaps["bstack:options"]?.deviceName)) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = caps.capabilities;
        } else if (currBrowserName && percyBrowserPreference[currBrowserName.toLowerCase()] < percyBrowserPreference[bestBrowser.toLowerCase()]) {
          bestBrowser = currBrowserName;
          bestPlatformCaps = caps.capabilities;
        }
      });
      return bestPlatformCaps;
    }
  } catch (err) {
    PercyLogger.error(`Error while trying to determine best platform for Percy snapshot ${err}`);
    return null;
  }
};

// src/config.ts
import { v4 as uuidv4 } from "uuid";
var BrowserStackConfig = class _BrowserStackConfig {
  static getInstance(options, config) {
    if (!this._instance && options && config) {
      this._instance = new _BrowserStackConfig(options, config);
    }
    return this._instance;
  }
  userName;
  accessKey;
  framework;
  buildName;
  buildIdentifier;
  testObservability;
  percy;
  percyCaptureMode;
  accessibility;
  app;
  static _instance;
  appAutomate;
  automate;
  funnelDataSent = false;
  percyBuildId;
  isPercyAutoEnabled = false;
  sdkRunID;
  constructor(options, config) {
    this.framework = config.framework;
    this.userName = config.user;
    this.accessKey = config.key;
    this.testObservability = new testOpsConfig_default(options.testObservability !== false, !isUndefined(options.testObservability));
    this.percy = options.percy || false;
    this.accessibility = options.accessibility !== void 0 ? options.accessibility : null;
    this.app = options.app;
    this.appAutomate = !isUndefined(options.app);
    this.automate = !this.appAutomate;
    this.buildIdentifier = options.buildIdentifier;
    this.sdkRunID = uuidv4();
    BStackLogger.info(`BrowserStack service started with id: ${this.sdkRunID}`);
  }
  sentFunnelData() {
    this.funnelDataSent = true;
  }
};
var config_default = BrowserStackConfig;

// src/exitHandler.ts
import { spawn as spawn4 } from "node:child_process";
import path16 from "node:path";

// src/instrumentation/funnelInstrumentation.ts
import os4 from "node:os";
import util3, { format as format2 } from "node:util";
import path9 from "node:path";
import fs9 from "node:fs";

// src/data-store.ts
import path8 from "node:path";
import fs8 from "node:fs";
var workersDataDirPath = path8.join(process.cwd(), "logs", "worker_data");
function getDataFromWorkers() {
  const workersData = [];
  if (!fs8.existsSync(workersDataDirPath)) {
    return workersData;
  }
  const files = fs8.readdirSync(workersDataDirPath);
  files.forEach((file) => {
    BStackLogger.debug("Reading worker file " + file);
    const filePath = path8.join(workersDataDirPath, file);
    const fileContent = fs8.readFileSync(filePath, "utf8");
    const workerData = JSON.parse(fileContent);
    workersData.push(workerData);
  });
  removeWorkersDataDir();
  return workersData;
}
function saveWorkerData(data) {
  const filePath = path8.join(workersDataDirPath, "worker-data-" + process.pid + ".json");
  try {
    createWorkersDataDir();
    fs8.writeFileSync(filePath, JSON.stringify(data));
  } catch (e) {
    BStackLogger.debug("Exception in saving worker data: " + e);
  }
}
function removeWorkersDataDir() {
  fs8.rmSync(workersDataDirPath, { recursive: true, force: true });
  return true;
}
function createWorkersDataDir() {
  if (!fs8.existsSync(workersDataDirPath)) {
    fs8.mkdirSync(workersDataDirPath, { recursive: true });
  }
  return true;
}

// src/instrumentation/funnelInstrumentation.ts
async function fireFunnelTestEvent(eventType, config) {
  if (!config.userName || !config.accessKey) {
    BStackLogger.debug("username/accesskey not passed");
    return;
  }
  try {
    const data = buildEventData(eventType, config);
    await fireFunnelRequest(data);
    BStackLogger.debug("Funnel event success");
    config.sentFunnelData();
  } catch (error) {
    BStackLogger.debug(`Exception in sending funnel data: ${format2(error)}`);
  }
}
async function sendStart(config) {
  await fireFunnelTestEvent("SDKTestAttempted", config);
}
async function sendFinish(config) {
  await fireFunnelTestEvent("SDKTestSuccessful", config);
}
function saveFunnelData(eventType, config) {
  const data = buildEventData(eventType, config);
  BStackLogger.ensureLogsFolder();
  const filePath = path9.join(BStackLogger.logFolderPath, "funnelData.json");
  fs9.writeFileSync(filePath, JSON.stringify(data));
  return filePath;
}
function redactCredentialsFromFunnelData(data) {
  if (data) {
    if (data.userName) {
      data.userName = "[REDACTED]";
    }
    if (data.accessKey) {
      data.accessKey = "[REDACTED]";
    }
  }
  return data;
}
async function fireFunnelRequest(data) {
  const { userName, accessKey } = data;
  redactCredentialsFromFunnelData(data);
  BStackLogger.debug("Sending SDK event with data " + util3.inspect(data, { depth: 6 }));
  const encodedAuth = Buffer.from(`${userName}:${accessKey}`, "utf8").toString("base64");
  const response = await fetchWrap(APIUtils.FUNNEL_INSTRUMENTATION_URL, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      Authorization: `Basic ${encodedAuth}`
    },
    body: JSON.stringify(data)
  });
  BStackLogger.debug("Funnel Event Response: " + JSON.stringify(await response.text()));
}
function getProductList(config) {
  const products = [];
  if (config.testObservability.enabled) {
    products.push("observability");
  }
  if (config.accessibility) {
    products.push("accessibility");
  }
  if (config.percy) {
    products.push("percy");
  }
  if (config.automate) {
    products.push("automate");
  }
  if (config.appAutomate) {
    products.push("app-automate");
  }
  return products;
}
function buildEventData(eventType, config) {
  const eventProperties = {
    // Framework Details
    sdkRunId: config?.sdkRunID,
    testhub_uuid: testOpsConfig_default.getInstance().buildHashedId,
    language_framework: getLanguageFramework(config.framework),
    referrer: getReferrer(config.framework),
    language: "WebdriverIO",
    languageVersion: process.version,
    // Build Details
    buildName: config.buildName || "undefined",
    buildIdentifier: String(config.buildIdentifier),
    // Host details
    os: os4.type() || "unknown",
    hostname: os4.hostname() || "unknown",
    // Product Details
    productMap: getProductMap(config),
    product: getProductList(config),
    // framework details
    framework: config.framework
  };
  if (eventType === "SDKTestSuccessful") {
    const workerData = getDataFromWorkers();
    eventProperties.productUsage = getProductUsage(workerData);
    if (process.env.BSTACK_A11Y_POLLING_TIMEOUT) {
      eventProperties.pollingTimeout = process.env.BSTACK_A11Y_POLLING_TIMEOUT;
    }
  }
  return {
    userName: config.userName,
    accessKey: config.accessKey,
    event_type: eventType,
    detectedFramework: WDIO_NAMING_PREFIX + config.framework,
    event_properties: eventProperties
  };
}
function getProductUsage(workersData) {
  return {
    testObservability: usageStats_default.getInstance().getFormattedData(workersData)
  };
}
function getLanguageFramework(framework) {
  return "WebdriverIO_" + framework;
}
function getReferrer(framework) {
  const fullName = framework ? WDIO_NAMING_PREFIX + framework : "WebdriverIO";
  return `${fullName}/${BSTACK_SERVICE_VERSION}`;
}
var sendEvent = {
  tcgDown: (config) => fireFunnelTestEvent("SDKTestTcgDownResponse", config),
  invalidTcgAuth: (config) => fireFunnelTestEvent("SDKTestInvalidTcgAuthResponseWithUserImpact", config),
  tcgAuthFailure: (config) => fireFunnelTestEvent("SDKTestTcgAuthFailure", config),
  tcgtInitSuccessful: (config) => fireFunnelTestEvent("SDKTestTcgtInitSuccessful", config),
  initFailed: (config) => fireFunnelTestEvent("SDKTestInitFailedResponse", config),
  tcgProxyFailure: (config) => fireFunnelTestEvent("SDKTestTcgProxyFailure", config)
};
function isProxyError(authResult) {
  return authResult?.status === 502;
}
function handleProxyError(config, isSelfHealEnabled) {
  sendEvent.tcgProxyFailure(config);
  if (isSelfHealEnabled) {
    BStackLogger.warn("Proxy Error. Disabling Healing for this session.");
  }
}
function handleUpgradeRequired(isSelfHealEnabled) {
  if (isSelfHealEnabled) {
    BStackLogger.warn("Please upgrade Browserstack Service to the latest version to use the self-healing feature.");
  }
}
function handleAuthenticationFailure(status, config, isSelfHealEnabled) {
  if (status >= 500) {
    if (isSelfHealEnabled) {
      BStackLogger.warn("Something went wrong. Disabling healing for this session. Please try again later.");
    }
    sendEvent.tcgDown(config);
  } else {
    if (isSelfHealEnabled) {
      BStackLogger.warn("Authentication Failed. Disabling Healing for this session.");
    }
    sendEvent.tcgAuthFailure(config);
  }
}
function handleAuthenticationSuccess(isHealingEnabledForUser, userId, config, isSelfHealEnabled) {
  if (!isHealingEnabledForUser && isSelfHealEnabled) {
    BStackLogger.warn("Healing is not enabled for your group, please contact the admin");
  } else if (userId && isHealingEnabledForUser) {
    sendEvent.tcgtInitSuccessful(config);
  }
}
function handleInitializationFailure(status, config, isSelfHealEnabled) {
  if (status >= 400) {
    sendEvent.initFailed(config);
  } else if (!status && isSelfHealEnabled) {
    sendEvent.invalidTcgAuth(config);
  }
  if (isSelfHealEnabled) {
    BStackLogger.warn("Authentication Failed. Healing will be disabled for this session.");
  }
}
function handleHealingInstrumentation(authResult, config, isSelfHealEnabled) {
  try {
    if (isProxyError(authResult)) {
      handleProxyError(config, isSelfHealEnabled);
      return;
    }
    const { message, isAuthenticated, status, userId, groupId, isHealingEnabled: isHealingEnabledForUser } = authResult;
    if (message === "Upgrade required") {
      handleUpgradeRequired(isSelfHealEnabled);
      return;
    }
    if (!isAuthenticated) {
      handleAuthenticationFailure(status, config, isSelfHealEnabled);
      return;
    }
    if (isAuthenticated && userId && groupId) {
      handleAuthenticationSuccess(isHealingEnabledForUser, userId, config, isSelfHealEnabled);
      return;
    }
    if (status >= 400 || !status) {
      handleInitializationFailure(status, config, isSelfHealEnabled);
      return;
    }
  } catch (err) {
    BStackLogger.debug("Error in handling healing instrumentation: " + err);
  }
}

// src/exitHandler.ts
import { fileURLToPath as fileURLToPath2 } from "node:url";

// src/cli/index.ts
import util10 from "node:util";
import { spawn as spawn3 } from "node:child_process";

// src/cli/cliUtils.ts
import fs11 from "node:fs";
import fsp2 from "node:fs/promises";
import { platform as platform3, arch as arch3, homedir } from "node:os";
import path11 from "node:path";
import util4, { promisify as promisify2 } from "node:util";
import { exec } from "node:child_process";
import { Readable } from "node:stream";
import yauzl2 from "yauzl";
import { threadId } from "node:worker_threads";

// src/cli/cliLogger.ts
import path10 from "node:path";
import fs10 from "node:fs";
import chalk3 from "chalk";
import logger3 from "@wdio/logger";
var log3 = logger3("@wdio/browserstack-service/cli");
var BStackLogger2 = class {
  static logFilePath = path10.join(process.cwd(), LOGS_FILE);
  static logFolderPath = path10.join(process.cwd(), "logs");
  static logFileStream;
  static logToFile(logMessage, logLevel) {
    try {
      if (!this.logFileStream) {
        this.ensureLogsFolder();
        this.logFileStream = fs10.createWriteStream(this.logFilePath, { flags: "a" });
      }
      if (this.logFileStream && this.logFileStream.writable) {
        this.logFileStream.write(this.formatLog(logMessage, logLevel));
      }
    } catch (error) {
      log3.debug(`Failed to log to file. Error ${error}`);
    }
  }
  static formatLog(logMessage, level) {
    return `${chalk3.gray((/* @__PURE__ */ new Date()).toISOString())} ${chalk3[COLORS[level]](level.toUpperCase())} ${chalk3.whiteBright("@wdio/browserstack-service")} ${logMessage}
`;
  }
  static info(message) {
    this.logToFile(message, "info");
    log3.info(message);
  }
  static error(message) {
    this.logToFile(message, "error");
    log3.error(message);
  }
  static debug(message, param) {
    this.logToFile(message, "debug");
    if (param) {
      log3.debug(message, param);
    } else {
      log3.debug(message);
    }
  }
  static warn(message) {
    this.logToFile(message, "warn");
    log3.warn(message);
  }
  static trace(message) {
    this.logToFile(message, "trace");
    log3.trace(message);
  }
  static clearLogger() {
    if (this.logFileStream) {
      this.logFileStream.end();
    }
    this.logFileStream = null;
  }
  static clearLogFile() {
    if (fs10.existsSync(this.logFilePath)) {
      fs10.truncateSync(this.logFilePath);
    }
  }
  static ensureLogsFolder() {
    if (!fs10.existsSync(this.logFolderPath)) {
      fs10.mkdirSync(this.logFolderPath);
    }
  }
};

// src/cli/frameworks/constants/testFrameworkConstants.ts
var TestFrameworkConstants = {
  KEY_TEST_UUID: "test_uuid",
  KEY_TEST_ID: "test_id",
  KEY_TEST_NAME: "test_name",
  KEY_TEST_FILE_PATH: "test_file_path",
  KEY_TEST_TAGS: "test_tags",
  KEY_TEST_RESULT: "test_result",
  KEY_TEST_RESULT_AT: "test_result_at",
  KEY_TEST_STARTED_AT: "test_started_at",
  KEY_TEST_ENDED_AT: "test_ended_at",
  KEY_TEST_LOCATION: "test_location",
  KEY_TEST_SCOPE: "test_scope",
  KEY_TEST_SCOPES: "test_scopes",
  KEY_TEST_FRAMEWORK_NAME: "test_framework_name",
  KEY_TEST_FRAMEWORK_VERSION: "test_framework_version",
  KEY_TEST_CODE: "test_code",
  KEY_TEST_RERUN_NAME: "test_rerun_name",
  KEY_PLATFORM_INDEX: "platform_index",
  KEY_TEST_FAILURE: "test_failure",
  KEY_TEST_FAILURE_TYPE: "test_failure_type",
  KEY_TEST_FAILURE_REASON: "test_failure_reason",
  KEY_TEST_LOGS: "test_logs",
  KEY_TEST_META: "test_meta",
  KEY_TEST_DEFERRED: "test_deferred",
  KEY_SESSION_NAME: "test_session_name",
  KEY_AUTOMATE_SESSION_NAME: "automate_session_name",
  KEY_AUTOMATE_SESSION_STATUS: "automate_session_status",
  KEY_AUTOMATE_SESSION_REASON: "automate_session_reason",
  KEY_EVENT_STARTED_AT: "event_started_at",
  KEY_EVENT_ENDED_AT: "event_ended_at",
  KEY_HOOK_ID: "hook_id",
  KEY_HOOK_RESULT: "hook_result",
  KEY_HOOK_LOGS: "hook_logs",
  KEY_HOOK_NAME: "hook_name",
  KEY_HOOKS_STARTED: "test_hooks_started",
  KEY_HOOKS_FINISHED: "test_hooks_finished",
  DEFAULT_TEST_RESULT: "pending",
  DEFAULT_HOOK_RESULT: "pending",
  KIND_SCREENSHOT: "TEST_SCREENSHOT",
  KIND_LOG: "TEST_LOG",
  HOOK_REGEX: "^(BEFORE_|AFTER_)"
};

// src/cli/cliUtils.ts
var CLIUtils = class _CLIUtils {
  static automationFrameworkDetail = {};
  static testFrameworkDetail = {};
  static CLISupportedFrameworks = ["mocha"];
  static isDevelopmentEnv() {
    return process.env.BROWSERSTACK_CLI_ENV === "development";
  }
  static getCLIParamsForDevEnv() {
    return {
      id: process.env.BROWSERSTACK_CLI_ENV || "",
      listen: `unix:/tmp/sdk-platform-${process.env.BROWSERSTACK_CLI_ENV}.sock`
    };
  }
  /**
   * Build config object for binary session request
   * @returns {string}
   * @throws {Error}
   */
  static getBinConfig(config, capabilities, options, buildTag) {
    const modifiedOpts = { ...options };
    if (modifiedOpts.opts) {
      modifiedOpts.browserStackLocalOptions = modifiedOpts.opts;
      delete modifiedOpts.opts;
    }
    modifiedOpts.testContextOptions = {
      skipSessionName: isFalse(modifiedOpts.setSessionName),
      skipSessionStatus: isFalse(modifiedOpts.setSessionStatus),
      sessionNameOmitTestTitle: modifiedOpts.sessionNameOmitTestTitle || false,
      sessionNamePrependTopLevelSuiteTitle: modifiedOpts.sessionNamePrependTopLevelSuiteTitle || false,
      sessionNameFormat: modifiedOpts.sessionNameFormat || ""
    };
    const commonBstackOptions = (() => {
      if (capabilities && !Array.isArray(capabilities) && typeof capabilities === "object" && "bstack:options" in capabilities) {
        return capabilities["bstack:options"] || {};
      }
      return {};
    })();
    const isNonBstackA11y = isTurboScale(options) || !shouldAddServiceVersion(config, options.testObservability);
    const observabilityOptions = options.testObservabilityOptions || {};
    const binconfig = {
      userName: observabilityOptions.user || config.user,
      accessKey: observabilityOptions.key || config.key,
      platforms: [],
      isNonBstackA11yWDIO: isNonBstackA11y,
      ...modifiedOpts,
      ...commonBstackOptions
    };
    binconfig.buildName = observabilityOptions.buildName || binconfig.buildName;
    binconfig.projectName = observabilityOptions.projectName || binconfig.projectName;
    binconfig.buildTag = this.getObservabilityBuildTags(observabilityOptions, buildTag) || [];
    let caps = capabilities;
    if (capabilities && !Array.isArray(capabilities)) {
      caps = [capabilities];
    }
    if (Array.isArray(caps)) {
      for (const cap of caps) {
        const platform4 = {};
        const capability = cap;
        Object.keys(capability).filter((key) => key !== "bstack:options").forEach((key) => {
          platform4[key] = capability[key];
        });
        if (capability["bstack:options"]) {
          Object.keys(capability["bstack:options"]).forEach((key) => {
            platform4[key] = capability["bstack:options"][key];
          });
        }
        binconfig.platforms.push(platform4);
      }
    }
    return JSON.stringify(binconfig);
  }
  static getSdkVersion() {
    return BSTACK_SERVICE_VERSION;
  }
  static getSdkLanguage() {
    return "ECMAScript";
  }
  static async setupCliPath(config) {
    BStackLogger2.debug("Configuring Cli path.");
    const developmentBinaryPath = process.env.SDK_CLI_BIN_PATH || null;
    if (!isNullOrEmpty(developmentBinaryPath)) {
      BStackLogger2.debug(`Development Cli Path: ${developmentBinaryPath}`);
      return developmentBinaryPath;
    }
    try {
      const cliDir = this.getCliDir();
      if (isNullOrEmpty(cliDir)) {
        throw new Error("No writable directory available for the CLI");
      }
      const existingCliPath = this.getExistingCliPath(cliDir);
      const finalBinaryPath = await this.checkAndUpdateCli(existingCliPath, cliDir, config);
      BStackLogger2.debug(`Resolved binary path: ${finalBinaryPath}`);
      return finalBinaryPath;
    } catch (err) {
      BStackLogger2.debug(`Error in setting up cli path directory, Exception: ${util4.format(err)}`);
    }
    return null;
  }
  static async checkAndUpdateCli(existingCliPath, cliDir, config) {
    PerformanceTester.start(EVENTS.SDK_CLI_CHECK_UPDATE);
    BStackLogger2.info(`Current CLI Path Found: ${existingCliPath}`);
    const queryParams = {
      sdk_version: _CLIUtils.getSdkVersion(),
      os: platform3(),
      os_arch: arch3(),
      cli_version: "0",
      sdk_language: this.getSdkLanguage()
    };
    if (!isNullOrEmpty(existingCliPath)) {
      queryParams.cli_version = await this.runShellCommand(`${existingCliPath} version`);
    }
    const response = await this.requestToUpdateCLI(queryParams, config);
    if (nestedKeyValue(response, ["updated_cli_version"])) {
      BStackLogger2.debug(`Need to update binary, current binary version: ${queryParams.cli_version}`);
      const browserStackBinaryUrl = process.env.BROWSERSTACK_BINARY_URL || null;
      if (!isNullOrEmpty(browserStackBinaryUrl)) {
        BStackLogger2.debug(`Using BROWSERSTACK_BINARY_URL: ${browserStackBinaryUrl}`);
        response.url = browserStackBinaryUrl;
      }
      const finalBinaryPath = await this.downloadLatestBinary(nestedKeyValue(response, ["url"]), cliDir);
      PerformanceTester.end(EVENTS.SDK_CLI_CHECK_UPDATE);
      return finalBinaryPath;
    }
    PerformanceTester.end(EVENTS.SDK_CLI_CHECK_UPDATE);
    return existingCliPath;
  }
  static getCliDir() {
    const writableDir = this.getWritableDir();
    try {
      if (isNullOrEmpty(writableDir)) {
        throw new Error("No writable directory available for the CLI");
      }
      const cliDirPath = path11.join(writableDir, "cli");
      if (!fs11.existsSync(cliDirPath)) {
        createDir(cliDirPath);
      }
      return cliDirPath;
    } catch (err) {
      BStackLogger2.error(`Error in getting writable directory, writableDir=${util4.format(err)}`);
      return "";
    }
  }
  static getWritableDir() {
    const writableDirOptions = [
      process.env.BROWSERSTACK_FILES_DIR,
      path11.join(homedir(), ".browserstack"),
      path11.join("tmp", ".browserstack")
    ];
    for (const path19 of writableDirOptions) {
      if (isNullOrEmpty(path19)) {
        continue;
      }
      try {
        if (fs11.existsSync(path19)) {
          BStackLogger2.debug(`File ${path19} already exist`);
          if (!isWritable(path19)) {
            BStackLogger2.debug(`Giving write permission to ${path19}`);
            const success = setReadWriteAccess(path19);
            if (!isTrue(success)) {
              BStackLogger2.warn(`Unable to provide write permission to ${path19}`);
            }
          }
        } else {
          BStackLogger2.debug(`File does not exist: ${path19}`);
          createDir(path19);
          BStackLogger2.debug(`Giving write permission to ${path19}`);
          const success = setReadWriteAccess(path19);
          if (!isTrue(success)) {
            BStackLogger2.warn(`Unable to provide write permission to ${path19}`);
          }
        }
        return path19;
      } catch (err) {
        BStackLogger2.error(`Unable to get writable directory, exception ${util4.format(err)}`);
      }
    }
    return null;
  }
  static getExistingCliPath(cliDir) {
    try {
      if (!fs11.existsSync(cliDir) || !fs11.statSync(cliDir).isDirectory()) {
        return "";
      }
      const allBinaries = fs11.readdirSync(cliDir).map((file) => path11.join(cliDir, file)).filter((filePath) => fs11.statSync(filePath).isFile() && path11.basename(filePath).startsWith("binary-"));
      if (allBinaries.length > 0) {
        const latestBinary = allBinaries.map((filePath) => ({
          filePath,
          mtime: fs11.statSync(filePath).mtime
        })).reduce((latest, current) => {
          if (!latest || !latest.mtime) {
            return current;
          }
          if (current.mtime > latest.mtime) {
            return current;
          }
          return latest;
        }, null);
        return latestBinary ? latestBinary.filePath : "";
      }
      return "";
    } catch (err) {
      BStackLogger2.error(`Error while reading CLI path: ${util4.format(err)}`);
      return "";
    }
  }
  static requestToUpdateCLI = async (queryParams, config) => {
    const params = new URLSearchParams(queryParams);
    const requestInit = {
      method: "GET",
      headers: {
        Authorization: `Basic ${Buffer.from(`${getBrowserStackUser(config)}:${getBrowserStackKey(config)}`).toString("base64")}`
      }
    };
    const response = await _fetch(`${APIUtils.BROWSERSTACK_AUTOMATE_API_URL}/${UPDATED_CLI_ENDPOINT}?${params.toString()}`, requestInit);
    const jsonResponse = await response.json();
    BStackLogger2.debug(`response ${JSON.stringify(jsonResponse)}`);
    return jsonResponse;
  };
  static runShellCommand(cmdCommand, workingDir = "") {
    return new Promise((resolve) => {
      const process2 = exec(
        cmdCommand,
        { cwd: workingDir, timeout: 5e3 },
        (error, stdout, stderr) => {
          if (error) {
            resolve(stderr.trim() || "SHELL_EXECUTE_ERROR");
          } else {
            resolve(stdout.trim());
          }
        }
      );
      process2.on("error", () => {
        resolve("SHELL_EXECUTE_ERROR");
      });
    });
  }
  static downloadLatestBinary = async (binDownloadUrl, cliDir) => {
    PerformanceTester.start(EVENTS.SDK_CLI_DOWNLOAD);
    BStackLogger2.debug(`Downloading SDK binary from: ${binDownloadUrl}`);
    try {
      const zipFilePath = path11.join(cliDir, "downloaded_file.zip");
      const downloadedFileStream = fs11.createWriteStream(zipFilePath);
      return new Promise((resolve, reject) => {
        const binaryName = null;
        const processDownload = async () => {
          const response = await _fetch(binDownloadUrl);
          if (!response.body) {
            throw new Error("No response body received");
          }
          downloadedFileStream.on("error", function(err) {
            BStackLogger2.error("Got Error while downloading cli binary file" + err);
            PerformanceTester.end(EVENTS.SDK_CLI_DOWNLOAD, false, util4.format(err));
            reject(err);
          });
          try {
            const arrayBuffer = await response.arrayBuffer();
            const buffer = Buffer.from(arrayBuffer);
            const nodeStream = Readable.from(buffer);
            nodeStream.pipe(downloadedFileStream);
            _CLIUtils.downloadFileStream(downloadedFileStream, binaryName, zipFilePath, cliDir, resolve, reject);
            PerformanceTester.end(EVENTS.SDK_CLI_DOWNLOAD);
          } catch (err) {
            BStackLogger2.error(`Got Error in cli binary downloading request ${util4.format(err)}`);
            PerformanceTester.end(EVENTS.SDK_CLI_DOWNLOAD, false, util4.format(err));
            reject(err);
          }
        };
        processDownload();
      });
    } catch (err) {
      PerformanceTester.end(EVENTS.SDK_CLI_DOWNLOAD, false, util4.format(err));
      BStackLogger2.debug(`Failed to download binary, Exception: ${util4.format(err)}`);
      return null;
    }
  };
  static downloadFileStream(downloadedFileStream, binaryName, zipFilePath, cliDir, resolve, reject) {
    downloadedFileStream.on("close", async function() {
      const yauzlOpenPromise = promisify2(yauzl2.open);
      try {
        const zipfile = await yauzlOpenPromise(zipFilePath, { lazyEntries: true });
        zipfile.readEntry();
        zipfile.on("entry", async (entry) => {
          if (!binaryName) {
            binaryName = entry.fileName;
          }
          if (/\/$/.test(entry.fileName)) {
            zipfile.readEntry();
          } else {
            const writeStream = fs11.createWriteStream(path11.join(cliDir, entry.fileName));
            const openReadStreamPromise = promisify2(zipfile.openReadStream).bind(zipfile);
            try {
              const readStream = await openReadStreamPromise(entry);
              readStream.on(
                "end",
                function() {
                  writeStream.close();
                  zipfile.readEntry();
                }
              );
              readStream.pipe(
                writeStream
              );
            } catch (zipErr) {
              reject(zipErr);
            }
            if (entry.fileName === binaryName) {
              zipfile.close();
            }
          }
        });
        zipfile.on("error", (zipErr) => {
          reject(zipErr);
        });
        zipfile.once("end", () => {
          fsp2.unlink(zipFilePath).catch(() => {
            BStackLogger2.warn(`Failed to delete zip file: ${zipFilePath}`);
          });
          fsp2.chmod(`${cliDir}/${binaryName}`, "0755").then(() => {
            resolve(`${cliDir}/${binaryName}`);
          }).catch((err) => {
            reject(err);
          });
          zipfile.close();
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  static getTestFrameworkDetail() {
    if (process.env.BROWSERSTACK_TEST_FRAMEWORK_DETAIL) {
      return JSON.parse(process.env.BROWSERSTACK_TEST_FRAMEWORK_DETAIL);
    }
    return this.testFrameworkDetail;
  }
  static getAutomationFrameworkDetail() {
    if (process.env.BROWSERSTACK_AUTOMATION_FRAMEWORK_DETAIL) {
      return JSON.parse(process.env.BROWSERSTACK_AUTOMATION_FRAMEWORK_DETAIL);
    }
    return this.automationFrameworkDetail;
  }
  static setFrameworkDetail(testFramework, automationFramework) {
    if (!testFramework || !automationFramework) {
      BStackLogger2.debug(`Test or Automation framework not provided testFramework=${testFramework}, automationFramework=${automationFramework}`);
    }
    this.testFrameworkDetail = {
      name: testFramework,
      version: { [testFramework]: _CLIUtils.getSdkVersion() }
    };
    this.automationFrameworkDetail = {
      name: automationFramework,
      version: { [automationFramework]: _CLIUtils.getSdkVersion() }
    };
    process.env.BROWSERSTACK_AUTOMATION_FRAMEWORK_DETAIL = JSON.stringify(this.automationFrameworkDetail);
    process.env.BROWSERSTACK_TEST_FRAMEWORK_DETAIL = JSON.stringify(this.testFrameworkDetail);
  }
  /**
   * Get the current instance name using thread id and processId
   * @returns {string}
   */
  static getCurrentInstanceName() {
    return `${process.pid}:${threadId}`;
  }
  /**
   *
   * @param {TestFrameworkState | AutomationFrameworkState} frameworkState
   * @param {HookState} hookState
   * @returns {string}
   */
  static getHookRegistryKey(frameworkState, hookState) {
    return `${frameworkState}:${hookState}`;
  }
  static matchHookRegex(hookState) {
    const pattern = new RegExp(TestFrameworkConstants.HOOK_REGEX);
    return pattern.test(hookState);
  }
  static getObservabilityBuildTags(observabilityOptions, bstackBuildTag) {
    if (process.env.TEST_OBSERVABILITY_BUILD_TAG) {
      return process.env.TEST_OBSERVABILITY_BUILD_TAG.split(",");
    }
    if (observabilityOptions.buildTag) {
      return observabilityOptions.buildTag;
    }
    if (bstackBuildTag) {
      return [bstackBuildTag];
    }
    return [];
  }
  static checkCLISupportedFrameworks(framework) {
    if (framework === void 0) {
      return false;
    }
    return this.CLISupportedFrameworks.includes(framework);
  }
};

// src/cli/grpcClient.ts
import path12 from "node:path";
import util5, { promisify as promisify3 } from "node:util";
import {
  SDKClient,
  grpcCredentials,
  grpcChannel,
  StartBinSessionRequestConstructor,
  StopBinSessionRequestConstructor,
  ConnectBinSessionRequestConstructor,
  TestFrameworkEventRequestConstructor,
  TestSessionEventRequestConstructor,
  ExecutionContextConstructor,
  LogCreatedEventRequestConstructor,
  LogCreatedEventRequest_LogEntryConstructor,
  AutomationSessionConstructor,
  DriverInitRequestConstructor,
  FetchDriverExecuteParamsEventRequestConstructor
} from "@browserstack/wdio-browserstack-service";
var GrpcClient = class _GrpcClient {
  static #instance = null;
  binSessionId;
  listenAddress;
  channel = null;
  client = null;
  logger = BStackLogger2;
  constructor() {
  }
  /**
   * Get the singleton instance of GrpcClient
   * @returns {GrpcClient} The singleton instance
   */
  static getInstance() {
    if (!_GrpcClient.#instance) {
      _GrpcClient.#instance = new _GrpcClient();
    }
    return _GrpcClient.#instance;
  }
  /**
   * Initialize the gRPC client connection
   * @param {string} host The gRPC server host
   * @param {number} port The gRPC server port
   */
  init(params) {
    const { id, listen } = params;
    if (!id || !listen) {
      throw new Error(`Unable to find listen addr or bin session id binSessionId: ${id} listenAddr: ${listen}`);
    }
    this.binSessionId = id;
    this.listenAddress = listen;
    process.env.BROWSERSTACK_CLI_BIN_SESSION_ID = this.binSessionId;
    process.env.BROWSERSTACK_CLI_BIN_LISTEN_ADDR = this.listenAddress;
    this.connect();
    this.logger.info(`Initialized gRPC client with bin session id: ${this.binSessionId} and listen address: ${this.listenAddress}`);
  }
  /**
   * Connect to the gRPC server
   * @returns {void}
   */
  connect() {
    let listenAddress = this.listenAddress;
    if (!listenAddress) {
      listenAddress = process.env.BROWSERSTACK_CLI_BIN_LISTEN_ADDR;
    }
    if (!this.binSessionId) {
      this.binSessionId = this.binSessionId || process.env.BROWSERSTACK_CLI_BIN_SESSION_ID;
    }
    if (!listenAddress) {
      throw new Error("Unable to determine gRPC server listen address");
    }
    this.channel = new grpcChannel(
      listenAddress,
      grpcCredentials.createInsecure(),
      {
        "grpc.keepalive_time_ms": 1e4
      }
    );
    this.client = new SDKClient(
      listenAddress,
      grpcCredentials.createInsecure(),
      {}
    );
    this.logger.info(`Connected to gRPC server at ${listenAddress}`);
  }
  async startBinSession(wdioConfig) {
    PerformanceTester.start(EVENTS.SDK_START_BIN_SESSION);
    this.logger.debug("startBinSession: Calling startBinSession");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const packageVersion = CLIUtils.getSdkVersion();
      const automationFrameworkDetail = CLIUtils.getAutomationFrameworkDetail();
      const testFrameworkDetail = CLIUtils.getTestFrameworkDetail();
      const frameworkVersions = {
        ...automationFrameworkDetail.version,
        ...testFrameworkDetail.version
      };
      const request = StartBinSessionRequestConstructor.create({
        binSessionId: this.binSessionId,
        sdkLanguage: CLIUtils.getSdkLanguage(),
        sdkVersion: packageVersion,
        pathProject: process.cwd(),
        pathConfig: path12.resolve(process.cwd(), "browserstack.yml"),
        cliArgs: process.argv.slice(2),
        frameworks: [automationFrameworkDetail.name, testFrameworkDetail.name],
        frameworkVersions,
        language: CLIUtils.getSdkLanguage(),
        testFramework: testFrameworkDetail.name,
        wdioConfig
      });
      const startBinSessionPromise = promisify3(this.client.startBinSession).bind(this.client);
      try {
        const response = await startBinSessionPromise(request);
        this.logger.info("StartBinSession successful");
        PerformanceTester.end(EVENTS.SDK_START_BIN_SESSION);
        return response;
      } catch (error) {
        this.logger.error(`StartBinSession error: ${util5.format(error)}`);
        PerformanceTester.end(EVENTS.SDK_START_BIN_SESSION, false, util5.format(error));
        throw error;
      }
    } catch (error) {
      this.logger.error(`Error in startBinSession: ${util5.format(error)}`);
      PerformanceTester.end(EVENTS.SDK_START_BIN_SESSION, false, util5.format(error));
      throw error;
    }
  }
  /**
   * Connect to the bin session
   * @returns {Promise<Object>} The response from the gRPC call
   */
  async connectBinSession() {
    PerformanceTester.start(EVENTS.SDK_CONNECT_BIN_SESSION);
    this.logger.debug("Connecting bin session");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const request = ConnectBinSessionRequestConstructor.create({
        binSessionId: this.binSessionId
      });
      const connectBinSessionPromise = promisify3(this.client.connectBinSession).bind(this.client);
      try {
        const response = await connectBinSessionPromise(request);
        this.logger.info("ConnectBinSession successful");
        PerformanceTester.end(EVENTS.SDK_CONNECT_BIN_SESSION);
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`ConnectBinSession error: ${errorMessage}`);
        PerformanceTester.end(EVENTS.SDK_CONNECT_BIN_SESSION, false, errorMessage);
        throw error;
      }
    } catch (error) {
      PerformanceTester.end(EVENTS.SDK_CONNECT_BIN_SESSION, false, util5.format(error));
      this.logger.error(`Error in connectBinSession: ${util5.format(error)}`);
      throw error;
    }
  }
  /**
   * Stop the bin session
   * @returns {Promise<void>}
   * @private
   */
  async stopBinSession() {
    PerformanceTester.start(EVENTS.SDK_CLI_ON_STOP);
    this.logger.debug("Stopping bin session");
    try {
      if (!this.binSessionId) {
        throw new Error("Missing binSessionId");
      }
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const request = StopBinSessionRequestConstructor.create({
        binSessionId: this.binSessionId
      });
      const stopBinSessionPromise = promisify3(this.client.stopBinSession).bind(this.client);
      try {
        const response = await stopBinSessionPromise(request);
        this.logger.info("StopBinSession successful");
        PerformanceTester.end(EVENTS.SDK_CLI_ON_STOP);
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`StopBinSession error: ${errorMessage}`);
        PerformanceTester.end(EVENTS.SDK_CLI_ON_STOP, false, errorMessage);
        throw error;
      }
    } catch (error) {
      PerformanceTester.end(EVENTS.SDK_CLI_ON_STOP, false, util5.format(error));
      this.logger.error(`Error in stopBinSession: ${util5.format(error)}`);
    }
  }
  async testSessionEvent(data) {
    this.logger.info("Sending TestSessionEvent");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const { platformIndex, testFrameworkName, testFrameworkVersion, testFrameworkState, testHookState, testUuid, automationSessions, capabilities, executionContext } = data;
      const sessions = automationSessions.map((automationSession) => {
        return AutomationSessionConstructor.create({
          provider: automationSession.provider,
          frameworkName: automationSession.frameworkName,
          frameworkVersion: automationSession.frameworkVersion,
          frameworkSessionId: automationSession.frameworkSessionId,
          ref: automationSession.ref,
          hubUrl: automationSession.hubUrl
        });
      });
      const executionContextBuilder = ExecutionContextConstructor.create({
        processId: executionContext?.processId,
        threadId: executionContext?.threadId,
        hash: executionContext?.hash
      });
      const request = TestSessionEventRequestConstructor.create({
        binSessionId: this.binSessionId,
        platformIndex,
        testFrameworkName,
        testFrameworkVersion,
        testFrameworkState,
        testHookState,
        testUuid,
        capabilities,
        automationSessions: sessions,
        executionContext: executionContextBuilder
      });
      const testSessionEventPromise = promisify3(this.client.testSessionEvent).bind(this.client);
      try {
        const response = await testSessionEventPromise(request);
        this.logger.info("testSessionEvent successful");
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`testSessionEvent error: ${errorMessage}`);
        throw error;
      }
    } catch (error) {
      this.logger.error(`Error in TestSessionEvent: ${util5.format(error)}`);
      throw error;
    }
  }
  /**
   *
   * Send TestFrameworkEvent
   */
  async testFrameworkEvent(data) {
    this.logger.info("Sending TestFrameworkEvent");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const { platformIndex, testFrameworkName, testFrameworkVersion, testFrameworkState, testHookState, startedAt, endedAt, uuid, eventJson, executionContext } = data;
      const executionContextBuilder = ExecutionContextConstructor.create({
        processId: executionContext?.processId,
        threadId: executionContext?.threadId,
        hash: executionContext?.hash
      });
      const request = TestFrameworkEventRequestConstructor.create({
        binSessionId: this.binSessionId,
        platformIndex,
        testFrameworkName,
        testFrameworkVersion,
        testFrameworkState,
        testHookState,
        startedAt,
        endedAt,
        uuid,
        eventJson,
        executionContext: executionContextBuilder
      });
      const testFrameworkEventPromise = promisify3(this.client.testFrameworkEvent).bind(this.client);
      try {
        const response = await testFrameworkEventPromise(request);
        this.logger.info("testFrameworkEvent successful");
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`testFrameworkEvent error: ${errorMessage}`);
        throw error;
      }
    } catch (error) {
      this.logger.error(`Error in TestFrameworkEvent: ${util5.format(error)}`);
      throw error;
    }
  }
  /**
   *
   * Send driverInitEvent
   */
  async driverInitEvent(data) {
    this.logger.info("Sending driverInitEvent");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const { platformIndex, ref, userInputParams } = data;
      const request = DriverInitRequestConstructor.create({
        binSessionId: this.binSessionId,
        platformIndex,
        ref,
        userInputParams
      });
      const driverInitEventPromise = promisify3(this.client.driverInit).bind(this.client);
      try {
        const response = await driverInitEventPromise(request);
        this.logger.info("driverInitEvent successful");
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`driverInitEvent error: ${errorMessage}`);
        throw error;
      }
    } catch (error) {
      this.logger.error(`Error in driverInitEvent: ${util5.format(error)}`);
      throw error;
    }
  }
  async logCreatedEvent(data) {
    this.logger.info("Sending LogCreatedEvent");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const { platformIndex, logs, executionContext } = data;
      const executionContextBuilder = ExecutionContextConstructor.create({
        processId: executionContext?.processId,
        threadId: executionContext?.threadId,
        hash: executionContext?.hash
      });
      const logEntries = [];
      for (const log4 of logs) {
        const logEntry = LogCreatedEventRequest_LogEntryConstructor.create({
          testFrameworkName: log4.testFrameworkName,
          testFrameworkVersion: log4.testFrameworkVersion,
          testFrameworkState: log4.testFrameworkState,
          uuid: log4.uuid,
          kind: log4.kind,
          message: log4.message,
          timestamp: log4.timestamp,
          level: log4.level
        });
        logEntries.push(logEntry);
      }
      const request = LogCreatedEventRequestConstructor.create({
        binSessionId: this.binSessionId,
        platformIndex,
        logs: logEntries,
        executionContext: executionContextBuilder
      });
      const logCreatedEventPromise = promisify3(this.client.logCreatedEvent).bind(this.client);
      try {
        this.logger.debug("logCreatedEvent payload:" + JSON.stringify(request));
        const response = await logCreatedEventPromise(request);
        this.logger.info("logCreatedEvent successful");
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`logCreatedEvent error: ${errorMessage}`);
        throw error;
      }
    } catch (error) {
      this.logger.error(`Error in LogCreatedEvent: ${util5.format(error)}`);
      throw error;
    }
  }
  async fetchDriverExecuteParamsEvent(data) {
    this.logger.info("Sending fetchDriverExecuteParamsEvent");
    try {
      if (!this.client) {
        this.logger.info("No gRPC client not initialized.");
      }
      const { product, scriptName } = data;
      const request = FetchDriverExecuteParamsEventRequestConstructor.create({
        binSessionId: this.binSessionId,
        product,
        scriptName
      });
      const fetchDriverExecuteParamsEventPromise = promisify3(this.client.fetchDriverExecuteParamsEvent).bind(this.client);
      try {
        const response = await fetchDriverExecuteParamsEventPromise(request);
        this.logger.info("fetchDriverExecuteParamsEvent successful");
        return response;
      } catch (error) {
        const errorMessage = util5.format(error);
        this.logger.error(`fetchDriverExecuteParamsEvent error: ${errorMessage}`);
        throw error;
      }
    } catch (error) {
      this.logger.error(`Error in fetchDriverExecuteParamsEvent: ${util5.format(error)}`);
      throw error;
    }
  }
  /**
   * Get the gRPC channel
   * @returns {grpc.Channel} The gRPC channel
   */
  getClient() {
    return this.client;
  }
  /**
   * Get the gRPC channel
   * @returns {grpc.Channel} The gRPC channel
   */
  getChannel() {
    return this.channel;
  }
};

// src/cli/modules/baseModule.ts
var BaseModule = class {
  #name;
  binSessionId;
  platformIndex;
  config;
  client;
  /**
   * Create a new BaseModule
   */
  constructor() {
    this.#name = "BaseModule";
    this.binSessionId = null;
    this.platformIndex = 0;
    this.config = {};
    this.client = null;
  }
  /**
   * Ensure that a bin session ID is available
   * @throws {Error} If binSessionId is missing
   */
  ensureBinSession() {
    if (!this.binSessionId) {
      throw new Error("Missing binSessionId");
    }
  }
  /**
   * Get the name of the module
   * @returns {string} The module name
   */
  getModuleName() {
    return this.#name;
  }
  /**
   * Configure the module with session information
   * @param {string} binSessionId - The bin session ID
   * @param {number} platformIndex - The platform index
   * @param {SDKClient | null} client - The gRPC client service
   * @param {Object} config - Configuration options
   */
  configure(binSessionId, platformIndex, client, config = {}) {
    this.binSessionId = binSessionId;
    this.platformIndex = platformIndex;
    this.client = client;
    this.config = config;
    BStackLogger2.debug(`Configured module ${this.getModuleName()} with binSessionId=${binSessionId}, platformIndex=${platformIndex}`);
  }
};

// src/cli/eventDispatcher.ts
var EventDispatcher = class _EventDispatcher {
  static #instance = null;
  observers;
  constructor() {
    this.observers = {};
  }
  /**
  * Get the EventDispatcher singleton instance
  * @returns {EventDispatcher} The singleton instance
  */
  static getInstance() {
    if (!_EventDispatcher.#instance) {
      _EventDispatcher.#instance = new _EventDispatcher();
    }
    return _EventDispatcher.#instance;
  }
  /**
  * Add event observer
  * @param {string} event - Event name
  * @param {Function} callback - Callback function
  */
  registerObserver(hookRegistryKey, callback) {
    if (!this.observers[hookRegistryKey]) {
      this.observers[hookRegistryKey] = [];
    }
    this.observers[hookRegistryKey].push(callback);
  }
  /**
  * Notify registered observers on an event
  * @param {string} event - Event name
  * @param {*} data - Event data
  */
  async notifyObserver(event, args) {
    if (this.observers[event]) {
      for (const callback of this.observers[event]) {
        await callback(args);
      }
      return;
    }
  }
};
var eventDispatcher = EventDispatcher.getInstance();
Object.freeze(eventDispatcher);

// src/cli/instances/trackedContext.ts
var TrackedContext = class {
  #id;
  #threadId;
  #processId;
  #type;
  /**
  * Create TrackedContext
  * @param {number} string - string Id for context - VERIFY
  * @param {number} threadId- Integer Thread Id for context
  * @param {number} processId - Integer Process Id for context
  * @param {string} type
  */
  constructor(id, threadId3, processId, type3) {
    this.#id = id;
    this.#threadId = threadId3;
    this.#processId = processId;
    this.#type = type3;
  }
  /**
  * get TrackedContext thread id
  * @returns {number} - return thread id of context
  */
  getThreadId() {
    return this.#threadId;
  }
  /**
  * get TrackedContext process id
  * @returns {number} - return process id of context
  */
  getProcessId() {
    return this.#processId;
  }
  /**
  * get TrackedContext id
  * @returns {string} - returns context id
  */
  getId() {
    return this.#id;
  }
  /**
  * get TrackedContext type
  * @returns {string}
  */
  getType() {
    return this.#type;
  }
};

// src/cli/instances/trackedInstance.ts
import crypto2 from "node:crypto";
import { threadId as threadId2 } from "node:worker_threads";
var TrackedInstance = class {
  #context;
  // We have a very generic type usage, unknown or {} is not working here
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  #data;
  /**
  * create TrackedInstance
  * @param {TrackedContext} context
  */
  constructor(context) {
    this.#context = context;
    this.#data = /* @__PURE__ */ new Map();
  }
  /**
  * get TrackedInstance ref
  * @returns {number} - returns ref id
  */
  getRef() {
    return this.#context.getId();
  }
  /**
  * get TrackedInstance context
  * @return {TrackedContext} - returns tracked context
  */
  getContext() {
    return this.#context;
  }
  /**
  * get All data of Instance
  * @returns {Map} - returns all data
  */
  getAllData() {
    return this.#data;
  }
  /**
  * set multiple data in the instance
  * @param {*} key
  * @param {*} value
  */
  // We have a very generic type usage, unknown or {} is not working here
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  updateMultipleEntries(entries) {
    Object.keys(entries).forEach((key) => {
      this.#data.set(key, entries[key]);
    });
  }
  // We have a very generic type usage, unknown or {} is not working here
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  updateData(key, value) {
    this.#data.set(key, value);
  }
  /**
  * get Specific data of instance.
  * @param {*} key
  * @returns {*}
  */
  getData(key) {
    return this.#data.get(key);
  }
  hasData(key) {
    return this.#data.has(key);
  }
  static createContext(target) {
    return new TrackedContext(
      crypto2.createHash("sha256").update(target).digest("hex"),
      threadId2 || 0,
      process.pid,
      typeof target
    );
  }
};

// src/cli/frameworks/testFramework.ts
var TestFramework = class _TestFramework {
  static instances = /* @__PURE__ */ new Map();
  testFrameworks = [];
  testFrameworkVersions = {};
  binSessionId = null;
  /**
   * Constructor for the TestFramework
   * @param {Array} testFrameworks - List of Test frameworks
   * @param {Map} testFrameworkVersions - Name of the Test frameworks
   * @param {string} binSessionId - BinSessionId
  */
  constructor(testFrameworks, testFrameworkVersions, binSessionId) {
    this.testFrameworks = testFrameworks;
    this.testFrameworkVersions = testFrameworkVersions;
    this.binSessionId = binSessionId;
  }
  /**
   * get all instances
   * @return {Map} - return all instances Map
  */
  getInstances() {
    return _TestFramework.instances;
  }
  /**
   * set testFrameworkInstance
   * @param {TrackedContext} context
   * @param {TestFrameworkInstance} instance
  */
  setInstance(context, instance) {
    _TestFramework.instances.set(context.getId, instance);
  }
  /**
   * Find instance and track any state for the test framework
   * @returns instance
  */
  static getTrackedInstance() {
    const ctx = TrackedInstance.createContext(CLIUtils.getCurrentInstanceName());
    return _TestFramework.instances.get(ctx.getId());
  }
  /**
  * Set tracked instance
  * @returns {string} The name of the test framework
  */
  static setTrackedInstance(context, instance) {
    _TestFramework.instances.set(context.getId(), instance);
  }
  /**
  * get all test framework versions
  * @returns {Map} - return all versions of framework available.
  */
  getTestFrameworksVersions() {
    return this.testFrameworkVersions;
  }
  /**
  * get all test frameworks
  * @returns {Array} - return all test frameworks
  */
  getTestFrameworks() {
    return this.testFrameworks;
  }
  /**
  * Track an event
  * @param {TestFrameworkState} testFrameworkState
  * @param {HookState} hookState
  * @param {*} args
  * @returns {void}
  */
  trackEvent(testFrameworkState, hookState, args = {}) {
    BStackLogger2.info(`trackEvent: testFrameworkState=${testFrameworkState}; hookState=${hookState}; args=${args}`);
  }
  /**
  * run test hooks
  * @param {TestFrameworkInstance} instance
  * @param {TestFrameworkState} testFrameworkState
  * @param {HookState} hookState
  * @param {*} args
  */
  async runHooks(instance, testFrameworkState, hookState, args = {}) {
    BStackLogger2.info(`runHooks: instance=${instance} automationFrameworkState=${testFrameworkState} hookState=${hookState}`);
    const hookRegistryKey = CLIUtils.getHookRegistryKey(testFrameworkState, hookState);
    await eventDispatcher.notifyObserver(hookRegistryKey, args);
  }
  /**
  * Register an observer
  * @param {TestFrameworkState} testFrameworkState
  * @param {HookState} hookState
  * @param {*} callback
  * @returns {void}
  */
  static registerObserver(testFrameworkState, hookState, callback) {
    eventDispatcher.registerObserver(CLIUtils.getHookRegistryKey(testFrameworkState, hookState), callback);
  }
  /**
  * Resolve instance for the test framework
  * @param {TestFrameworkInstance} testFrameworkInstance
  * @param {string} key
  * @returns {TestFrameworkInstance}
  */
  static getState(instance, key) {
    return instance.getAllData().get(key);
  }
  static hasState(instance, key) {
    return instance.hasData(key);
  }
  /**
  * Set the state
  * @param {TrackedInstance} instance - The instance
  * @param {string} key - The key
  * @param {*} value - The value
  * @returns
  */
  static setState(instance, key, value) {
    instance.getAllData().set(key, value);
  }
  updateInstanceState(instance, testFrameworkState, hookState) {
    instance.setLastTestState(instance.getCurrentTestState());
    instance.setLastHookState(instance.getCurrentHookState());
    instance.setCurrentTestState(testFrameworkState);
    instance.setCurrentHookState(hookState);
  }
};

// src/cli/states/testFrameworkState.ts
var TestFrameworkState = Object.freeze({
  /**
   * Initial state, no session created
   */
  NONE: {
    value: 0,
    toString() {
      return "TestFrameworkState.NONE";
    }
  },
  /**
   * Framework instance is being beforeAll
   */
  BEFORE_ALL: {
    value: 1,
    toString() {
      return "TestFrameworkState.BEFORE_ALL";
    }
  },
  /**
   * Framework is in log state
   */
  LOG: {
    value: 2,
    toString() {
      return "TestFrameworkState.LOG";
    }
  },
  /**
   * Framework is in setup fixture state
   */
  SETUP_FIXTURE: {
    value: 3,
    toString() {
      return "TestFrameworkState.SETUP_FIXTURE";
    }
  },
  /**
   * Framework is in init test
   */
  INIT_TEST: {
    value: 4,
    toString() {
      return "TestFrameworkState.INIT_TEST";
    }
  },
  /**
   * Framework is in beforeEach
   */
  BEFORE_EACH: {
    value: 5,
    toString() {
      return "TestFrameworkState.BEFORE_EACH";
    }
  },
  /**
   * Framework is in afterEach
   */
  AFTER_EACH: {
    value: 6,
    toString() {
      return "TestFrameworkState.AFTER_EACH";
    }
  },
  /**
   * Framework is test executing
   */
  TEST: {
    value: 7,
    toString() {
      return "TestFrameworkState.TEST";
    }
  },
  /**
   * Framework is in step state
   */
  STEP: {
    value: 8,
    toString() {
      return "TestFrameworkState.STEP";
    }
  },
  /**
   * Framework is log reporting state
   */
  LOG_REPORT: {
    value: 9,
    toString() {
      return "TestFrameworkState.LOG_REPORT";
    }
  },
  /**
   * Framework is in afterAll state
   */
  AFTER_ALL: {
    value: 10,
    toString() {
      return "TestFrameworkState.AFTER_ALL";
    }
  }
});

// src/cli/states/hookState.ts
var HookState = Object.freeze({
  /**
   * No hook, initial state
   */
  NONE: {
    value: 0,
    toString() {
      return "HookState.NONE";
    }
  },
  /**
   * Pre-execution hook
   */
  PRE: {
    value: 1,
    toString() {
      return "HookState.PRE";
    }
  },
  /**
   * Post-execution hook
   */
  POST: {
    value: 2,
    toString() {
      return "HookState.POST";
    }
  }
});

// src/cli/frameworks/constants/automationFrameworkConstants.ts
var AutomationFrameworkConstants = {
  ENV_BROWSERSTACK_PLATFORM_INDEX: "BROWSERSTACK_PLATFORM_INDEX",
  KEY_HUB_URL: "hub_url",
  KEY_FRAMEWORK_SESSION_ID: "framework_session_id",
  KEY_INPUT_CAPABILITIES: "input_capabilities",
  KEY_CAPABILITIES: "capabilities",
  KEY_IS_BROWSERSTACK_HUB: "is_browserstack_hub",
  KEY_STARTED_AT: "started_at",
  KEY_ENDED_AT: "ended_at",
  KEY_PLATFORM_INDEX: "platform_index",
  COMMAND_NEW_SESSION: "newsession",
  COMMAND_GET: "get",
  COMMAND_SCREENSHOT: "screenshot",
  COMMAND_W3C_EXECUTE_SCRIPT: "w3cexecutescript",
  COMMAND_W3C_EXECUTE_SCRIPT_ASYNC: "w3cexecutescriptasync",
  COMMAND_QUIT: "quit"
};

// src/cli/frameworks/automationFramework.ts
var AutomationFramework = class _AutomationFramework {
  #automationFrameworkName;
  #automationFrameworkVersion;
  static instances = /* @__PURE__ */ new Map();
  static KEY_AUTOMATION_SESSIONS = "automation_sessions";
  static KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS = "non_browserstack_automation_sessions";
  /**
   * Constructor for the AutomationFramework
   * @param {string} automationFrameworkName - Name of the automation framework
   * @param {string} automationFrameworkVersion - Version of the automation framework
  */
  constructor(automationFrameworkName, automationFrameworkVersion) {
    this.#automationFrameworkName = automationFrameworkName;
    this.#automationFrameworkVersion = automationFrameworkVersion;
  }
  /**
  * Get the automation framework name
  * @returns {string} The name of the automation framework
  */
  getAutomationFrameworkName() {
    return this.#automationFrameworkName;
  }
  /**
  * Get the automation framework version
  * @returns {string} The version of the automation framework
  */
  getAutomationFrameworkVersion() {
    return this.#automationFrameworkVersion;
  }
  /**
  * Track an event
  * @param {Object}
  * @param {Object}
  * @param {Object}
  * @returns {void}
  */
  async trackEvent(automationFrameworkState, hookState, args = {}) {
    BStackLogger2.info(`trackEvent: automationFrameworkState=${automationFrameworkState} hookState=${hookState} args=${args}`);
  }
  /**
  *
  * @param {*} instance
  * @param {*} automationFrameworkState
  * @param {*} hookState
  * @param {*} args
  */
  async runHooks(instance, automationFrameworkState, hookState, args = {}) {
    BStackLogger2.info(`runHooks: automationFrameworkState=${automationFrameworkState} hookState=${hookState}`);
    const hookRegistryKey = CLIUtils.getHookRegistryKey(automationFrameworkState, hookState);
    await eventDispatcher.notifyObserver(hookRegistryKey, args);
  }
  /**
  * Register an observer
  * @returns {void}
  */
  static registerObserver(automationFrameworkState, hookState, callback) {
    eventDispatcher.registerObserver(CLIUtils.getHookRegistryKey(automationFrameworkState, hookState), callback);
  }
  /**
  * Set the tracked instance
  * @param {TrackedInstance} context - The context
  * @param {TrackedInstance} instance - The instance
  * @returns {void}
  */
  static setTrackedInstance(context, instance) {
    BStackLogger2.debug(`setTrackedInstance: ${context.getId()}`);
    _AutomationFramework.instances.set(context.getId(), instance);
  }
  /**
  * Get the tracked instance
  * @returns {TrackedInstance} The tracked instance
  */
  static getTrackedInstance() {
    BStackLogger2.debug(`getTrackedInstance: ${CLIUtils.getCurrentInstanceName()}`);
    const context = TrackedInstance.createContext(CLIUtils.getCurrentInstanceName());
    return _AutomationFramework.instances.get(context.getId());
  }
  /**
  * Set the state
  * @param {TrackedInstance} instance - The instance
  * @param {string} key - The key
  * @param {*} value - The value
  * @returns
  */
  static setState(instance, key, value) {
    instance.getAllData().set(key, value);
  }
  /**
  * Get the state
  * @param {TrackedInstance} instance - The instance
  * @param {string} key - The key
  * @returns {*} The state
  */
  static getState(instance, key) {
    return instance.getAllData().get(key);
  }
  static isAutomationSession(instance) {
    return _AutomationFramework.getState(instance, AutomationFrameworkConstants.KEY_IS_BROWSERSTACK_HUB);
  }
  /**
   * Set the driver for the automation framework instance
   * @param {AutomationFrameworkInstance} instance - The automation framework instance
   * @param {*} driver - The driver object
   */
  static setDriver(instance, driver) {
    if (this.isAutomationSession(instance)) {
      _AutomationFramework.setState(instance, _AutomationFramework.KEY_AUTOMATION_SESSIONS, driver);
    } else {
      _AutomationFramework.setState(instance, _AutomationFramework.KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS, driver);
    }
  }
  /**
   * Get the driver from the automation framework instance
   * @param {AutomationFrameworkInstance} instance - The automation framework instance
   * @returns {*} The driver object or null
   */
  static getDriver(instance) {
    let driver = null;
    driver = this.isAutomationSession(instance) ? _AutomationFramework.getState(instance, _AutomationFramework.KEY_AUTOMATION_SESSIONS) || null : _AutomationFramework.getState(instance, _AutomationFramework.KEY_NON_BROWSERSTACK_AUTOMATION_SESSIONS) || null;
    return driver;
  }
};

// src/cli/states/automationFrameworkState.ts
var AutomationFrameworkState = Object.freeze({
  /**
  * Initial state, no session created
  */
  NONE: {
    value: 0,
    toString() {
      return "AutomationFrameworkState.NONE";
    }
  },
  /**
  * Framework instance is being created
  */
  CREATE: {
    value: 1,
    toString() {
      return "AutomationFrameworkState.CREATE";
    }
  },
  /**
  * Framework is executing tests
  */
  EXECUTE: {
    value: 2,
    toString() {
      return "AutomationFrameworkState.EXECUTE";
    }
  },
  /**
  * Framework is idle, not executing any tests
  */
  IDLE: {
    value: 3,
    toString() {
      return "AutomationFrameworkState.IDLE";
    }
  },
  /**
  * Framework is shutting down
  */
  QUIT: {
    value: 4,
    toString() {
      return "AutomationFrameworkState.QUIT";
    }
  }
});

// src/cli/modules/automateModule.ts
import util6 from "node:util";
var AutomateModule = class _AutomateModule extends BaseModule {
  logger = BStackLogger2;
  browserStackConfig;
  sessionMap = /* @__PURE__ */ new Map();
  static MODULE_NAME = "AutomateModule";
  /**
   * Create a new AutomateModule
   */
  constructor(browserStackConfig) {
    super();
    this.browserStackConfig = browserStackConfig;
    this.logger.info("AutomateModule: Initializing Automate Module");
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.PRE, this.onBeforeTest.bind(this));
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.POST, this.onAfterTest.bind(this));
    TestFramework.registerObserver(AutomationFrameworkState.EXECUTE, HookState.POST, this.onAfterExecute.bind(this));
  }
  getModuleName() {
    return _AutomateModule.MODULE_NAME;
  }
  async onBeforeTest(args) {
    this.logger.info("onbeforeTest: inside automate module before test hook!");
    const instace = args.instance;
    const autoInstance = AutomationFramework.getTrackedInstance();
    const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
    const browser = AutomationFramework.getDriver(autoInstance);
    const test = args.test;
    const testTitle = test.title;
    const suiteTitle = args.suiteTitle;
    const testContextOptions = this.config.testContextOptions;
    if (testContextOptions.skipSessionName || !isBrowserstackSession(browser)) {
      this.logger.info("Skipping session name update as per configuration");
      return;
    }
    let name = suiteTitle;
    if (testContextOptions.sessionNameFormat) {
      const caps = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_CAPABILITIES);
      name = testContextOptions.sessionNameFormat(
        this.browserStackConfig,
        caps,
        suiteTitle,
        testTitle
      );
    } else if (test && !test.fullName) {
      const pre = testContextOptions.sessionNamePrependTopLevelSuiteTitle ? `${suiteTitle} - ` : "";
      const post = !testContextOptions.sessionNameOmitTestTitle ? ` - ${testTitle}` : "";
      name = `${pre}${test.parent}${post}`;
    }
    const existingSession = this.sessionMap.get(sessionId);
    if (!existingSession) {
      this.sessionMap.set(sessionId, {
        lastTestName: name,
        testResults: /* @__PURE__ */ new Map()
      });
    } else {
      existingSession.lastTestName = name;
      this.sessionMap.set(sessionId, existingSession);
    }
    TestFramework.setState(instace, TestFrameworkConstants.KEY_AUTOMATE_SESSION_NAME, name);
  }
  async onAfterTest(args) {
    this.logger.debug("onAfterTest: inside automate module after test hook!");
    const instace = args.instance;
    const { error, passed } = args.result;
    const _failReasons = [];
    if (!passed) {
      _failReasons.push(error && error.message || "Unknown Error");
    }
    const status = passed ? "passed" : "failed";
    const reason = _failReasons.length > 0 ? _failReasons.join("\n") : void 0;
    const autoInstance = AutomationFramework.getTrackedInstance();
    const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
    const browser = AutomationFramework.getDriver(autoInstance);
    const test = args.test;
    const testTitle = test.title;
    const suiteTitle = args.suiteTitle;
    const testContextOptions = this.config.testContextOptions;
    if (testContextOptions.skipSessionStatus || !isBrowserstackSession(browser)) {
      this.logger.info("Skipping session status update as per configuration");
      return;
    }
    let name = suiteTitle;
    if (testContextOptions.sessionNameFormat) {
      const caps = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_CAPABILITIES);
      name = testContextOptions.sessionNameFormat(
        this.browserStackConfig,
        caps,
        suiteTitle,
        testTitle
      );
    } else if (test && !test.fullName) {
      const pre = testContextOptions.sessionNamePrependTopLevelSuiteTitle ? `${suiteTitle} - ` : "";
      const post = !testContextOptions.sessionNameOmitTestTitle ? ` - ${testTitle}` : "";
      name = `${pre}${test.parent}${post}`;
    }
    const sessionData = this.sessionMap.get(sessionId);
    if (sessionData) {
      const testResult = {
        testName: name,
        status,
        reason
      };
      sessionData.testResults.set(name, testResult);
      this.sessionMap.set(sessionId, sessionData);
    }
    TestFramework.setState(instace, TestFrameworkConstants.KEY_AUTOMATE_SESSION_STATUS, status);
    TestFramework.setState(instace, TestFrameworkConstants.KEY_AUTOMATE_SESSION_REASON, reason);
  }
  async onAfterExecute() {
    this.logger.debug("onAfterExecute: inside automate module after execute hook!");
    const userName = this.config.userName;
    const accessKey = this.config.accessKey;
    const testContextOptions = this.config.testContextOptions;
    for (const [sessionId, sessionData] of this.sessionMap.entries()) {
      try {
        const failedTests = Array.from(sessionData.testResults.values()).filter((test) => test.status === "failed");
        const hasFailures = failedTests.length > 0;
        const sessionStatus = hasFailures ? "failed" : "passed";
        let failureReason;
        if (hasFailures) {
          if (failedTests.length === 1) {
            failureReason = failedTests[0].reason || "Test failed";
          } else {
            const reasonLines = failedTests.map(
              (test) => `${test.testName}: ${test.reason || "Unknown Error"}`
            );
            failureReason = reasonLines.join(",\n");
          }
        }
        if (!testContextOptions.skipSessionName) {
          await this.markSessionName(sessionId, sessionData.lastTestName, { user: userName, key: accessKey });
        }
        if (!testContextOptions.skipSessionStatus) {
          await this.markSessionStatus(sessionId, sessionStatus, failureReason, { user: userName, key: accessKey });
        }
      } catch (error) {
        this.logger.error(`Failed to process session ${sessionId}: ${error}`);
      }
    }
    this.sessionMap.clear();
  }
  async markSessionName(sessionId, sessionName, config) {
    return await PerformanceTester.measureWrapper(
      AUTOMATE_EVENTS.SESSION_NAME,
      async (sessionId2, sessionName2, config2) => {
        try {
          const auth = Buffer.from(`${config2.user}:${config2.key}`).toString("base64");
          const isAppAutomate = this.config.app;
          if (isAppAutomate) {
            this.logger.info("Marking session name for App Automate");
          } else {
            this.logger.info("Marking session name for Automate");
          }
          const sessionNameApiUrl = isAppAutomate ? `${APIUtils.BROWSERSTACK_AA_API_URL}/app-automate/sessions/${sessionId2}.json` : `${APIUtils.BROWSERSTACK_AUTOMATE_API_URL}/automate/sessions/${sessionId2}.json`;
          const requestBody = {
            name: sessionName2
          };
          const options = {
            method: "PUT",
            headers: {
              Authorization: `Basic ${auth}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody)
          };
          const response = await _fetch(sessionNameApiUrl, options);
          const responseData = await response.json();
          this.logger.debug(`Session name updated: ${util6.format(responseData)}. Done for sessionId ${sessionId2}`);
        } catch (err) {
          this.logger.error(`Failed to update session name on BrowserStack: ${err}`);
        }
      }
    )(sessionId, sessionName, config);
  }
  async markSessionStatus(sessionId, sessionStatus, sessionErrorMessage, config) {
    return await PerformanceTester.measureWrapper(
      AUTOMATE_EVENTS.SESSION_STATUS,
      async (sessionId2, sessionStatus2, sessionErrorMessage2, config2) => {
        try {
          const auth = Buffer.from(`${config2.user}:${config2.key}`).toString("base64");
          const isAppAutomate = this.config.app;
          if (isAppAutomate) {
            this.logger.info("Marking session status for App Automate");
          } else {
            this.logger.info("Marking session status for Automate");
          }
          const sessionStatusApiUrl = isAppAutomate ? `${APIUtils.BROWSERSTACK_AA_API_URL}/app-automate/sessions/${sessionId2}.json` : `${APIUtils.BROWSERSTACK_AUTOMATE_API_URL}/automate/sessions/${sessionId2}.json`;
          const body = {
            status: sessionStatus2,
            ...sessionErrorMessage2 ? { reason: sessionErrorMessage2 } : {}
          };
          const options = {
            method: "PUT",
            headers: {
              Authorization: `Basic ${auth}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(body)
          };
          const response = await _fetch(sessionStatusApiUrl, options);
          const responseData = await response.json();
          this.logger.debug(`Session status updated: ${util6.format(responseData)}. Done for sessionId ${sessionId2}`);
        } catch (err) {
          this.logger.error(`Failed to update session status on BrowserStack: ${err}`);
        }
      }
    )(sessionId, sessionStatus, sessionErrorMessage, config);
  }
};

// src/cli/modules/testHubModule.ts
import util7 from "node:util";

// src/cli/frameworks/wdioMochaTestFramework.ts
import { v4 as uuidv42 } from "uuid";
import path13 from "node:path";

// src/cli/instances/testFrameworkInstance.ts
var now = /* @__PURE__ */ new Date();
var TestFrameworkInstance = class extends TrackedInstance {
  testFrameworks;
  testFrameworksVersions;
  #currentTestState;
  #currentHookState;
  #lastTestState;
  #lastHookState;
  #createdAt;
  /**
  * create TestFrameworkInstance
  * @param {TrackedContext} context
  * @param {Array} testFrameworks
  * @param {Map} testFrameworksVersions
  * @param {TestFrameworkState} testFrameworkState
  * @param {HookState} hookState
  */
  constructor(context, testFrameworks, testFrameworksVersions, testFrameworkState, hookState) {
    super(context);
    this.testFrameworks = testFrameworks;
    this.testFrameworksVersions = testFrameworksVersions;
    this.#currentTestState = testFrameworkState;
    this.#currentHookState = hookState;
    this.#lastTestState = TestFrameworkState.NONE;
    this.#lastHookState = HookState.NONE;
    this.#createdAt = now.toLocaleString();
  }
  /**
  * get CurrentTestState of instance
  * @returns {*} - returns TestFramework State
  */
  getCurrentTestState() {
    return this.#currentTestState;
  }
  /**
  * set CurrentTestState of instance
  * @param {TestFrameworkState} currentTestState - Set Current TestFramework State
  */
  setCurrentTestState(currentTestState) {
    this.setLastTestState(this.#currentTestState);
    this.#currentTestState = currentTestState;
  }
  /**
  * get CurrentHookState of instance
  * @returns {HookState} - return current hook state.
  */
  getCurrentHookState() {
    return this.#currentHookState;
  }
  /**
  * set CurrentHookState of instance
  * @param {HookState} currentHookState - set current hook state.
  */
  setCurrentHookState(currentHookState) {
    this.setLastHookState(this.#currentHookState);
    this.#currentHookState = currentHookState;
  }
  /**
  * get LastTestState of instance
  * @returns {TestFrameworkState} - return last test framework state
  */
  getLastTestState() {
    return this.#lastTestState;
  }
  /**
  * set LastTestState of instance
  * @param {TestFrameworkState} lastTestState - set last test framework state
  */
  setLastTestState(lastTestState) {
    this.#lastTestState = lastTestState;
  }
  /**
  * get LastHookState of instance
  * @returns {HookState} get last hook state
  */
  getLastHookState() {
    return this.#lastHookState;
  }
  /**
  * set LastHookState of instance
  * @param {HookState} lastHookState - returns late hook state
  */
  setLastHookState(lastHookState) {
    this.#lastHookState = lastHookState;
  }
  /**
  * get CreatedAt of instance
  * @returns {string} - return created time
  */
  getCreatedAt() {
    return this.#createdAt;
  }
};

// src/cli/frameworks/wdioMochaTestFramework.ts
var WdioMochaTestFramework = class _WdioMochaTestFramework extends TestFramework {
  static KEY_HOOK_LAST_STARTED = "test_hook_last_started";
  static KEY_HOOK_LAST_FINISHED = "test_hook_last_finished";
  /**
   * Constructor for the TestFramework
   * @param {Array} testFrameworks - List of Test frameworks
   * @param {Map} testFrameworkVersions - Name of the Test frameworks
   * @param {string} binSessionId - BinSessionId
  */
  constructor(testFrameworks, testFrameworkVersions, binSessionId) {
    super(testFrameworks, testFrameworkVersions, binSessionId);
  }
  /**
     * Find instance and track any state for the test framework
     * @param {TestFrameworkState} testFrameworkState
     * @param {HookState} hookState
     * @param {*} args
  */
  async trackEvent(testFrameworkState, hookState, args = {}) {
    BStackLogger2.info(`trackEvent: testFrameworkState=${testFrameworkState} hookState=${hookState}`);
    await super.trackEvent(testFrameworkState, hookState, args);
    const instance = this.resolveInstance(testFrameworkState, hookState, args);
    if (instance === null) {
      BStackLogger2.error(`trackEvent: instance not found for testFrameworkState=${testFrameworkState} hookState=${hookState}`);
      return;
    }
    try {
      if (CLIUtils.matchHookRegex(testFrameworkState.toString()) && hookState === HookState.PRE) {
        instance.updateMultipleEntries({
          [TestFrameworkConstants.KEY_HOOK_ID]: uuidv42()
        });
      }
      if (!TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_ID) && hookState === HookState.PRE && testFrameworkState === TestFrameworkState.TEST) {
        const test = args.test;
        const testData = await this.getTestData(instance, test);
        BStackLogger2.info(`trackEvent: instanceData=${JSON.stringify(Object.fromEntries(instance.getAllData()))}`);
        instance.updateMultipleEntries(testData);
      }
      if (testFrameworkState === TestFrameworkState.TEST) {
        if (hookState === HookState.PRE) {
          instance.updateMultipleEntries({
            [TestFrameworkConstants.KEY_TEST_STARTED_AT]: (/* @__PURE__ */ new Date()).toISOString()
          });
        } else if (hookState === HookState.POST) {
          instance.updateMultipleEntries({
            [TestFrameworkConstants.KEY_TEST_ENDED_AT]: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      } else if (testFrameworkState === TestFrameworkState.LOG) {
        const logEntry = args.logEntry;
        logEntry.uuid = TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOK_ID);
        this.loadLogEntries(instance, testFrameworkState, hookState, logEntry);
      } else if (testFrameworkState === TestFrameworkState.LOG_REPORT && hookState === HookState.POST) {
        BStackLogger2.info("trackEvent: load test results");
        this.loadTestResult(instance, args);
      }
      await this.trackHookEvents(instance, testFrameworkState, hookState, args);
      BStackLogger2.debug(`trackEvent: tracked instance data=${JSON.stringify(Object.fromEntries(instance.getAllData()))}`);
    } catch (error) {
      BStackLogger2.error(`trackEvent: Error in tracking events: ${error} hookState=${hookState} testFrameworkState=${testFrameworkState}`);
    }
    args.instance = instance;
    await this.runHooks(instance, testFrameworkState, hookState, args);
  }
  /**
  * Resolve instance for the test framework
  * @param {TestFrameworkState} testFrameworkState
  * @param {HookState} hookState
  * @param {*} args
  * @returns {TestFrameworkInstance}
  */
  resolveInstance(testFrameworkState, hookState, args = {}) {
    let instance = null;
    BStackLogger2.info(`resolveInstance: resolving instance for testFrameworkState=${testFrameworkState} hookState=${hookState}`);
    if (testFrameworkState === TestFrameworkState.INIT_TEST || testFrameworkState === TestFrameworkState.NONE) {
      this.trackWdioMochaInstance(testFrameworkState, args);
    }
    instance = TestFramework.getTrackedInstance();
    this.updateInstanceState(instance, testFrameworkState, hookState);
    return instance;
  }
  /**
  * Track WebdriverIO instance
  * @param {TestFrameworkState} testFrameworkState
  * @param {*} args
  */
  trackWdioMochaInstance(testFrameworkState, args) {
    const target = CLIUtils.getCurrentInstanceName();
    const trackedContext = TrackedInstance.createContext(target);
    let instance = null;
    BStackLogger2.info(`trackWdioMochaInstance: created instance for target=${target}, state=${testFrameworkState}, args=${args}`);
    instance = new TestFrameworkInstance(
      trackedContext,
      this.getTestFrameworks(),
      this.getTestFrameworksVersions(),
      testFrameworkState,
      HookState.NONE
    );
    const frameworkName = this.getTestFrameworks()[0];
    const instanceEntries = {
      [TestFrameworkConstants.KEY_TEST_FRAMEWORK_NAME]: frameworkName,
      [TestFrameworkConstants.KEY_TEST_FRAMEWORK_VERSION]: this.getTestFrameworksVersions()[frameworkName],
      [TestFrameworkConstants.KEY_TEST_LOGS]: [],
      [TestFrameworkConstants.KEY_HOOKS_FINISHED]: /* @__PURE__ */ new Map(),
      [TestFrameworkConstants.KEY_HOOKS_STARTED]: /* @__PURE__ */ new Map(),
      [TestFrameworkConstants.KEY_TEST_UUID]: uuidv42(),
      [TestFrameworkConstants.KEY_TEST_RESULT]: TestFrameworkConstants.DEFAULT_TEST_RESULT
      // TODO[CLI]: Add customRerunParam
      // [TestFrameworkConstants.KEY_TEST_RERUN_NAME]:
    };
    process.env[TEST_ANALYTICS_ID] = instanceEntries[TestFrameworkConstants.KEY_TEST_UUID];
    instance.updateMultipleEntries(instanceEntries);
    TestFramework.setTrackedInstance(trackedContext, instance);
    BStackLogger2.info(`trackWdioMochaInstance: saved instance contextId=${trackedContext.getId()} target=${target}`);
  }
  async getTestData(instance, test) {
    const framework = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_FRAMEWORK_NAME);
    const fullTitle = getUniqueIdentifier(test, framework);
    const gitConfig = await getGitMetaData();
    const filename = test.file;
    const testData = {
      [TestFrameworkConstants.KEY_TEST_ID]: getUniqueIdentifier(test, framework),
      [TestFrameworkConstants.KEY_TEST_NAME]: test.title || test.description,
      [TestFrameworkConstants.KEY_TEST_CODE]: test.body || "",
      [TestFrameworkConstants.KEY_TEST_FILE_PATH]: gitConfig?.root && filename ? path13.relative(gitConfig.root, filename) : void 0,
      [TestFrameworkConstants.KEY_TEST_LOCATION]: filename ? path13.relative(process.cwd(), filename) : void 0,
      [TestFrameworkConstants.KEY_TEST_SCOPE]: fullTitle,
      [TestFrameworkConstants.KEY_TEST_SCOPES]: getMochaTestHierarchy(test)
    };
    return testData;
  }
  loadTestResult(instance, args) {
    const results = args.result;
    const { error, passed } = results;
    let result = "passed";
    let failure = null;
    let failureReason = null;
    let failureType = null;
    if (!passed) {
      result = error && error.message && error.message.includes("sync skip; aborting execution") ? "ignore" : "failed";
      if (error && result !== "skipped") {
        failure = [{ backtrace: [removeAnsiColors(error.message), removeAnsiColors(error.stack || "")] }];
        failureReason = removeAnsiColors(error.message);
        failureType = isUndefined(error.message) ? null : error.message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError";
      }
    }
    instance.updateMultipleEntries({
      [TestFrameworkConstants.KEY_TEST_RESULT]: result,
      [TestFrameworkConstants.KEY_TEST_FAILURE]: failure,
      [TestFrameworkConstants.KEY_TEST_FAILURE_REASON]: failureReason,
      [TestFrameworkConstants.KEY_TEST_FAILURE_TYPE]: failureType
    });
  }
  /**
   * Load log entries into the test framework instance.
   * @param instance TestFrameworkInstance
   * @param testFrameworkState TestFrameworkState
   * @param hookState HookState
   * @param args Additional arguments (level, message, etc.)
   */
  loadLogEntries(instance, testFrameworkState, hookState, logEntry) {
    const logRecord = {};
    const { level, message, timestamp } = logEntry;
    if (CLIUtils.matchHookRegex(instance.getCurrentTestState().toString())) {
      logRecord[TestFrameworkConstants.KEY_HOOK_ID] = TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOK_ID);
    }
    logRecord.kind = TestFrameworkConstants.KIND_LOG;
    logRecord.message = Buffer.from(message);
    logRecord.level = level;
    logRecord.timestamp = timestamp;
    const lastActiveHook = _WdioMochaTestFramework.lastActiveHook(instance, _WdioMochaTestFramework.KEY_HOOK_LAST_STARTED);
    if (lastActiveHook) {
      const hookLogs = lastActiveHook[TestFrameworkConstants.KEY_HOOK_LOGS];
      hookLogs.push(logRecord);
      BStackLogger2.debug(`hooks after update logs ${TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOKS_STARTED)} ${TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOKS_FINISHED)}`);
      return;
    }
    const entries = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_LOGS);
    entries.push(logRecord);
    instance.updateMultipleEntries({
      [TestFrameworkConstants.KEY_TEST_LOGS]: entries
    });
  }
  /**
   * Get the last active hook for the given instance and hook key.
   * @param instance TestFrameworkInstance
   * @param lastHookKey string
   * @returns Record<string, unknown> | null
   */
  static lastActiveHook(instance, lastHookKey) {
    const hookStore = lastHookKey === _WdioMochaTestFramework.KEY_HOOK_LAST_FINISHED ? TestFrameworkConstants.KEY_HOOKS_FINISHED : TestFrameworkConstants.KEY_HOOKS_STARTED;
    const lastActive = TestFramework.getState(instance, lastHookKey);
    let hooksMap = null;
    if (lastActive) {
      hooksMap = TestFramework.getState(instance, hookStore);
    }
    if (hooksMap && lastActive && hooksMap[lastActive]) {
      const lastHooks = hooksMap[lastActive];
      if (lastHooks.length > 0) {
        return lastHooks[lastHooks.length - 1];
      }
    }
    return null;
  }
  /**
   * Clear logs for a specific hook.
   * @param instance TestFrameworkInstance
   * @param lastHookKey string
   */
  static clearHookLogs(instance, lastHookKey) {
    const hook = this.lastActiveHook(instance, lastHookKey);
    if (hook) {
      hook[TestFrameworkConstants.KEY_HOOK_LOGS] = [];
    }
  }
  /**
   * Clear all logs for the given instance, test framework state, and hook state.
   * @param instance TestFrameworkInstance
   * @param testFrameworkState TestFrameworkState
   * @param hookState HookState
   */
  static clearLogs(instance, testFrameworkState, hookState) {
    const lastHookKey = hookState === HookState.PRE ? _WdioMochaTestFramework.KEY_HOOK_LAST_STARTED : _WdioMochaTestFramework.KEY_HOOK_LAST_FINISHED;
    _WdioMochaTestFramework.clearHookLogs(instance, lastHookKey);
    instance.updateMultipleEntries({
      [TestFrameworkConstants.KEY_TEST_LOGS]: []
    });
  }
  /**
   * Get all log entries for the given instance, test framework state, and hook state.
   * @param instance TestFrameworkInstance
   * @param testFrameworkState TestFrameworkState
   * @param hookState HookState
   * @returns unknown[]
   */
  static getLogEntries(instance, testFrameworkState, hookState) {
    const lastHookKey = hookState === HookState.PRE ? _WdioMochaTestFramework.KEY_HOOK_LAST_STARTED : _WdioMochaTestFramework.KEY_HOOK_LAST_FINISHED;
    const hook = _WdioMochaTestFramework.lastActiveHook(instance, lastHookKey);
    const entries = hook ? hook[TestFrameworkConstants.KEY_HOOK_LOGS] : [];
    const testEntries = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_LOGS);
    return [...entries, ...testEntries];
  }
  /**
   * Track hook events for the test framework.
   * @param instance TestFrameworkInstance
   * @param testFrameworkState TestFrameworkState
   * @param hookState HookState
   * @param args Additional arguments (e.g., test result, test method)
   */
  async trackHookEvents(instance, testFrameworkState, hookState, args) {
    const testResult = args.result;
    const test = args.test;
    const key = testFrameworkState.toString();
    const hooksStarted = TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOKS_STARTED);
    if (!hooksStarted.has(key)) {
      hooksStarted.set(key, []);
    }
    const hooksFinished = TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOKS_FINISHED);
    if (!hooksFinished.has(key)) {
      hooksFinished.set(key, []);
    }
    const updates = {
      [TestFrameworkConstants.KEY_HOOKS_STARTED]: hooksStarted,
      [TestFrameworkConstants.KEY_HOOKS_FINISHED]: hooksFinished
    };
    if (hookState === HookState.PRE) {
      const gitConfig = await getGitMetaData();
      const filename = test.file;
      const hook = {
        key,
        [TestFrameworkConstants.KEY_HOOK_ID]: TestFramework.getState(instance, TestFrameworkConstants.KEY_HOOK_ID) || "",
        [TestFrameworkConstants.KEY_HOOK_RESULT]: TestFrameworkConstants.DEFAULT_HOOK_RESULT,
        [TestFrameworkConstants.KEY_EVENT_STARTED_AT]: (/* @__PURE__ */ new Date()).toISOString(),
        [TestFrameworkConstants.KEY_HOOK_LOGS]: [],
        [TestFrameworkConstants.KEY_HOOK_NAME]: test.title || test.description,
        [TestFrameworkConstants.KEY_TEST_FILE_PATH]: gitConfig?.root && filename ? path13.relative(gitConfig.root, filename) : void 0,
        [TestFrameworkConstants.KEY_TEST_LOCATION]: filename ? path13.relative(process.cwd(), filename) : void 0
      };
      hooksStarted.get(key)?.push(hook);
      updates[_WdioMochaTestFramework.KEY_HOOK_LAST_STARTED] = key;
      BStackLogger2.info(`Hook Started in PRE key = ${key} & hook = ${JSON.stringify(hook)}`);
    } else if (hookState === HookState.POST) {
      const hooksList = hooksStarted.get(key) || [];
      BStackLogger2.info(`Hook List in Post ${JSON.stringify(hooksList)}`);
      if (hooksList.length > 0) {
        const hook = hooksList.pop();
        const result = testResult.status;
        if (result !== TestFrameworkConstants.DEFAULT_HOOK_RESULT) {
          hook[TestFrameworkConstants.KEY_HOOK_RESULT] = result;
        }
        hook[TestFrameworkConstants.KEY_EVENT_ENDED_AT] = (/* @__PURE__ */ new Date()).toISOString();
        hooksFinished.get(key)?.push(hook);
        updates[_WdioMochaTestFramework.KEY_HOOK_LAST_FINISHED] = key;
      }
    }
    instance.updateMultipleEntries(updates);
    BStackLogger2.info(`trackHookEvents: hook state=${key}.${hookState}, hooks started=${JSON.stringify(hooksStarted)}, hooks finished=${JSON.stringify(hooksFinished)}`);
  }
};

// src/cli/modules/testHubModule.ts
var TestHubModule = class _TestHubModule extends BaseModule {
  logger = BStackLogger2;
  testhubConfig;
  name;
  static MODULE_NAME = "TestHubModule";
  /**
   * Create a new TestHubModule
   */
  constructor(testhubConfig) {
    super();
    this.name = "TestHubModule";
    this.testhubConfig = testhubConfig;
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.PRE, this.onBeforeTest.bind(this));
    Object.values(TestFrameworkState).forEach((state) => {
      Object.values(HookState).forEach((hook) => {
        TestFramework.registerObserver(state, hook, this.onAllTestEvents.bind(this));
      });
    });
  }
  /**
   * Get the module name
   * @returns {string} The module name
   */
  getModuleName() {
    return _TestHubModule.MODULE_NAME;
  }
  onBeforeTest(args) {
    this.logger.debug("onBeforeTest: Called after test hook from cli configured module!!!");
    const autoInstance = AutomationFramework.getTrackedInstance();
    const instances = [autoInstance];
    args.autoInstance = instances;
    this.sendTestSessionEvent(args);
  }
  onAllTestEvents(args) {
    this.logger.debug("onAllTestEvents: Called after all test events from cli configured module!!!");
    const instance = args.instance;
    const testState = instance.getCurrentTestState();
    const hookState = instance.getCurrentHookState();
    const keyTestDeferred = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_DEFERRED);
    if (testState === TestFrameworkState.LOG) {
      this.logger.debug(`onAllTestEvents: TestFrameworkState.LOG - ${testState}`);
      const logEntries = WdioMochaTestFramework.getLogEntries(instance, testState, hookState);
      if (logEntries && logEntries.length > 0) {
        args.logEntries = logEntries;
        this.sendLogCreatedEvent(args);
        WdioMochaTestFramework.clearLogs(instance, testState, hookState);
      }
    } else if (testState === TestFrameworkState.TEST && hookState === HookState.POST && !TestFramework.hasState(instance, TestFrameworkConstants.KEY_TEST_RESULT_AT)) {
      this.logger.info("onAllTestEvents: dropping due to lack of results");
      TestFramework.setState(instance, TestFrameworkConstants.KEY_TEST_DEFERRED, true);
    } else if (keyTestDeferred && testState === TestFrameworkState.LOG_REPORT && hookState === HookState.POST && TestFramework.hasState(instance, TestFrameworkConstants.KEY_TEST_RESULT_AT)) {
      instance.setCurrentTestState(TestFrameworkState.TEST);
      this.onAllTestEvents(args);
    }
    if (testState === TestFrameworkState.TEST || CLIUtils.matchHookRegex(testState.toString().split(".")[1])) {
      this.sendTestFrameworkEvent(args);
    }
  }
  async sendTestFrameworkEvent(args) {
    try {
      const testArgs = args;
      const instance = testArgs.instance;
      const trackedContext = instance.getContext();
      const testData = instance.getAllData();
      const testFrameworkName = testData.get(TestFrameworkConstants.KEY_TEST_FRAMEWORK_NAME) || "";
      const testFrameworkVersion = testData.get(TestFrameworkConstants.KEY_TEST_FRAMEWORK_VERSION) || "";
      const startedAt = testData.get(TestFrameworkConstants.KEY_TEST_STARTED_AT) || "";
      const endedAt = testData.get(TestFrameworkConstants.KEY_TEST_ENDED_AT) || "";
      const testFrameworkState = instance.getCurrentTestState().toString().split(".")[1];
      const testHookState = instance.getCurrentHookState().toString().split(".")[1];
      this.logger.debug(`sendTestFrameworkEvent for testState: ${testFrameworkState} hookState: ${testHookState}`);
      const platformIndex = process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0;
      const uuid = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_UUID) || instance.getRef();
      const eventJson = Buffer.from(JSON.stringify(Object.fromEntries(testData)));
      const executionContext = { hash: trackedContext.getId(), threadId: trackedContext.getThreadId().toString(), processId: trackedContext.getProcessId().toString() };
      const payload = {
        platformIndex,
        testFrameworkName,
        testFrameworkVersion,
        testFrameworkState,
        testHookState,
        startedAt,
        endedAt,
        uuid,
        eventJson,
        executionContext
      };
      this.logger.debug(`sendTestFrameworkEvent payload: ${JSON.stringify(payload)}`);
      await GrpcClient.getInstance().testFrameworkEvent(payload);
      this.logger.debug(`sendTestFrameworkEvent complete for testState: ${testFrameworkState} hookState: ${testHookState}`);
    } catch (error) {
      this.logger.error(`Error in sendTestFrameworkEvent: ${util7.format(error)}`);
    }
  }
  /**
   * Send test session event to the service
   * @param args containing test session data
   */
  async sendTestSessionEvent(args) {
    this.logger.debug("sendTestSessionEvent: Called");
    try {
      const instance = args.instance;
      const autoInstances = args.autoInstance || [];
      const trackedContext = instance.getContext();
      const testFWName = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_FRAMEWORK_NAME);
      const testFWVersion = TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_FRAMEWORK_VERSION);
      const testState = instance.getCurrentTestState().toString().split(".")[1];
      const hookState = instance.getCurrentHookState().toString().split(".")[1];
      this.logger.debug("sendTestSessionEvent: setup");
      const executionContext = {
        threadId: trackedContext.getThreadId().toString(),
        processId: trackedContext.getProcessId().toString()
      };
      const payload = {
        testFrameworkName: testFWName,
        testFrameworkVersion: testFWVersion,
        testFrameworkState: testState.toString(),
        testHookState: hookState.toString(),
        testUuid: TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_UUID).toString(),
        executionContext,
        automationSessions: [],
        platformIndex: process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0,
        capabilities: new Uint8Array()
      };
      try {
        if (autoInstances.length > 0) {
          const driver = AutomationFramework.getDriver(autoInstances[0]);
          const userCaps = JSON.stringify(driver.capabilities);
          if (userCaps) {
            payload.capabilities = new TextEncoder().encode(userCaps);
          }
        }
      } catch (error) {
        this.logger.debug(`Error while getting capabilities from driver: ${error}`);
      }
      this.logger.debug(`sendTestSessionEvent: instance iteration ${JSON.stringify(autoInstances)}`);
      for (const autoInstance of autoInstances) {
        const sessionProvider = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_IS_BROWSERSTACK_HUB) ? "browserstack" : "unknown_grid";
        const automationSession = {
          provider: sessionProvider,
          ref: autoInstance.getRef(),
          hubUrl: this.config.hubUrl,
          frameworkSessionId: AutomationFramework.getState(
            autoInstance,
            AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID
          ).toString(),
          frameworkName: autoInstance.frameworkName,
          frameworkVersion: autoInstance.frameworkVersion
        };
        this.logger.debug(`sendTestSessionEvent: automationSession: ${JSON.stringify(automationSession)}`);
        payload.platformIndex = process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0;
        payload.automationSessions.push(automationSession);
      }
      this.logger.debug(`sendTestSessionEvent payload: ${JSON.stringify(payload)}`);
      await GrpcClient.getInstance().testSessionEvent(payload);
      this.logger.debug(`sendTestSessionEvent complete for testState: ${testState} hookState: ${hookState}`);
    } catch (error) {
      this.logger.error(`sendTestSessionEvent: Error sending grpc call: event=${JSON.stringify(args)}, error=${error}`);
      throw new Error(`Failed to send test session event: ${error}`);
    }
  }
  async sendLogCreatedEvent(args) {
    try {
      const testArgs = args;
      const logEntries = args.logEntries;
      const instance = testArgs.instance;
      const trackedContext = instance.getContext();
      const testData = instance.getAllData();
      const testFrameworkName = testData.get(TestFrameworkConstants.KEY_TEST_FRAMEWORK_NAME) || "";
      const testFrameworkVersion = testData.get(TestFrameworkConstants.KEY_TEST_FRAMEWORK_VERSION) || "";
      const testFrameworkState = instance.getCurrentTestState().toString().split(".")[1];
      const testHookState = instance.getCurrentHookState().toString().split(".")[1];
      this.logger.debug(`sendLogCreatedEvent testId: testFrameworkState: ${testFrameworkState} testHookState: ${testHookState}`);
      const platformIndex = process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0;
      const executionContext = { hash: trackedContext.getId(), threadId: trackedContext.getThreadId().toString(), processId: trackedContext.getProcessId().toString() };
      const payload = {
        platformIndex,
        logs: [],
        executionContext
      };
      for (const logEntry of logEntries) {
        const logData = {
          testFrameworkName,
          testFrameworkVersion,
          testFrameworkState,
          uuid: logEntry[TestFrameworkConstants.KEY_HOOK_ID] || TestFramework.getState(instance, TestFrameworkConstants.KEY_TEST_UUID),
          kind: logEntry.kind,
          message: logEntry.message,
          timestamp: logEntry.timestamp,
          level: logEntry.level
        };
        payload.logs.push(logData);
      }
      this.logger.debug(`sendLogCreatedEvent payload: ${JSON.stringify(payload)}`);
      await GrpcClient.getInstance().logCreatedEvent(payload);
      this.logger.debug(`sendLogCreatedEvent complete for testState: ${testFrameworkState} hookState: ${testHookState}`);
    } catch (error) {
      this.logger.error(`Error in sendLogCreatedEvent: ${util7.format(error)}`);
    }
  }
};

// src/cli/instances/automationFrameworkInstance.ts
var AutomationFrameworkInstance = class extends TrackedInstance {
  frameworkName;
  frameworkVersion;
  state;
  constructor(context, frameworkName, frameworkVersion, state) {
    super(context);
    this.frameworkName = frameworkName;
    this.frameworkVersion = frameworkVersion;
    this.state = state;
  }
  /**
  * Get the framework name
  * @returns {string} The name of the automation framework
  */
  getFrameworkName() {
    return this.frameworkName;
  }
  /**
  * Get the framework version
  * @returns {string} The version of the automation framework
  */
  getFrameworkVersion() {
    return this.frameworkVersion;
  }
  /**
  * Get the current state
  * @returns {AutomationFrameworkState} The current state of the automation framework
  */
  getState() {
    return this.state;
  }
  /**
  * Set the current state
  * @param {AutomationFrameworkState} state - The new state to set
  */
  setState(state) {
    this.state = state;
  }
};

// src/cli/frameworks/wdioAutomationFramework.ts
var WdioAutomationFramework = class extends AutomationFramework {
  constructor(automationFrameworkName, automationFrameworkVersion) {
    super(automationFrameworkName, automationFrameworkVersion);
  }
  /**
   * Find instance and track any state for the automation framework
   * @param {*} automationFrameworkState
   * @param {*} hookState
   * @param {*} args
   */
  async trackEvent(automationFrameworkState, hookState, args = {}) {
    BStackLogger2.info(`trackEvent: automationFrameworkState=${automationFrameworkState} hookState=${hookState}`);
    await super.trackEvent(automationFrameworkState, hookState, args);
    const instance = this.resolveInstance(automationFrameworkState, hookState, args);
    if (instance === null) {
      BStackLogger2.error(`trackEvent: instance not found for automationFrameworkState=${automationFrameworkState} hookState=${hookState}`);
      return;
    }
    args.instance = instance;
    await this.runHooks(instance, automationFrameworkState, hookState, args);
  }
  /**
   * Resolve instance for the automation framework
   * @param {*} automationFrameworkState
   * @param {*} hookState
   * @param {*} args
   * @returns instance
   */
  resolveInstance(automationFrameworkState, hookState, args = {}) {
    let instance = null;
    BStackLogger2.info(`resolveInstance: resolving instance for automationFrameworkState=${automationFrameworkState} hookState=${hookState}`);
    if (automationFrameworkState === AutomationFrameworkState.CREATE || automationFrameworkState === AutomationFrameworkState.NONE) {
      this.trackWebdriverIOInstance(automationFrameworkState, args);
    }
    instance = AutomationFramework.getTrackedInstance();
    return instance;
  }
  /**
   * Create instance for WebdriverIO
   * @returns {void}
   */
  trackWebdriverIOInstance(automationFrameworkState, args = {}) {
    if (
      // !args.browser &&
      AutomationFramework.getTrackedInstance()
    ) {
      BStackLogger2.info("trackWebdriverIOInstance: instance already exists");
      return;
    }
    const target = CLIUtils.getCurrentInstanceName();
    const trackedContext = TrackedInstance.createContext(target);
    let instance = null;
    BStackLogger2.info(`trackWebdriverIOInstance: created instance for target=${target}, state=${automationFrameworkState}, args=${args}`);
    instance = new AutomationFrameworkInstance(
      trackedContext,
      this.getAutomationFrameworkName(),
      this.getAutomationFrameworkVersion(),
      automationFrameworkState
    );
    AutomationFramework.setTrackedInstance(trackedContext, instance);
    BStackLogger2.info(`trackWebdriverIOInstance: saved instance contextId=${trackedContext.getId()} target=${target}`);
  }
};

// src/cli/modules/webdriverIOModule.ts
import util8 from "node:util";
var WebdriverIOModule = class _WebdriverIOModule extends BaseModule {
  name;
  browserName;
  browserVersion;
  platforms;
  testRunId;
  logger = BStackLogger2;
  static MODULE_NAME = "WebdriverIOModule";
  /**
     * Create a new WebdriverIOModule
     */
  constructor() {
    super();
    this.name = "WebdriverIOModule";
    this.browserName = null;
    this.browserVersion = null;
    this.platforms = [];
    this.testRunId = null;
    AutomationFramework.registerObserver(AutomationFrameworkState.CREATE, HookState.PRE, this.onBeforeDriverCreate.bind(this));
    AutomationFramework.registerObserver(AutomationFrameworkState.CREATE, HookState.POST, this.onDriverCreated.bind(this));
  }
  /**
     * Get the module name
     * @returns {string} The module name
     */
  getModuleName() {
    return _WebdriverIOModule.MODULE_NAME;
  }
  async onBeforeDriverCreate(args) {
    try {
      const instance = args.instance;
      this.logger.debug("onBeforeDriverCreate: driver is about to be created");
      const capabilities = args.caps;
      if (!capabilities) {
        this.logger.warn("onBeforeDriverCreate: No capabilities provided");
        return;
      }
      AutomationFramework.setState(instance, AutomationFrameworkConstants.KEY_INPUT_CAPABILITIES, capabilities);
      await this.getBinDriverCapabilities(instance, capabilities);
    } catch (e) {
      this.logger.error(`Error in onBeforeDriverCreate: ${util8.format(e)}`);
    }
  }
  /**
   * Handle driver creation event
   * @param args Event arguments containing driver and instance information
   */
  async onDriverCreated(args) {
    this.logger.debug("onDriverCreated: Called");
    try {
      const instance = args.instance;
      const browser = args.browser;
      if (!instance || !browser) {
        this.logger.warn("onDriverCreated: Missing instance or driver");
        return;
      }
      AutomationFramework.setState(instance, AutomationFrameworkConstants.KEY_HUB_URL, args.hubUrl);
      let sessionId = null;
      try {
        sessionId = browser.sessionId;
        if (sessionId) {
          this.logger.debug(`onDriverCreated: Driver session ID: ${sessionId}`);
          AutomationFramework.setState(instance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID, sessionId);
        }
      } catch (error) {
        this.logger.debug(`onDriverCreated: Could not get session ID: ${error}`);
      }
      try {
        const capabilities = browser.capabilities;
        if (capabilities) {
          this.logger.debug(`onDriverCreated: Driver capabilities: ${JSON.stringify(capabilities)}`);
          AutomationFramework.setState(instance, AutomationFrameworkConstants.KEY_CAPABILITIES, capabilities);
        }
      } catch (error) {
        this.logger.debug(`onDriverCreated: Could not get capabilities: ${error}`);
      }
      try {
        const isBrowserStackHub = isBrowserstackSession(browser);
        AutomationFramework.setState(instance, AutomationFrameworkConstants.KEY_IS_BROWSERSTACK_HUB, isBrowserStackHub);
        this.logger.debug(`onDriverCreated: Is BrowserStack hub: ${isBrowserStackHub}`);
      } catch (error) {
        this.logger.debug(`onDriverCreated: Could not determine hub type: ${error}`);
      }
      AutomationFramework.setDriver(instance, browser);
      this.logger.info(`onDriverCreated: Successfully processed driver creation for session: ${sessionId}`);
    } catch (error) {
      this.logger.error(`onDriverCreated: Error processing driver creation: ${error}`);
    }
  }
  async getBinDriverCapabilities(instance, caps) {
    try {
      const payload = {
        platformIndex: process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0,
        ref: instance.getRef(),
        userInputParams: Buffer.from(JSON.stringify(caps).toString())
      };
      const response = await GrpcClient.getInstance().driverInitEvent(payload);
      if (response.success) {
        if (response.capabilities.length > 0) {
          const capabilitiesStr = response.capabilities.toString("utf8");
          const capabilitiesObj = JSON.parse(capabilitiesStr);
          AutomationFramework.setState(instance, AutomationFrameworkConstants.KEY_CAPABILITIES, capabilitiesObj);
        }
        this.logger.debug(`getBinDriverCapabilities: got hub url ${response.hubUrl}`);
      }
    } catch (error) {
      this.logger.error(`getBinDriverCapabilities: Error getting capabilities: ${error}`);
    }
  }
};

// src/cli/modules/accessibilityModule.ts
import util9 from "node:util";
var AccessibilityModule = class extends BaseModule {
  logger = BStackLogger2;
  name;
  scriptInstance;
  accessibility = false;
  autoScanning = true;
  isAppAccessibility;
  isNonBstackA11y;
  accessibilityConfig;
  static MODULE_NAME = "AccessibilityModule";
  accessibilityMap;
  LOG_DISABLED_SHOWN;
  testMetadata = {};
  constructor(accessibilityConfig, isNonBstackA11y) {
    super();
    this.name = "AccessibilityModule";
    this.accessibilityConfig = accessibilityConfig;
    AutomationFramework.registerObserver(AutomationFrameworkState.CREATE, HookState.POST, this.onBeforeExecute.bind(this));
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.PRE, this.onBeforeTest.bind(this));
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.POST, this.onAfterTest.bind(this));
    this.accessibility = Boolean(accessibilityConfig);
    const accessibilityOptions = BrowserstackCLI.getInstance().options?.accessibilityOptions;
    this.autoScanning = Boolean(accessibilityOptions?.autoScanning ?? true);
    this.scriptInstance = accessibility_scripts_default;
    this.accessibilityMap = /* @__PURE__ */ new Map();
    this.LOG_DISABLED_SHOWN = /* @__PURE__ */ new Map();
    this.isAppAccessibility = accessibilityConfig.isAppAccessibility || false;
    this.isNonBstackA11y = isNonBstackA11y;
  }
  async onBeforeExecute() {
    try {
      const autoInstance = AutomationFramework.getTrackedInstance();
      if (!autoInstance) {
        this.logger.debug("No tracked instances found!");
        return;
      }
      const browser = AutomationFramework.getDriver(autoInstance);
      if (!browser) {
        this.logger.debug("No browser instance found for command wrapping");
        return;
      }
      const isBrowserstackSession2 = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_IS_BROWSERSTACK_HUB);
      const browserCaps = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_CAPABILITIES);
      const inputCaps = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_INPUT_CAPABILITIES);
      const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
      const platformA11yMeta = {
        browser_name: browserCaps.browserName,
        browser_version: browserCaps?.browserVersion || "latest",
        platform_name: browserCaps?.platformName,
        platform_version: this.getCapability(browserCaps, "appium:platformVersion", "platformVersion")
      };
      if (this.isAppAccessibility) {
        this.accessibility = validateCapsWithAppA11y(platformA11yMeta);
      } else {
        const device = this.getCapability(inputCaps, "deviceName");
        const chromeOptions = this.getCapability(inputCaps, "goog:chromeOptions");
        this.accessibility = validateCapsWithA11y(device, platformA11yMeta, chromeOptions);
      }
      browser.getAccessibilityResultsSummary = async () => {
        if (this.isAppAccessibility) {
          return await getAppA11yResultsSummary(true, browser, isBrowserstackSession2, this.accessibility, sessionId);
        }
        return await this.getA11yResultsSummary(browser);
      };
      browser.getAccessibilityResults = async () => {
        if (this.isAppAccessibility) {
          return await getAppA11yResults(true, browser, isBrowserstackSession2, this.accessibility, sessionId);
        }
        return await this.getA11yResults(browser);
      };
      browser.performScan = async () => {
        if (!this.accessibility && !this.isAppAccessibility) {
          return;
        }
        return await this.performScanCli(browser);
      };
      browser.startA11yScanning = async () => {
        if (!this.accessibility && !this.isAppAccessibility) {
          return;
        }
        this.logger.warn("Accessibility scanning cannot be started from outside the test");
      };
      browser.stopA11yScanning = async () => {
        if (!this.accessibility && !this.isAppAccessibility) {
          return;
        }
        this.logger.warn("Accessibility scanning cannot be stopped from outside the test");
      };
      if (!this.accessibility) {
        this.logger.info("Accessibility automation is disabled for this session.");
        return;
      }
      if (!("overwriteCommand" in browser && Array.isArray(this.scriptInstance.commandsToWrap))) {
        return;
      }
      if (this.scriptInstance.commandsToWrap && this.scriptInstance.commandsToWrap.length > 0) {
        this.scriptInstance.commandsToWrap.filter((command) => command.name && command.class).forEach((command) => {
          browser.overwriteCommand(
            // @ts-expect-error fix type
            command.name,
            this.commandWrapper.bind(this, command),
            command.class === "Element"
          );
        });
      }
    } catch (error) {
      this.logger.error(`Error in onBeforeExecute: ${error}`);
    }
  }
  async commandWrapper(command, originFunction, ...args) {
    try {
      const autoInstance = AutomationFramework.getTrackedInstance();
      const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
      if (sessionId && this.accessibilityMap.get(sessionId)) {
        const browser = AutomationFramework.getDriver(autoInstance);
        if (!command.name.includes("execute") || !this.shouldPatchExecuteScript(args.length ? args[0] : null)) {
          try {
            await this.performScanCli(browser, command.name);
            this.logger.debug(`Accessibility scan performed after ${command.name} command`);
          } catch (scanError) {
            this.logger.debug(`Error performing accessibility scan after ${command.name}: ${scanError}`);
          }
        }
      }
      const result = await originFunction(...args);
      return result;
    } catch (error) {
      this.logger.error(`Error in commandWrapper for ${command.name}: ${error}`);
      return await originFunction(...args);
    }
  }
  async onBeforeTest(args) {
    try {
      this.logger.debug("Accessibility before test hook. Starting accessibility scan for this test case.");
      const suiteTitle = (typeof args.suiteTitle === "string" ? args.suiteTitle : "") || "";
      const test = (args.test && typeof args.test === "object" ? args.test : {}) || {};
      const autoInstance = AutomationFramework.getTrackedInstance();
      const testInstance = TestFramework.getTrackedInstance();
      const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
      const accessibilityOptions = this.config.accessibilityOptions;
      const shouldScanTest = this.autoScanning && shouldScanTestForAccessibility(suiteTitle, test.title || "", accessibilityOptions) && this.accessibility;
      this.accessibilityMap.set(sessionId, shouldScanTest);
      const testIdentifier = String(testInstance.getContext().getId());
      this.testMetadata[testIdentifier] = {
        scanTestForAccessibility: shouldScanTest,
        accessibilityScanStarted: shouldScanTest
      };
      const browser = AutomationFramework.getDriver(autoInstance);
      browser.startA11yScanning = async () => {
        if (!this.accessibility && !this.isAppAccessibility) {
          return;
        }
        this.accessibilityMap.set(sessionId, true);
        this.testMetadata[testIdentifier] = {
          scanTestForAccessibility: true,
          accessibilityScanStarted: true
        };
        TestFramework.setState(testInstance, `accessibility_metadata_${testIdentifier}`, this.testMetadata[testIdentifier]);
        await this._setAnnotation("Accessibility scanning has started");
      };
      browser.stopA11yScanning = async () => {
        if (!this.accessibility && !this.isAppAccessibility) {
          return;
        }
        this.accessibilityMap.set(sessionId, false);
        await this._setAnnotation("Accessibility scanning has stopped");
      };
      browser.performScan = async () => {
        if (!this.accessibility && !this.isAppAccessibility) {
          return;
        }
        const results = await this.performScanCli(browser);
        if (results) {
          const testIdentifier2 = String(testInstance.getContext().getId());
          this.testMetadata[testIdentifier2] = {
            scanTestForAccessibility: true,
            accessibilityScanStarted: true
          };
          TestFramework.setState(testInstance, `accessibility_metadata_${testIdentifier2}`, this.testMetadata[testIdentifier2]);
          await this._setAnnotation("Accessibility scanning was triggered manually");
        }
        return results;
      };
      TestFramework.setState(testInstance, `accessibility_metadata_${testIdentifier}`, this.testMetadata[testIdentifier]);
      if (shouldScanTest) {
        this.logger.info("Accessibility test case execution has started.");
      } else if (!this.LOG_DISABLED_SHOWN.get(sessionId)) {
        this.logger.info("Accessibility scanning disabled for this test case.");
        this.LOG_DISABLED_SHOWN.set(sessionId, true);
      }
    } catch (error) {
      this.logger.error(`Exception in starting accessibility automation scan for this test case: ${error}`);
    }
  }
  async onAfterTest() {
    this.logger.debug("Accessibility after test hook. Before sending test stop event");
    try {
      const autoInstance = AutomationFramework.getTrackedInstance();
      const testInstance = TestFramework.getTrackedInstance();
      const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
      if (!autoInstance || !testInstance) {
        this.logger.error("No tracked instances found for accessibility after test");
        return;
      }
      const testIdentifier = String(testInstance.getContext().getId());
      const testMetadata = testInstance.getData(`accessibility_metadata_${testIdentifier}`);
      if (!testMetadata) {
        this.logger.debug("No accessibility metadata found for this test");
        return;
      }
      const { accessibilityScanStarted, scanTestForAccessibility } = testMetadata;
      if (!accessibilityScanStarted) {
        this.logger.debug("Accessibility scan was not started for this test");
        return;
      }
      if (scanTestForAccessibility) {
        this.logger.info("Automate test case execution has ended. Processing for accessibility testing is underway.");
        const browser = AutomationFramework.getDriver(autoInstance);
        if (browser) {
          let dataForExtension = {
            "thTestRunUuid": process.env.TEST_ANALYTICS_ID,
            "thBuildUuid": process.env.BROWSERSTACK_TESTHUB_UUID,
            "thJwtToken": process.env.BROWSERSTACK_TESTHUB_JWT
          };
          const driverExecuteParams = await this.getDriverExecuteParams();
          dataForExtension = { ...dataForExtension, ...driverExecuteParams };
          await this.sendTestStopEvent(browser, dataForExtension);
          this.logger.info("Accessibility testing for this test case has ended.");
        } else {
          this.logger.warn("No driver found to send accessibility test stop event");
        }
        this.accessibilityMap.delete(sessionId);
        TestFramework.setState(testInstance, `accessibility_metadata_${testIdentifier}`, null);
      }
    } catch (error) {
      this.logger.error(`Accessibility results could not be processed for the test case. Error: ${error}`);
    }
  }
  shouldPatchExecuteScript(script) {
    if (!script || typeof script !== "string") {
      return true;
    }
    return script.toLowerCase().indexOf("browserstack_executor") !== -1 || script.toLowerCase().indexOf("browserstack_accessibility_automation_script") !== -1;
  }
  getCapability(capabilities, key, legacyKey = "") {
    if (key === "deviceName") {
      if (capabilities["bstack:options"] && capabilities["bstack:options"]?.deviceName) {
        return capabilities["bstack:options"]?.deviceName;
      } else if (capabilities["bstack:options"] && capabilities["bstack:options"]?.device) {
        return capabilities["bstack:options"]?.device;
      } else if (capabilities["appium:deviceName"]) {
        return capabilities["appium:deviceName"];
      }
    } else if (key === "goog:chromeOptions" && capabilities["goog:chromeOptions"]) {
      return capabilities["goog:chromeOptions"];
    } else {
      const bstackOptions = capabilities["bstack:options"];
      if (bstackOptions && Object.prototype.hasOwnProperty.call(bstackOptions, key)) {
        return bstackOptions[key];
      } else if (capabilities[legacyKey]) {
        return capabilities[legacyKey];
      }
    }
  }
  async performScanCli(browser, commandName) {
    return await PerformanceTester.measureWrapper(
      A11Y_EVENTS.PERFORM_SCAN,
      async () => {
        try {
          if (!this.accessibility) {
            this.logger.debug("Not an Accessibility Automation session.");
            return;
          }
          if (this.isAppAccessibility) {
            const results2 = await browser.execute(
              formatString(this.scriptInstance.performScan, JSON.stringify(_getParamsForAppAccessibility(commandName))),
              {}
            );
            BStackLogger2.debug(util9.format(results2));
            return results2;
          }
          const results = await browser.executeAsync(
            this.scriptInstance.performScan,
            { "method": commandName || "" }
          );
          return results;
        } catch (err) {
          this.logger.error("Accessibility Scan could not be performed : " + err);
          return;
        }
      },
      { command: commandName }
    )();
  }
  async sendTestStopEvent(browser, dataForExtension) {
    try {
      const autoInstance = AutomationFramework.getTrackedInstance();
      const sessionId = AutomationFramework.getState(autoInstance, AutomationFrameworkConstants.KEY_FRAMEWORK_SESSION_ID);
      if (!this.accessibility) {
        this.logger.debug("Not an Accessibility Automation session.");
        return;
      }
      if (this.accessibilityMap.get(sessionId)) {
        this.logger.debug("Performing scan before saving results");
        await this.performScanCli(browser);
      }
      if (this.isAppAccessibility) {
        return;
      }
      await PerformanceTester.measureWrapper(A11Y_EVENTS.SAVE_RESULTS, async () => {
        const results = await browser.executeAsync(accessibility_scripts_default.saveTestResults, dataForExtension);
        this.logger.debug(`save results : ${util9.format(results)}`);
      })();
    } catch (error) {
      this.logger.error(`Error while sending test stop event: ${error}`);
    }
  }
  async getA11yResults(browser) {
    return await PerformanceTester.measureWrapper(
      A11Y_EVENTS.GET_RESULTS,
      async () => {
        try {
          if (!this.accessibility) {
            this.logger.debug("Not an Accessibility Automation session.");
            return;
          }
          this.logger.debug("Performing scan before getting results");
          await this.performScanCli(browser);
          const results = await browser.executeAsync(this.scriptInstance.getResults);
          return results;
        } catch (error) {
          this.logger.error("No accessibility results were found.");
          this.logger.debug(`getA11yResults Failed. Error: ${error}`);
          return [];
        }
      }
    )();
  }
  async getA11yResultsSummary(browser) {
    return await PerformanceTester.measureWrapper(
      A11Y_EVENTS.GET_RESULTS_SUMMARY,
      async () => {
        try {
          if (!this.accessibility) {
            this.logger.debug("Not an Accessibility Automation session.");
            return;
          }
          this.logger.debug("Performing scan before getting results summary");
          await this.performScanCli(browser);
          const summaryResults = await browser.executeAsync(this.scriptInstance.getResultsSummary);
          return summaryResults;
        } catch {
          this.logger.error("No accessibility summary was found.");
          return {};
        }
      }
    )();
  }
  async getDriverExecuteParams() {
    const payload = {
      product: "accessibility",
      scriptName: "saveResults"
    };
    const response = await GrpcClient.getInstance().fetchDriverExecuteParamsEvent(payload);
    if (response.success) {
      return response.accessibilityExecuteParams ? JSON.parse(Buffer.from(response.accessibilityExecuteParams).toString("utf8")) : {};
    }
    this.logger.error(`Failed to fetch driver execute params: ${response.error || "Unknown error"}`);
    return {};
  }
  async _setAnnotation(message) {
    const autoInstance = AutomationFramework.getTrackedInstance();
    const browser = AutomationFramework.getDriver(autoInstance);
    if (this.accessibility && isBrowserstackSession(browser)) {
      await browser.execute(`browserstack_executor: ${JSON.stringify({
        action: "annotate",
        arguments: {
          data: message,
          level: "info"
        }
      })}`);
    }
  }
};

// src/cli/modules/observabilityModule.ts
var ObservabilityModule = class _ObservabilityModule extends BaseModule {
  logger = BStackLogger2;
  observabilityConfig;
  name;
  static MODULE_NAME = "ObservabilityModule";
  /**
   * Create a new ObservabilityModule
   */
  constructor(observabilityConfig) {
    super();
    this.name = "ObservabilityModule";
    this.observabilityConfig = observabilityConfig;
    AutomationFramework.registerObserver(AutomationFrameworkState.CREATE, HookState.POST, this.onBeforeTest.bind(this));
  }
  /**
   * Get the module name
   * @returns {string} The module name
   */
  getModuleName() {
    return _ObservabilityModule.MODULE_NAME;
  }
  async onBeforeTest(args) {
    if (args.browser) {
      const browser = args.browser;
      PerformanceTester.start(O11Y_EVENTS.SYNC);
      performO11ySync(browser);
      PerformanceTester.end(O11Y_EVENTS.SYNC);
      this.logger.info("onBeforeTest: Observability sync done");
    } else {
      this.logger.error("onBeforeTest: page is not defined");
    }
  }
};

// src/Percy/PercyCaptureMap.ts
var PercyCaptureMap = class {
  #map = {};
  increment(sessionName, eventName) {
    if (!this.#map[sessionName]) {
      this.#map[sessionName] = {};
    }
    if (!this.#map[sessionName][eventName]) {
      this.#map[sessionName][eventName] = 0;
    }
    this.#map[sessionName][eventName]++;
  }
  decrement(sessionName, eventName) {
    if (!this.#map[sessionName] || !this.#map[sessionName][eventName]) {
      return;
    }
    this.#map[sessionName][eventName]--;
  }
  getName(sessionName, eventName) {
    return `${sessionName}-${eventName}-${this.get(sessionName, eventName)}`;
  }
  get(sessionName, eventName) {
    if (!this.#map[sessionName]) {
      return 0;
    }
    if (!this.#map[sessionName][eventName]) {
      return 0;
    }
    return this.#map[sessionName][eventName] - 1;
  }
};
var PercyCaptureMap_default = PercyCaptureMap;

// src/Percy/PercySDK.ts
var PercySDK_exports = {};
__export(PercySDK_exports, {
  screenshot: () => screenshot,
  screenshotApp: () => screenshotApp,
  snapshot: () => snapshot
});

// src/insights-handler.ts
import path15 from "node:path";
import { v4 as uuidv44 } from "uuid";

// src/reporter.ts
import path14 from "node:path";
import WDIOReporter from "@wdio/reporter";
import * as url from "node:url";
import { v4 as uuidv43 } from "uuid";

// src/request-handler.ts
var RequestQueueHandler = class _RequestQueueHandler {
  queue = [];
  callback;
  pollEventBatchInterval;
  static tearDownInvoked = false;
  static instance;
  // making it private to use singleton pattern
  constructor(callback) {
    this.callback = callback;
    this.startEventBatchPolling();
  }
  static getInstance(callback) {
    if (!_RequestQueueHandler.instance && callback) {
      _RequestQueueHandler.instance = new _RequestQueueHandler(callback);
    }
    return _RequestQueueHandler.instance;
  }
  add(event) {
    if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
      throw new Error("Test Reporting and Analytics build start not completed yet.");
    }
    this.queue.push(event);
    BStackLogger.debug(`Added data to request queue. Queue length = ${this.queue.length}`);
    const shouldProceed = this.shouldProceed();
    if (shouldProceed) {
      this.sendBatch().catch((e) => {
        BStackLogger.debug("Exception in sending batch: " + e);
      });
    }
  }
  async shutdown() {
    BStackLogger.debug("shutdown started");
    this.removeEventBatchPolling("Shutting down");
    while (this.queue.length > 0) {
      const data = this.queue.splice(0, DATA_BATCH_SIZE);
      await this.callCallback(data, "SHUTDOWN_QUEUE");
    }
    BStackLogger.debug("shutdown ended");
  }
  startEventBatchPolling() {
    this.pollEventBatchInterval = setInterval(this.sendBatch.bind(this), DATA_BATCH_INTERVAL);
  }
  async sendBatch() {
    const data = this.queue.splice(0, DATA_BATCH_SIZE);
    if (data.length === 0) {
      return;
    }
    BStackLogger.debug(`Sending data from request queue. Data length = ${data.length}, Queue length after removal = ${this.queue.length}`);
    await this.callCallback(data, "INTERVAL_QUEUE");
  }
  callCallback = async (data, kind) => {
    BStackLogger.debug("calling callback with kind " + kind);
    await this.callback?.(data);
  };
  resetEventBatchPolling() {
    this.removeEventBatchPolling("Resetting");
    this.startEventBatchPolling();
  }
  removeEventBatchPolling(tag) {
    if (this.pollEventBatchInterval) {
      BStackLogger.debug(`${tag} request queue`);
      clearInterval(this.pollEventBatchInterval);
    }
  }
  shouldProceed() {
    if (_RequestQueueHandler.tearDownInvoked) {
      BStackLogger.debug("Force request-queue shutdown, as test run event is received after teardown");
      return true;
    }
    return this.queue.length >= DATA_BATCH_SIZE;
  }
};

// src/testOps/requestUtils.ts
import { format as format3 } from "node:util";
async function uploadEventData(eventData, eventUrl = DATA_EVENT_ENDPOINT) {
  let logTag = "BATCH_UPLOAD";
  if (!Array.isArray(eventData)) {
    logTag = getLogTag(eventData.event_type);
  }
  if (eventUrl === DATA_SCREENSHOT_ENDPOINT) {
    logTag = "screenshot_upload";
  }
  if (!process.env[TESTOPS_BUILD_COMPLETED_ENV]) {
    throw new Error("Build start not completed yet");
  }
  if (!process.env[BROWSERSTACK_TESTHUB_JWT]) {
    BStackLogger.debug(`[${logTag}] Missing Authentication Token/ Build ID`);
    throw new Error("Token/buildID is undefined, build creation might have failed");
  }
  try {
    const url3 = `${APIUtils.DATA_ENDPOINT}/${eventUrl}`;
    const data = await fetchWrap(url3, {
      method: "POST",
      headers: {
        ...DEFAULT_REQUEST_CONFIG.headers,
        "Authorization": `Bearer ${process.env[BROWSERSTACK_TESTHUB_JWT]}`
      },
      body: JSON.stringify(eventData)
    });
    BStackLogger.debug(`[${logTag}] Success response: ${JSON.stringify(await data.json())}`);
  } catch (error) {
    BStackLogger.debug(`[${logTag}] Failed. Error: ${format3(error)}`);
    throw error;
  }
}
function sendScreenshots(eventData) {
  return uploadEventData(eventData, DATA_SCREENSHOT_ENDPOINT);
}

// src/testOps/listener.ts
var Listener = class _Listener {
  static instance;
  usageStats = usageStats_default.getInstance();
  testStartedStats = this.usageStats.testStartedStats;
  testFinishedStats = this.usageStats.testFinishedStats;
  hookStartedStats = this.usageStats.hookStartedStats;
  hookFinishedStats = this.usageStats.hookFinishedStats;
  cbtSessionStats = this.usageStats.cbtSessionStats;
  logEvents = this.usageStats.logStats;
  requestBatcher;
  pendingUploads = 0;
  static _accessibilityOptions;
  static _testRunAccessibilityVar = false;
  // Making the constructor private to use singleton pattern
  constructor() {
  }
  static getInstance() {
    if (!_Listener.instance) {
      _Listener.instance = new _Listener();
    }
    return _Listener.instance;
  }
  static setAccessibilityOptions(options) {
    _Listener._accessibilityOptions = options;
  }
  static setTestRunAccessibilityVar(accessibility) {
    _Listener._testRunAccessibilityVar = accessibility;
  }
  async onWorkerEnd() {
    try {
      await this.uploadPending();
      await this.teardown();
    } catch (e) {
      BStackLogger.debug("Exception in onWorkerEnd: " + e);
    }
  }
  async uploadPending(waitTimeout = DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS, waitInterval = DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS) {
    if (this.pendingUploads <= 0 || waitTimeout <= 0) {
      return;
    }
    await sleep(waitInterval);
    return this.uploadPending(waitTimeout - waitInterval);
  }
  async teardown() {
    BStackLogger.debug("teardown started");
    RequestQueueHandler.tearDownInvoked = true;
    await this.requestBatcher?.shutdown();
    BStackLogger.debug("teardown ended");
  }
  hookStarted(hookData) {
    try {
      if (!shouldProcessEventForTesthub("HookRunStarted")) {
        return;
      }
      this.hookStartedStats.triggered();
      this.sendBatchEvents(this.getEventForHook("HookRunStarted", hookData));
    } catch (e) {
      this.hookStartedStats.failed();
      throw e;
    }
  }
  hookFinished(hookData) {
    try {
      if (!shouldProcessEventForTesthub("HookRunFinished")) {
        return;
      }
      this.hookFinishedStats.triggered(hookData.result);
      this.sendBatchEvents(this.getEventForHook("HookRunFinished", hookData));
    } catch (e) {
      this.hookFinishedStats.failed(hookData.result);
      throw e;
    }
  }
  testStarted(testData) {
    try {
      if (!shouldProcessEventForTesthub("TestRunStarted")) {
        return;
      }
      process.env[TEST_ANALYTICS_ID] = testData.uuid;
      this.testStartedStats.triggered();
      testData.product_map = {
        accessibility: _Listener._testRunAccessibilityVar
      };
      this.sendBatchEvents(this.getEventForHook("TestRunStarted", testData));
    } catch (e) {
      this.testStartedStats.failed();
      throw e;
    }
  }
  testFinished(testData) {
    try {
      if (!shouldProcessEventForTesthub("TestRunFinished")) {
        return;
      }
      testData.product_map = {
        accessibility: _Listener._testRunAccessibilityVar
      };
      this.testFinishedStats.triggered(testData.result);
      this.sendBatchEvents(this.getEventForHook("TestRunFinished", testData));
    } catch (e) {
      this.testFinishedStats.failed(testData.result);
      throw e;
    }
  }
  logCreated(logs) {
    try {
      if (!shouldProcessEventForTesthub("LogCreated")) {
        return;
      }
      this.markLogs("triggered", logs);
      this.sendBatchEvents({
        event_type: "LogCreated",
        logs
      });
    } catch (e) {
      this.markLogs("failed", logs);
      throw e;
    }
  }
  async onScreenshot(jsonArray) {
    if (!this.shouldSendEvents()) {
      return;
    }
    try {
      if (!shouldProcessEventForTesthub("LogCreated")) {
        return;
      }
      this.markLogs("triggered", jsonArray);
      this.pendingUploads += 1;
      await sendScreenshots([{
        event_type: "LogCreated",
        logs: jsonArray
      }]);
      this.markLogs("success", jsonArray);
    } catch (e) {
      this.markLogs("failed", jsonArray);
      throw e;
    } finally {
      this.pendingUploads -= 1;
    }
  }
  cbtSessionCreated(data) {
    try {
      if (!shouldProcessEventForTesthub("CBTSessionCreated")) {
        return;
      }
      this.cbtSessionStats.triggered();
      this.sendBatchEvents({ event_type: "CBTSessionCreated", test_run: data });
    } catch (e) {
      this.cbtSessionStats.failed();
      throw e;
    }
  }
  markLogs(status, data) {
    if (!data) {
      BStackLogger.debug("No log data");
      return;
    }
    try {
      for (const _log of data) {
        const kind = _log.kind;
        this.logEvents.mark(status, LOG_KIND_USAGE_MAP[kind] || kind);
      }
    } catch (e) {
      BStackLogger.debug("Exception in marking logs status " + e);
      throw e;
    }
  }
  getResult(jsonObject, kind) {
    const runStr = kind === "test" ? "test_run" : "hook_run";
    const runData = jsonObject[runStr];
    return runData?.result;
  }
  shouldSendEvents() {
    return isTrue(process.env[TESTOPS_BUILD_COMPLETED_ENV]);
  }
  sendBatchEvents(jsonObject) {
    if (!this.shouldSendEvents()) {
      return;
    }
    if (!this.requestBatcher) {
      this.requestBatcher = RequestQueueHandler.getInstance(async (data) => {
        BStackLogger.debug("callback: called with events " + data.length);
        try {
          this.pendingUploads += 1;
          await batchAndPostEvents(DATA_BATCH_ENDPOINT, "BATCH_DATA", data);
          BStackLogger.debug("callback: marking events success " + data.length);
          this.eventsSuccess(data);
        } catch {
          BStackLogger.debug("callback: marking events failed " + data.length);
          this.eventsFailed(data);
        } finally {
          this.pendingUploads -= 1;
        }
      });
    }
    this.requestBatcher.add(jsonObject);
  }
  eventsFailed(events) {
    for (const event of events) {
      const eventType = event.event_type;
      if (eventType === "TestRunStarted") {
        this.testStartedStats.failed();
      } else if (eventType === "TestRunFinished") {
        this.testFinishedStats.failed(this.getResult(event, "test"));
      } else if (eventType === "HookRunStarted") {
        this.hookStartedStats.failed();
      } else if (eventType === "HookRunFinished") {
        this.hookFinishedStats.failed(this.getResult(event, "hook"));
      } else if (eventType === "CBTSessionCreated") {
        this.cbtSessionStats.failed();
      } else if (eventType === "LogCreated") {
        this.markLogs("failed", event.logs);
      }
    }
  }
  eventsSuccess(events) {
    for (const event of events) {
      const eventType = event.event_type;
      if (eventType === "TestRunStarted") {
        this.testStartedStats.success();
      } else if (eventType === "TestRunFinished") {
        this.testFinishedStats.success(this.getResult(event, "test"));
      } else if (eventType === "HookRunStarted") {
        this.hookStartedStats.success();
      } else if (eventType === "HookRunFinished") {
        this.hookFinishedStats.success(this.getResult(event, "hook"));
      } else if (eventType === "CBTSessionCreated") {
        this.cbtSessionStats.success();
      } else if (eventType === "LogCreated") {
        this.markLogs("success", event.logs);
      }
    }
  }
  getEventForHook(eventType, data) {
    return {
      event_type: eventType,
      [data.type === "hook" ? "hook_run" : "test_run"]: data
    };
  }
};
var listener_default = Listener;

// src/reporter.ts
var _TestReporter = class __TestReporter extends WDIOReporter {
  _capabilities = {};
  _config;
  _observability = true;
  _sessionId;
  _suiteName;
  _suites = [];
  static _tests = {};
  _gitConfigPath;
  _gitConfigured = false;
  _currentHook = {};
  static currentTest = {};
  _userCaps = {};
  listener = listener_default.getInstance();
  static hashCodeToHandleTestSkip = {};
  async onRunnerStart(runnerStats) {
    this._capabilities = runnerStats.capabilities;
    this._userCaps = this.getUserCaps(runnerStats);
    this._config = runnerStats.config;
    this._sessionId = runnerStats.sessionId;
    if (typeof this._config.testObservability !== "undefined") {
      this._observability = this._config.testObservability;
    }
    await this.configureGit();
    this.registerListeners();
  }
  getUserCaps(runnerStats) {
    return runnerStats.capabilities;
  }
  registerListeners() {
    if (this._config?.framework !== "jasmine") {
      return;
    }
    process.removeAllListeners(`bs:addLog:${process.pid}`);
    process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
  }
  async appendTestItemLog(stdLog) {
    if (this._currentHook.uuid && !this._currentHook.finished) {
      stdLog.hook_run_uuid = this._currentHook.uuid;
    } else if (__TestReporter.currentTest.uuid) {
      stdLog.test_run_uuid = __TestReporter.currentTest.uuid;
    }
    if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
      this.listener.logCreated([stdLog]);
    }
  }
  setCurrentHook(hookDetails) {
    if (hookDetails.finished) {
      if (this._currentHook.uuid === hookDetails.uuid) {
        this._currentHook.finished = true;
      }
      return;
    }
    this._currentHook = {
      uuid: hookDetails.uuid,
      finished: false
    };
  }
  async configureGit() {
    if (this._gitConfigured) {
      return;
    }
    const gitMeta = await getGitMetaData();
    if (gitMeta) {
      this._gitConfigPath = gitMeta.root;
    }
    this._gitConfigured = true;
  }
  static getTests() {
    return __TestReporter._tests;
  }
  onSuiteStart(suiteStats) {
    let filename = suiteStats.file;
    if (this._config?.framework === "jasmine") {
      try {
        if (suiteStats.file.startsWith("file://")) {
          filename = url.fileURLToPath(suiteStats.file);
        }
        if (filename === "unknown spec file") {
          filename = this._suiteName || suiteStats.file;
        }
      } catch {
        BStackLogger.debug("Error in decoding file name of suite");
      }
    }
    this._suiteName = filename;
    this._suites.push(suiteStats);
  }
  onSuiteEnd() {
    this._suites.pop();
  }
  needToSendData(testType, event) {
    if (!this._observability) {
      return false;
    }
    switch (this._config?.framework) {
      case "mocha":
        return event === "skip";
      case "cucumber":
        return false;
      case "jasmine":
        return event !== "skip";
      default:
        return false;
    }
  }
  async onTestEnd(testStats) {
    if (!this.needToSendData("test", "end")) {
      return;
    }
    if (testStats.fullTitle === "<unknown test>") {
      return;
    }
    testStats.end ||= /* @__PURE__ */ new Date();
    this.listener.testFinished(await this.getRunData(testStats, "TestRunFinished"));
  }
  async onTestStart(testStats) {
    if (!this.needToSendData("test", "start")) {
      return;
    }
    if (testStats.fullTitle === "<unknown test>") {
      return;
    }
    const uuid = uuidv43();
    __TestReporter.currentTest.uuid = uuid;
    __TestReporter._tests[testStats.fullTitle] = {
      uuid
    };
    this.listener.testStarted(await this.getRunData(testStats, "TestRunStarted"));
  }
  async onHookStart(hookStats) {
    if (!this.needToSendData("hook", "start")) {
      return;
    }
    const identifier = this.getHookIdentifier(hookStats);
    const hookId = uuidv43();
    this.setCurrentHook({ uuid: hookId });
    __TestReporter._tests[identifier] = {
      uuid: hookId,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.listener.hookStarted(await this.getRunData(hookStats, "HookRunStarted"));
  }
  async onHookEnd(hookStats) {
    if (!this.needToSendData("hook", "end")) {
      return;
    }
    const identifier = this.getHookIdentifier(hookStats);
    if (__TestReporter._tests[identifier]) {
      __TestReporter._tests[identifier].finishedAt = (/* @__PURE__ */ new Date()).toISOString();
    } else {
      __TestReporter._tests[identifier] = {
        finishedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    this.setCurrentHook({ uuid: __TestReporter._tests[identifier].uuid, finished: true });
    if (!hookStats.state && !hookStats.error) {
      hookStats.state = "passed";
    }
    this.listener.hookFinished(await this.getRunData(hookStats, "HookRunFinished"));
  }
  getHookIdentifier(hookStats) {
    return `${hookStats.title} for ${this._suites.at(-1)?.title}`;
  }
  async onTestSkip(testStats) {
    if (!this.needToSendData("test", "skip")) {
      return;
    }
    testStats.start ||= /* @__PURE__ */ new Date();
    testStats.end ||= /* @__PURE__ */ new Date();
    const testData = await this.getRunData(testStats, "TestRunSkipped");
    const testFinishHashCode = generateHashCodeFromFields(
      [
        testData.integrations?.browserstack?.browser ?? "",
        testData.integrations?.browserstack?.browser_version ?? "",
        testData.integrations?.browserstack?.platform ?? "",
        testData.integrations?.browserstack?.session_id ?? "",
        testData.integrations?.capabilities ?? {},
        testData.file_name ?? "",
        testData.scopes ?? [],
        testData.name ?? ""
      ]
    );
    if (__TestReporter.hashCodeToHandleTestSkip !== null && !isObjectEmpty(__TestReporter.hashCodeToHandleTestSkip) && testFinishHashCode in __TestReporter.hashCodeToHandleTestSkip) {
      if (__TestReporter.hashCodeToHandleTestSkip[testFinishHashCode] !== "") {
        testData.uuid = __TestReporter.hashCodeToHandleTestSkip[testFinishHashCode];
      }
    }
    this.listener.testFinished(testData);
  }
  async getRunData(testStats, eventType) {
    const framework = this._config?.framework;
    const scopes = this._suites.map((s) => s.title);
    const identifier = testStats.type === "test" ? testStats.fullTitle : this.getHookIdentifier(testStats);
    const testMetaData = __TestReporter._tests[identifier];
    const scope = testStats.type === "test" ? testStats.fullTitle : `${this._suites[0].title} - ${testStats.title}`;
    const suiteFileName = this._suiteName || (this.specs?.length > 0 ? this.specs[this.specs.length - 1]?.replace("file:", "") : void 0);
    if (eventType === "TestRunStarted") {
      __TestReporter.currentTest.name = testStats.title;
    }
    await this.configureGit();
    const testData = {
      uuid: testMetaData ? testMetaData.uuid : uuidv43(),
      type: testStats.type,
      name: testStats.title,
      body: {
        lang: "webdriverio",
        code: null
      },
      scope,
      scopes,
      identifier,
      file_name: suiteFileName ? path14.relative(process.cwd(), suiteFileName) : void 0,
      location: suiteFileName ? path14.relative(process.cwd(), suiteFileName) : void 0,
      vc_filepath: this._gitConfigPath && suiteFileName ? path14.relative(this._gitConfigPath, suiteFileName) : void 0,
      started_at: testStats.start && testStats.start.toISOString(),
      finished_at: testStats.end && testStats.end.toISOString(),
      framework,
      duration_in_ms: testStats._duration,
      result: testStats.state
    };
    if (testStats.type === "test") {
      testData.retries = { limit: testStats.retries || 0, attempts: testStats.retries || 0 };
    }
    if (eventType.startsWith("TestRun") || eventType === "HookRunStarted") {
      const cloudProvider = getCloudProvider({ options: { hostname: this._config?.hostname } });
      testData.integrations = {};
      testData.integrations[cloudProvider] = {
        capabilities: this._capabilities,
        session_id: this._sessionId,
        browser: this._capabilities?.browserName,
        browser_version: this._capabilities?.browserVersion,
        platform: this._capabilities?.platformName,
        platform_version: getPlatformVersion(this._capabilities, this._userCaps)
      };
    }
    if (eventType === "TestRunFinished" || eventType === "HookRunFinished") {
      const { error } = testStats;
      const failed = testStats.state === "failed";
      if (failed) {
        testData.result = error && error.message && error.message.includes("sync skip; aborting execution") ? "ignore" : "failed";
        if (error && testData.result !== "skipped") {
          testData.failure = [{ backtrace: [removeAnsiColors(error.message), removeAnsiColors(error.stack || "")] }];
          testData.failure_reason = removeAnsiColors(error.message);
          testData.failure_type = error.message === null ? null : error.message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError";
        }
      }
    }
    if (eventType === "TestRunSkipped") {
      eventType = "TestRunFinished";
    }
    if (eventType.match(/HookRun/)) {
      testData.hook_type = testData.name?.toLowerCase() ? getHookType(testData.name.toLowerCase()) : "undefined";
    }
    return testData;
  }
};
var TestReporter = o11yClassErrorHandler(_TestReporter);
var reporter_default = TestReporter;

// src/insights-handler.ts
var _InsightsHandler = class {
  constructor(_browser, _framework, _userCaps, _options) {
    this._browser = _browser;
    this._framework = _framework;
    const caps = this._browser.capabilities;
    const sessionId = this._browser.sessionId;
    this._userCaps = _userCaps;
    this._options = _options;
    this._platformMeta = {
      browserName: caps.browserName,
      browserVersion: caps?.browserVersion,
      platformName: caps?.platformName,
      caps,
      sessionId,
      product: getObservabilityProduct(_options, this._isAppAutomate())
    };
    this.registerListeners();
  }
  _tests = {};
  _hooks = {};
  _platformMeta;
  _commands = {};
  _gitConfigPath;
  _suiteFile;
  static currentTest = {};
  _currentHook = {};
  _cucumberData = {
    stepsStarted: false,
    scenariosStarted: false,
    steps: []
  };
  _userCaps = {};
  _options;
  listener = listener_default.getInstance();
  currentTestId;
  cbtQueue = [];
  _isAppAutomate() {
    const browserDesiredCapabilities = this._browser?.capabilities ?? {};
    const desiredCapabilities = this._userCaps ?? {};
    return !!browserDesiredCapabilities["appium:app"] || !!desiredCapabilities["appium:app"] || !!desiredCapabilities["appium:options"]?.app;
  }
  registerListeners() {
    if (!(this._framework === "mocha" || this._framework === "cucumber")) {
      return;
    }
    process.removeAllListeners(`bs:addLog:${process.pid}`);
    process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
  }
  setSuiteFile(filename) {
    this._suiteFile = filename;
  }
  async before() {
    if (isBrowserstackSession(this._browser)) {
      await this._browser.executeScript(`browserstack_executor: ${JSON.stringify({
        action: "annotate",
        arguments: {
          data: `TestReportingSync:${Date.now()}`,
          level: "debug"
        }
      })}`, []);
    }
    const gitMeta = await getGitMetaData();
    if (gitMeta) {
      this._gitConfigPath = gitMeta.root;
    }
  }
  getCucumberHookType(test) {
    let hookType = null;
    if (!test) {
      hookType = this._cucumberData.scenariosStarted ? "AFTER_ALL" : "BEFORE_ALL";
    } else if (!this._cucumberData.stepsStarted) {
      hookType = "BEFORE_EACH";
    } else if (this._cucumberData.steps?.length > 0) {
    } else {
      hookType = "AFTER_EACH";
    }
    return hookType;
  }
  getCucumberHookName(hookType) {
    switch (hookType) {
      case "BEFORE_EACH":
      case "AFTER_EACH":
        return `${hookType} for ${this._cucumberData.scenario?.name}`;
      case "BEFORE_ALL":
      case "AFTER_ALL":
        return `${hookType} for ${this._cucumberData.feature?.name}`;
    }
    return "";
  }
  getCucumberHookUniqueId(hookType, hook) {
    switch (hookType) {
      case "BEFORE_EACH":
      case "AFTER_EACH":
        return hook.hookId;
      case "BEFORE_ALL":
      case "AFTER_ALL":
        return `${hookType} for ${this.getCucumberFeatureUniqueId()}`;
    }
    return null;
  }
  getCucumberFeatureUniqueId() {
    const { uri, feature } = this._cucumberData;
    return `${uri}:${feature?.name}`;
  }
  setCurrentHook(hookDetails) {
    if (hookDetails.finished) {
      if (this._currentHook.uuid === hookDetails.uuid) {
        this._currentHook.finished = true;
      }
      return;
    }
    this._currentHook = {
      uuid: hookDetails.uuid,
      finished: false
    };
  }
  async sendScenarioObjectSkipped(scenario, feature, uri) {
    const testMetaData = {
      uuid: uuidv44(),
      startedAt: (/* @__PURE__ */ new Date()).toISOString(),
      finishedAt: (/* @__PURE__ */ new Date()).toISOString(),
      scenario: {
        name: scenario.name
      },
      feature: {
        path: uri,
        name: feature.name,
        description: feature.description
      },
      steps: scenario.steps.map((step) => {
        return {
          id: step.id,
          text: step.text,
          keyword: step.keyword,
          result: "skipped"
        };
      })
    };
    this.listener.testFinished(this.getTestRunDataForCucumber(null, "TestRunSkipped", testMetaData));
  }
  async processCucumberHook(test, params, result) {
    const hookType = this.getCucumberHookType(test);
    if (!hookType) {
      return;
    }
    const { event, hookUUID } = params;
    const hookId = this.getCucumberHookUniqueId(hookType, test);
    if (!hookId) {
      return;
    }
    if (event === "before") {
      this.setCurrentHook({ uuid: hookUUID });
      const hookMetaData = {
        uuid: hookUUID,
        startedAt: (/* @__PURE__ */ new Date()).toISOString(),
        testRunId: InsightsHandler.currentTest.uuid,
        hookType
      };
      this._tests[hookId] = hookMetaData;
      this.listener.hookStarted(this.getHookRunDataForCucumber(hookMetaData, "HookRunStarted"));
    } else {
      this._tests[hookId].finishedAt = (/* @__PURE__ */ new Date()).toISOString();
      this.setCurrentHook({ uuid: this._tests[hookId].uuid, finished: true });
      this.listener.hookFinished(this.getHookRunDataForCucumber(this._tests[hookId], "HookRunFinished", result));
      if (hookType === "BEFORE_ALL" && result && !result.passed) {
        const { feature, uri } = this._cucumberData;
        if (!feature) {
          return;
        }
        feature.children.map(async (childObj) => {
          if (childObj.rule) {
            childObj.rule.children.map(async (scenarioObj) => {
              if (scenarioObj.scenario) {
                await this.sendScenarioObjectSkipped(scenarioObj.scenario, feature, uri);
              }
            });
          } else if (childObj.scenario) {
            await this.sendScenarioObjectSkipped(childObj.scenario, feature, uri);
          }
        });
      }
    }
  }
  async beforeHook(test, context) {
    if (!frameworkSupportsHook("before", this._framework)) {
      return;
    }
    const hookUUID = uuidv44();
    if (this._framework === "cucumber") {
      test = test;
      await this.processCucumberHook(test, { event: "before", hookUUID });
      return;
    }
    test = test;
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      uuid: hookUUID,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.setCurrentHook({ uuid: hookUUID });
    this.attachHookData(context, hookUUID);
    this.listener.hookStarted(this.getRunData(test, "HookRunStarted"));
  }
  async afterHook(test, result) {
    if (!frameworkSupportsHook("after", this._framework)) {
      return;
    }
    if (this._framework === "cucumber") {
      await this.processCucumberHook(test, { event: "after" }, result);
      return;
    }
    test = test;
    const fullTitle = getUniqueIdentifier(test, this._framework);
    if (this._tests[fullTitle]) {
      this._tests[fullTitle].finishedAt = (/* @__PURE__ */ new Date()).toISOString();
    } else {
      this._tests[fullTitle] = {
        finishedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    this.setCurrentHook({ uuid: this._tests[fullTitle].uuid, finished: true });
    this.listener.hookFinished(this.getRunData(test, "HookRunFinished", result));
    const hookType = getHookType(test.title);
    if (!result.passed && (hookType === "BEFORE_EACH" || hookType === "BEFORE_ALL" || hookType === "AFTER_EACH")) {
      const sendTestSkip = async (skippedTest) => {
        if (skippedTest.state === void 0) {
          const fullTitle2 = `${skippedTest.parent.title} - ${skippedTest.title}`;
          this._tests[fullTitle2] = {
            uuid: uuidv44(),
            startedAt: (/* @__PURE__ */ new Date()).toISOString(),
            finishedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          this.listener.testFinished(this.getRunData(skippedTest, "TestRunSkipped"));
        }
      };
      const sendSuiteSkipped = async (suite) => {
        for (const skippedTest of suite.tests) {
          await sendTestSkip(skippedTest);
        }
        for (const skippedSuite of suite.suites) {
          await sendSuiteSkipped(skippedSuite);
        }
      };
      await sendSuiteSkipped(test.ctx.test.parent);
    }
  }
  getHookRunDataForCucumber(hookData, eventType, result) {
    const { uri, feature } = this._cucumberData;
    const testData = {
      uuid: hookData.uuid,
      type: "hook",
      name: this.getCucumberHookName(hookData.hookType),
      body: {
        lang: "webdriverio",
        code: null
      },
      started_at: hookData.startedAt,
      finished_at: hookData.finishedAt,
      hook_type: hookData.hookType,
      test_run_id: hookData.testRunId,
      scope: feature?.name,
      scopes: [feature?.name || ""],
      file_name: uri ? path15.relative(process.cwd(), uri) : void 0,
      location: uri ? path15.relative(process.cwd(), uri) : void 0,
      vc_filepath: this._gitConfigPath && uri ? path15.relative(this._gitConfigPath, uri) : void 0,
      result: "pending",
      framework: this._framework
    };
    if (eventType === "HookRunFinished" && result) {
      testData.result = result.passed ? "passed" : "failed";
      testData.retries = result.retries;
      testData.duration_in_ms = result.duration;
      if (!result.passed) {
        Object.assign(testData, getFailureObject(result.error));
      }
    }
    if (eventType === "HookRunStarted") {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
    }
    return testData;
  }
  async beforeTest(test) {
    const uuid = uuidv44();
    InsightsHandler.currentTest = {
      test,
      uuid
    };
    if (this._framework !== "mocha") {
      return;
    }
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      uuid,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.listener.testStarted(this.getRunData(test, "TestRunStarted"));
  }
  async afterTest(test, result) {
    if (this._framework !== "mocha") {
      return;
    }
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      ...this._tests[fullTitle] || {},
      finishedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.flushCBTDataQueue();
    const testData = this.getRunData(test, "TestRunFinished", result);
    this.listener.testFinished(testData);
    const testFinishHashCode = generateHashCodeFromFields(
      [
        testData.integrations?.browserstack?.browser ?? "",
        testData.integrations?.browserstack?.browser_version ?? "",
        testData.integrations?.browserstack?.platform ?? "",
        testData.integrations?.browserstack?.session_id ?? "",
        testData.integrations?.capabilities ?? {},
        testData.file_name ?? "",
        testData.scopes ?? [],
        testData.name ?? ""
      ]
    );
    reporter_default.hashCodeToHandleTestSkip[testFinishHashCode] = testData.uuid ?? "";
  }
  /**
    * Cucumber Only
    */
  async beforeFeature(uri, feature) {
    this._cucumberData.scenariosStarted = false;
    this._cucumberData.feature = feature;
    this._cucumberData.uri = uri;
  }
  async beforeScenario(world) {
    const uuid = uuidv44();
    InsightsHandler.currentTest = {
      uuid
    };
    this._cucumberData.scenario = world.pickle;
    this._cucumberData.scenariosStarted = true;
    this._cucumberData.stepsStarted = false;
    const pickleData = world.pickle;
    const gherkinDocument = world.gherkinDocument;
    const featureData = gherkinDocument.feature;
    const uniqueId = getUniqueIdentifierForCucumber(world);
    const testMetaData = {
      uuid,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (pickleData) {
      testMetaData.scenario = {
        name: pickleData.name
      };
    }
    if (gherkinDocument && featureData) {
      testMetaData.feature = {
        path: gherkinDocument.uri,
        name: featureData.name,
        description: featureData.description
      };
    }
    this._tests[uniqueId] = testMetaData;
    this.listener.testStarted(this.getTestRunDataForCucumber(world, "TestRunStarted"));
  }
  async afterScenario(world) {
    this._cucumberData.scenario = void 0;
    this.flushCBTDataQueue();
    this.listener.testFinished(this.getTestRunDataForCucumber(world, "TestRunFinished"));
  }
  async beforeStep(step, scenario) {
    this._cucumberData.stepsStarted = true;
    this._cucumberData.steps.push(step);
    const uniqueId = getUniqueIdentifierForCucumber({ pickle: scenario });
    const testMetaData = this._tests[uniqueId] || { steps: [] };
    if (testMetaData && !testMetaData.steps) {
      testMetaData.steps = [];
    }
    testMetaData.steps?.push({
      id: step.id,
      text: step.text,
      keyword: step.keyword,
      started_at: (/* @__PURE__ */ new Date()).toISOString()
    });
    this._tests[uniqueId] = testMetaData;
  }
  async afterStep(step, scenario, result) {
    this._cucumberData.steps.pop();
    const uniqueId = getUniqueIdentifierForCucumber({ pickle: scenario });
    const testMetaData = this._tests[uniqueId] || { steps: [] };
    if (!testMetaData.steps) {
      testMetaData.steps = [{
        id: step.id,
        text: step.text,
        keyword: step.keyword,
        finished_at: (/* @__PURE__ */ new Date()).toISOString(),
        result: result.passed ? "PASSED" : "FAILED",
        duration: result.duration,
        failure: result.error ? removeAnsiColors(result.error) : result.error
      }];
    }
    const stepDetails = testMetaData.steps?.find((item) => item.id === step.id);
    if (stepDetails) {
      stepDetails.finished_at = (/* @__PURE__ */ new Date()).toISOString();
      stepDetails.result = result.passed ? "PASSED" : "FAILED";
      stepDetails.duration = result.duration;
      stepDetails.failure = result.error ? removeAnsiColors(result.error) : result.error;
    }
    this._tests[uniqueId] = testMetaData;
  }
  /**
   * misc methods
   */
  appendTestItemLog = async (stdLog) => {
    try {
      if (BrowserstackCLI.getInstance().isRunning()) {
        await BrowserstackCLI.getInstance().getTestFramework().trackEvent(TestFrameworkState.LOG, HookState.POST, { logEntry: stdLog });
        return;
      }
      if (this._currentHook.uuid && !this._currentHook.finished && (this._framework === "mocha" || this._framework === "cucumber")) {
        stdLog.hook_run_uuid = this._currentHook.uuid;
      } else if (InsightsHandler.currentTest.uuid && (this._framework === "mocha" || this._framework === "cucumber")) {
        stdLog.test_run_uuid = InsightsHandler.currentTest.uuid;
      }
      if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
        this.listener.logCreated([stdLog]);
      }
    } catch (error) {
      BStackLogger.debug(`Exception in uploading log data to Test Reporting and Analytics with error : ${error}`);
    }
  };
  async browserCommand(commandType, args, test) {
    const dataKey = `${args.sessionId}_${args.method}_${args.endpoint}`;
    if (commandType === "client:beforeCommand") {
      this._commands[dataKey] = args;
      return;
    }
    if (!test) {
      return;
    }
    const identifier = this.getIdentifier(test);
    const testMeta = this._tests[identifier] || reporter_default.getTests()[identifier];
    if (!testMeta) {
      return;
    }
    const body = "body" in args ? args.body : void 0;
    const result = "result" in args ? args.result : void 0;
    if (Boolean(process.env[TESTOPS_SCREENSHOT_ENV]) && isScreenshotCommand(args) && result?.value) {
      await this.listener.onScreenshot([{
        test_run_uuid: testMeta.uuid,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        message: result.value,
        kind: "TEST_SCREENSHOT"
      }]);
    }
    const requestData = this._commands[dataKey];
    if (!requestData) {
      return;
    }
    this.listener.logCreated(
      [{
        test_run_uuid: testMeta.uuid,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        kind: "HTTP",
        http_response: {
          path: requestData.endpoint,
          method: requestData.method,
          body,
          response: result
        }
      }]
    );
  }
  /*
   * private methods
   */
  /**
   * Check if any test steps failed (excluding hook failures)
   * This is used when ignoreHooksStatus is true to determine test status based only on test steps
   */
  hasTestStepFailures(world) {
    if (!world?.pickle) {
      return false;
    }
    const uniqueId = getUniqueIdentifierForCucumber(world);
    const testMetaData = this._tests[uniqueId];
    if (!testMetaData?.steps) {
      return false;
    }
    return testMetaData.steps.some((step) => step.result === "FAILED");
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  attachHookData(context, hookId) {
    if (context.currentTest && context.currentTest.parent) {
      const parentTest = `${context.currentTest.parent.title} - ${context.currentTest.title}`;
      if (!this._hooks[parentTest]) {
        this._hooks[parentTest] = [];
      }
      this._hooks[parentTest].push(hookId);
      return;
    } else if (context.test) {
      this.setHooksFromSuite(context.test.parent, hookId);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setHooksFromSuite(parent, hookId) {
    if (!parent) {
      return false;
    }
    if (parent.tests && parent.tests.length > 0) {
      const uniqueIdentifier = getUniqueIdentifier(parent.tests[0], this._framework);
      if (!this._hooks[uniqueIdentifier]) {
        this._hooks[uniqueIdentifier] = [];
      }
      this._hooks[uniqueIdentifier].push(hookId);
      return true;
    }
    for (const suite of parent.suites) {
      const result = this.setHooksFromSuite(suite, hookId);
      if (result) {
        return true;
      }
    }
    return false;
  }
  /*
   * Get hierarchy info
   */
  getHierarchy(test) {
    const value = [];
    if (test.ctx && test.ctx.test) {
      let parent = typeof test.parent === "object" ? test.parent : test.ctx.test.parent;
      while (parent && parent.title !== "") {
        value.push(parent.title);
        parent = parent.parent;
      }
    } else if (test.description && test.fullName) {
      value.push(test.description);
      value.push(test.fullName.replace(new RegExp(" " + test.description + "$"), ""));
    }
    return value.reverse();
  }
  getRunData(test, eventType, results) {
    const fullTitle = getUniqueIdentifier(test, this._framework);
    const testMetaData = this._tests[fullTitle];
    const filename = test.file || this._suiteFile;
    this.currentTestId = testMetaData.uuid;
    if (eventType === "TestRunStarted") {
      InsightsHandler.currentTest.name = test.title || test.description;
    }
    const testData = {
      uuid: testMetaData.uuid,
      type: test.type || "test",
      name: test.title || test.description,
      body: {
        lang: "webdriverio",
        code: test.body
      },
      scope: fullTitle,
      scopes: this.getHierarchy(test),
      identifier: fullTitle,
      file_name: filename ? path15.relative(process.cwd(), filename) : void 0,
      location: filename ? path15.relative(process.cwd(), filename) : void 0,
      vc_filepath: this._gitConfigPath && filename ? path15.relative(this._gitConfigPath, filename) : void 0,
      started_at: testMetaData.startedAt,
      finished_at: testMetaData.finishedAt,
      result: "pending",
      framework: this._framework
    };
    if ((eventType === "TestRunFinished" || eventType === "HookRunFinished") && results) {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
      const { error, passed } = results;
      if (!passed) {
        testData.result = error && error.message && error.message.includes("sync skip; aborting execution") ? "ignore" : "failed";
        if (error && testData.result !== "skipped") {
          testData.failure = [{ backtrace: [removeAnsiColors(error.message), removeAnsiColors(error.stack || "")] }];
          testData.failure_reason = removeAnsiColors(error.message);
          testData.failure_type = isUndefined(error.message) ? null : error.message.toString().match(/AssertionError/) ? "AssertionError" : "UnhandledError";
        }
      } else {
        testData.result = "passed";
      }
      testData.retries = results.retries;
      testData.duration_in_ms = results.duration;
      if (this._hooks[fullTitle]) {
        testData.hooks = this._hooks[fullTitle];
      }
    }
    if (eventType === "TestRunStarted" || eventType === "TestRunSkipped" || eventType === "HookRunStarted") {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
    }
    if (eventType === "TestRunSkipped") {
      if (this._hooks[fullTitle]) {
        testData.hooks = this._hooks[fullTitle];
      }
      testData.result = "skipped";
      eventType = "TestRunFinished";
    }
    if (eventType.match(/HookRun/)) {
      testData.hook_type = testData.name?.toLowerCase() ? getHookType(testData.name.toLowerCase()) : "undefined";
      testData.test_run_id = this.getTestRunId(test.ctx);
    }
    return testData;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getTestRunId(context) {
    if (!context) {
      return;
    }
    if (context.currentTest) {
      const uniqueIdentifier = getUniqueIdentifier(context.currentTest, this._framework);
      return this._tests[uniqueIdentifier] && this._tests[uniqueIdentifier].uuid;
    }
    if (!context.test) {
      return;
    }
    return this.getTestRunIdFromSuite(context.test.parent);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getTestRunIdFromSuite(parent) {
    if (!parent) {
      return;
    }
    for (const test of parent.tests) {
      const uniqueIdentifier = getUniqueIdentifier(test, this._framework);
      if (this._tests[uniqueIdentifier]) {
        return this._tests[uniqueIdentifier].uuid;
      }
    }
    for (const suite of parent.suites) {
      const testRunId = this.getTestRunIdFromSuite(suite);
      if (testRunId) {
        return testRunId;
      }
    }
    return;
  }
  getTestRunDataForCucumber(worldObj, eventType, testMetaData = null) {
    const world = worldObj;
    const dataHub = testMetaData ? testMetaData : this._tests[getUniqueIdentifierForCucumber(world)] || {};
    const { feature, scenario, steps, uuid, startedAt, finishedAt } = dataHub;
    const examples = !testMetaData ? getScenarioExamples(world) : void 0;
    let fullNameWithExamples;
    if (!testMetaData) {
      fullNameWithExamples = examples ? world.pickle.name + " (" + examples.join(", ") + ")" : world.pickle.name;
    } else {
      fullNameWithExamples = scenario?.name || "";
    }
    this.currentTestId = uuid;
    if (eventType === "TestRunStarted") {
      InsightsHandler.currentTest.name = fullNameWithExamples;
    }
    const testData = {
      uuid,
      started_at: startedAt,
      finished_at: finishedAt,
      type: "test",
      body: {
        lang: "webdriverio",
        code: null
      },
      name: fullNameWithExamples,
      scope: fullNameWithExamples,
      scopes: [feature?.name || ""],
      identifier: scenario?.name,
      file_name: feature && feature.path ? path15.relative(process.cwd(), feature.path) : void 0,
      location: feature && feature.path ? path15.relative(process.cwd(), feature.path) : void 0,
      vc_filepath: this._gitConfigPath && feature?.path ? path15.relative(this._gitConfigPath, feature?.path) : void 0,
      framework: this._framework,
      result: "pending",
      meta: {
        feature,
        scenario,
        steps,
        examples
      }
    };
    if (eventType === "TestRunStarted" || eventType === "TestRunSkipped") {
      testData.integrations = {};
      if (this._browser && this._platformMeta) {
        const provider = getCloudProvider(this._browser);
        testData.integrations[provider] = this.getIntegrationsObject();
      }
    }
    if (world?.result) {
      let result = world.result.status.toLowerCase();
      if (result !== "passed" && result !== "failed") {
        result = "skipped";
      }
      const ignoreHooksStatus = this._options?.testObservabilityOptions?.ignoreHooksStatus === true;
      if (ignoreHooksStatus && result === "failed" && world) {
        const hasTestStepFailures = this.hasTestStepFailures(world);
        if (!hasTestStepFailures) {
          result = "passed";
        }
      }
      testData.finished_at = (/* @__PURE__ */ new Date()).toISOString();
      testData.result = result;
      testData.duration_in_ms = world.result.duration.seconds * 1e3 + world.result.duration.nanos / 1e6;
      if (result === "failed") {
        testData.failure = [
          {
            "backtrace": [world.result.message ? removeAnsiColors(world.result.message) : "unknown"]
          }
        ];
        testData.failure_reason = world.result.message ? removeAnsiColors(world.result.message) : world.result.message;
        if (world.result.message) {
          testData.failure_type = world.result.message.match(/AssertionError/) ? "AssertionError" : "UnhandledError";
        }
      }
    }
    if (world?.pickle) {
      testData.tags = world.pickle.tags.map(({ name }) => name);
    }
    if (eventType === "TestRunSkipped") {
      testData.result = "skipped";
    }
    return testData;
  }
  async flushCBTDataQueue() {
    BStackLogger.debug(`Flushing CBT Data Queue ${this.currentTestId}`);
    if (isUndefined(this.currentTestId)) {
      return;
    }
    this.cbtQueue.forEach((cbtData) => {
      cbtData.uuid = this.currentTestId;
      this.listener.cbtSessionCreated(cbtData);
    });
    this.currentTestId = void 0;
  }
  async sendCBTInfo() {
    const integrationsData = {};
    if (this._browser && this._platformMeta) {
      const provider = getCloudProvider(this._browser);
      integrationsData[provider] = this.getIntegrationsObject();
    }
    const cbtData = {
      uuid: "",
      integrations: integrationsData
    };
    BStackLogger.debug(`Sending CBT Data ${this.currentTestId} ${JSON.stringify(cbtData)}`);
    if (this.currentTestId !== void 0) {
      cbtData.uuid = this.currentTestId;
      this.listener.cbtSessionCreated(cbtData);
    } else {
      this.cbtQueue.push(cbtData);
    }
  }
  getIntegrationsObject() {
    const caps = this._browser?.capabilities;
    const sessionId = this._browser?.sessionId;
    BStackLogger.debug(`Driver capabilities used for integration object: ${JSON.stringify(caps)}`);
    BStackLogger.debug(`User capabilities used for integration object: ${JSON.stringify(this._userCaps)}`);
    return {
      capabilities: caps,
      session_id: sessionId,
      browser: caps?.browserName,
      browser_version: caps?.browserVersion,
      platform: caps?.platformName,
      product: this._platformMeta?.product,
      platform_version: getPlatformVersion(caps, this._userCaps)
    };
  }
  getIdentifier(test) {
    if ("pickle" in test) {
      return getUniqueIdentifierForCucumber(test);
    }
    return getUniqueIdentifier(test, this._framework);
  }
  async setGitConfigPath() {
    const gitMeta = await getGitMetaData();
    if (gitMeta) {
      this._gitConfigPath = gitMeta.root;
    }
  }
  setTestData(test, uuid) {
    InsightsHandler.currentTest = {
      test,
      uuid
    };
    if (this._framework !== "mocha") {
      return;
    }
    const fullTitle = getUniqueIdentifier(test, this._framework);
    this._tests[fullTitle] = {
      uuid,
      startedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
var InsightsHandler = o11yClassErrorHandler(_InsightsHandler);
var insights_handler_default = InsightsHandler;

// src/Percy/PercySDK.ts
var tryRequire = async function(pkg, fallback) {
  try {
    return (await import(pkg)).default;
  } catch {
    return fallback;
  }
};
var percySnapshot = await tryRequire("@percy/selenium-webdriver", null);
var percyAppScreenshot = await tryRequire("@percy/appium-app", {});
var snapshotHandler = (...args) => {
  PercyLogger.error("Unsupported driver for percy");
};
if (percySnapshot) {
  snapshotHandler = (browser, snapshotName, options) => {
    if (process.env.PERCY_SNAPSHOT === "true") {
      let { name, uuid } = insights_handler_default.currentTest;
      if (isUndefined(name)) {
        ({ name, uuid } = reporter_default.currentTest);
      }
      options ||= {};
      options = {
        ...options,
        testCase: name || ""
      };
      return percySnapshot(browser, snapshotName, options);
    }
  };
}
var snapshot = snapshotHandler;
var screenshotHelper = (type3, driverOrName, nameOrOptions, options) => {
  let { name, uuid } = insights_handler_default.currentTest;
  if (isUndefined(name)) {
    ({ name, uuid } = reporter_default.currentTest);
  }
  if (!driverOrName || typeof driverOrName === "string") {
    nameOrOptions ||= {};
    if (typeof nameOrOptions === "object") {
      nameOrOptions = {
        ...nameOrOptions,
        testCase: name || ""
      };
    }
  } else {
    options ||= {};
    options = {
      ...options,
      testCase: name || ""
    };
  }
  if (type3 === "app") {
    return percyAppScreenshot(driverOrName, nameOrOptions, options);
  }
  return percySnapshot.percyScreenshot(driverOrName, nameOrOptions, options);
};
var screenshotHandler = async (...args) => {
  PercyLogger.error("Unsupported driver for percy");
};
if (percySnapshot && percySnapshot.percyScreenshot) {
  screenshotHandler = (browser, screenshotName, options) => {
    return screenshotHelper("web", browser, screenshotName, options);
  };
}
var screenshot = screenshotHandler;
var screenshotAppHandler = async (...args) => {
  PercyLogger.error("Unsupported driver for percy");
};
if (percyAppScreenshot) {
  screenshotAppHandler = (driverOrName, nameOrOptions, options) => {
    return screenshotHelper("app", driverOrName, nameOrOptions, options);
  };
}
var screenshotApp = screenshotAppHandler;

// src/Percy/Percy-Handler.ts
var _PercyHandler = class {
  constructor(_percyAutoCaptureMode, _browser, _capabilities, _isAppAutomate, _framework) {
    this._percyAutoCaptureMode = _percyAutoCaptureMode;
    this._browser = _browser;
    this._capabilities = _capabilities;
    this._isAppAutomate = _isAppAutomate;
    this._framework = _framework;
    if (!_percyAutoCaptureMode || !CAPTURE_MODES.includes(_percyAutoCaptureMode)) {
      this._percyAutoCaptureMode = "auto";
    }
  }
  _sessionName;
  _isPercyCleanupProcessingUnderway = false;
  _percyScreenshotCounter = 0;
  _percyDeferredScreenshots = [];
  _percyScreenshotInterval = null;
  _percyCaptureMap;
  _setSessionName(name) {
    this._sessionName = name;
  }
  async teardown() {
    await new Promise((resolve) => {
      setInterval(() => {
        if (this._percyScreenshotCounter === 0) {
          resolve();
        }
      }, 1e3);
    });
  }
  async percyAutoCapture(eventName, sessionName) {
    PerformanceTester.start(PERCY_EVENTS.AUTO_CAPTURE);
    try {
      if (eventName) {
        if (!sessionName) {
          this._percyScreenshotCounter += 1;
        }
        this._percyCaptureMap?.increment(sessionName ? sessionName : this._sessionName, eventName);
        const performanceEventName = this._isAppAutomate ? PERCY_EVENTS.SCREENSHOT_APP : PERCY_EVENTS.SCREENSHOT;
        await PerformanceTester.measureWrapper(performanceEventName, async () => {
          await (this._isAppAutomate ? screenshotApp(this._percyCaptureMap?.getName(sessionName ? sessionName : this._sessionName, eventName)) : await screenshot(this._browser, this._percyCaptureMap?.getName(sessionName ? sessionName : this._sessionName, eventName)));
        })();
        this._percyScreenshotCounter -= 1;
      }
    } catch (err) {
      this._percyScreenshotCounter -= 1;
      this._percyCaptureMap?.decrement(sessionName ? sessionName : this._sessionName, eventName);
      PerformanceTester.end(PERCY_EVENTS.AUTO_CAPTURE, false, err, { eventName, sessionName });
      PercyLogger.error(`Error while trying to auto capture Percy screenshot ${err}`);
    }
    PerformanceTester.end(PERCY_EVENTS.AUTO_CAPTURE, true, null, { eventName, sessionName });
  }
  async before() {
    this._percyCaptureMap = new PercyCaptureMap_default();
  }
  deferCapture(sessionName, eventName) {
    this._percyScreenshotCounter += 1;
    this._percyDeferredScreenshots.push({ sessionName, eventName });
  }
  isDOMChangingCommand(args) {
    return typeof args.method === "string" && typeof args.endpoint === "string" && (args.method === "POST" && (PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS.includes(args.endpoint) || /* click / clear element */
    args.endpoint.includes("/session/:sessionId/element") && (args.endpoint.includes("click") || args.endpoint.includes("clear")) || /* execute script sync / async */
    Boolean(args.endpoint.includes("/session/:sessionId/execute") && args.body.script) || /* Touch action for Appium */
    args.endpoint.includes("/session/:sessionId/touch")) || args.method === "DELETE" && args.endpoint === "/session/:sessionId");
  }
  async cleanupDeferredScreenshots() {
    this._isPercyCleanupProcessingUnderway = true;
    for (const entry of this._percyDeferredScreenshots) {
      await this.percyAutoCapture(entry.eventName, entry.sessionName);
    }
    this._percyDeferredScreenshots = [];
    this._isPercyCleanupProcessingUnderway = false;
  }
  async browserBeforeCommand(args) {
    try {
      if (!this.isDOMChangingCommand(args)) {
        return;
      }
      do {
        await sleep(1e3);
      } while (this._percyScreenshotInterval);
      this._percyScreenshotInterval = setInterval(async () => {
        if (!this._isPercyCleanupProcessingUnderway) {
          if (this._percyScreenshotInterval) {
            clearInterval(this._percyScreenshotInterval);
          }
          await this.cleanupDeferredScreenshots();
          this._percyScreenshotInterval = null;
        }
      }, 1e3);
    } catch (err) {
      PercyLogger.error(`Error while trying to cleanup deferred screenshots ${err}`);
    }
  }
  async browserAfterCommand(args) {
    try {
      if (!args.endpoint || !this._percyAutoCaptureMode) {
        return;
      }
      let eventName = null;
      const endpoint = args.endpoint;
      if (endpoint.includes("click") && ["click", "auto"].includes(this._percyAutoCaptureMode)) {
        eventName = "click";
      } else if (endpoint.includes("screenshot") && ["screenshot", "auto"].includes(this._percyAutoCaptureMode)) {
        eventName = "screenshot";
      } else if (endpoint.includes("actions") && ["auto"].includes(this._percyAutoCaptureMode)) {
        const actionsBody = args.body.actions;
        if (actionsBody && Array.isArray(actionsBody) && actionsBody.length && actionsBody[0].type === "key") {
          eventName = "keys";
        }
      } else if (endpoint.includes("/session/:sessionId/element") && endpoint.includes("value") && ["auto"].includes(this._percyAutoCaptureMode)) {
        eventName = "keys";
      }
      if (eventName) {
        this.deferCapture(this._sessionName, eventName);
      }
    } catch (err) {
      PercyLogger.error(`Error while trying to calculate auto capture parameters ${err}`);
    }
  }
  async afterTest() {
    if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === "testcase") {
      await this.percyAutoCapture("testcase", null);
    }
  }
  async afterScenario() {
    if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === "testcase") {
      await this.percyAutoCapture("testcase", null);
    }
  }
};
var PercyHandler = o11yClassErrorHandler(_PercyHandler);
var Percy_Handler_default = PercyHandler;

// src/cli/modules/percyModule.ts
var PercyModule = class _PercyModule extends BaseModule {
  logger = BStackLogger2;
  browser;
  static MODULE_NAME = "PercyModule";
  percyHandler;
  percyConfig;
  isAppAutomate;
  /**
   * Create a new PercyModule
   */
  constructor(percyConfig) {
    super();
    this.percyConfig = percyConfig;
    this.isAppAutomate = false;
    this.logger.info("PercyModule: Initializing Percy Module");
    AutomationFramework.registerObserver(AutomationFrameworkState.CREATE, HookState.POST, this.onAfterCreate.bind(this));
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.PRE, this.onBeforeTest.bind(this));
    TestFramework.registerObserver(TestFrameworkState.TEST, HookState.POST, this.onAfterTest.bind(this));
  }
  getModuleName() {
    return _PercyModule.MODULE_NAME;
  }
  async onAfterCreate(args) {
    this.browser = args.browser;
    if (!this.browser) {
      this.logger.error("PercyModule: Browser instance is not defined in onAfterCreate");
      return;
    }
    if (!this.percyConfig || !this.percyConfig.percyCaptureMode) {
      this.logger.warn("PercyModule: Percy capture mode is not defined in the configuration, skipping Percy initialization");
      return;
    }
    this.isAppAutomate = this.isAppAutomate || "app" in this.config;
    this.percyHandler = new Percy_Handler_default(
      this.percyConfig.percyCaptureMode,
      this.browser,
      {},
      this.isAppAutomate,
      ""
    );
    await this.percyHandler.before();
    const sessionId = this.browser.sessionId;
    this.browser.on("command", async (command) => {
      await this.percyHandler?.browserBeforeCommand(
        Object.assign(command, { sessionId })
      );
    });
    this.browser.on("result", (result) => {
      this.percyHandler?.browserAfterCommand(
        Object.assign(result, { sessionId })
      );
    });
  }
  async onBeforeTest(args) {
    const instace = args.instance;
    const sessionName = TestFramework.getState(instace, TestFrameworkConstants.KEY_AUTOMATE_SESSION_NAME);
    if (!this.percyHandler) {
      this.logger.warn("PercyModule: Percy handler is not initialized, skipping pre execute actions");
      return;
    }
    this.percyHandler._setSessionName(sessionName);
  }
  async onAfterTest() {
    try {
      if (!this.percyHandler) {
        this.logger.warn("PercyModule: Percy handler is not initialized, skipping post execute actions");
        return;
      }
      if (this.percyConfig.percyCaptureMode === "testcase") {
        await this.percyHandler.percyAutoCapture("testcase", null);
      }
      await this.percyHandler.teardown();
    } catch (error) {
      this.logger.error(`Percy post execute failed: ${error}`);
    }
  }
};

// src/cli/index.ts
var BrowserstackCLI = class _BrowserstackCLI {
  static #instance = null;
  static enabled = false;
  initialized;
  config;
  wdioConfig;
  cliArgs;
  browserstackConfig;
  process = null;
  isMainConnected = false;
  isChildConnected = false;
  binSessionId = null;
  modules = {};
  testFramework = null;
  cliParams = null;
  automationFramework = null;
  SDK_CLI_BIN_PATH = null;
  logger = BStackLogger2;
  options;
  constructor() {
    this.initialized = false;
    this.config = {};
    this.cliArgs = {};
    this.browserstackConfig = {};
    this.wdioConfig = "";
    this.options = {};
  }
  /**
   * Get the singleton instance of BrowserstackCLI
   * @returns {BrowserstackCLI} The singleton instance
   */
  static getInstance() {
    if (!_BrowserstackCLI.#instance) {
      _BrowserstackCLI.#instance = new _BrowserstackCLI();
    }
    return _BrowserstackCLI.#instance;
  }
  /**
   * Bootstrap the CLI
   * Initializes and starts the CLI based on environment settings
   * @returns {Promise<void>}
   */
  async bootstrap(options, config, wdioConfig = "") {
    PerformanceTester.start(EVENTS.SDK_CLI_ON_BOOTSTRAP);
    _BrowserstackCLI.enabled = true;
    this.options = options;
    if (config) {
      _BrowserstackCLI.getInstance().setBrowserstackConfig(config);
    }
    try {
      const binSessionId = process.env.BROWSERSTACK_CLI_BIN_SESSION_ID || null;
      if (binSessionId) {
        await this.startChild(binSessionId);
        PerformanceTester.end(EVENTS.SDK_CLI_ON_BOOTSTRAP);
        return;
      }
      this.wdioConfig = wdioConfig;
      await this.startMain();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.stack || error.message : String(error);
      this.logger.error(`bootstrap: failed to bootstrap ${errorMessage}`);
      await this.stop();
      PerformanceTester.end(EVENTS.SDK_CLI_ON_BOOTSTRAP, false, util10.format(error));
    }
  }
  /**
   * Start as a main process
   * @returns {Promise<void>}
   */
  async startMain() {
    this.logger.info("startMain: Starting main process");
    await this.start();
    this.logger.debug("startMain: main-process started");
    const response = await GrpcClient.getInstance().startBinSession(this.wdioConfig);
    BStackLogger2.debug(`start: startBinSession response=${JSON.stringify(response)}`);
    this.loadModules(response);
    this.isMainConnected = true;
  }
  /**
   * Load modules
   * @param {Object} startBinResponse - StartBinSession response
   */
  loadModules(startBinResponse) {
    this.binSessionId = startBinResponse.binSessionId;
    this.logger.info(`loadModules: binSessionId=${this.binSessionId}`);
    this.setConfig(startBinResponse);
    APIUtils.updateURLSForGRR(this.config.apis);
    this.setupTestFramework();
    this.setupAutomationFramework();
    this.modules[WebdriverIOModule.MODULE_NAME] = new WebdriverIOModule();
    this.modules[AutomateModule.MODULE_NAME] = new AutomateModule(this.browserstackConfig);
    if (startBinResponse.testhub) {
      process.env[TESTOPS_BUILD_COMPLETED_ENV] = "true";
      if (startBinResponse.testhub.jwt) {
        process.env[BROWSERSTACK_TESTHUB_JWT] = startBinResponse.testhub.jwt;
      }
      if (startBinResponse.testhub.buildHashedId) {
        process.env[BROWSERSTACK_TESTHUB_UUID] = startBinResponse.testhub.buildHashedId;
        testOpsConfig_default.getInstance().buildHashedId = startBinResponse.testhub.buildHashedId;
      }
      if (startBinResponse.observability?.success) {
        process.env[BROWSERSTACK_OBSERVABILITY] = "true";
        if (startBinResponse.observability.options?.allowScreenshots) {
          process.env[TESTOPS_SCREENSHOT_ENV] = startBinResponse.observability.options.allowScreenshots.toString();
        }
        this.modules[ObservabilityModule.MODULE_NAME] = new ObservabilityModule(startBinResponse.observability);
      }
      this.modules[TestHubModule.MODULE_NAME] = new TestHubModule(startBinResponse.testhub);
      if (startBinResponse.accessibility?.success) {
        process.env[BROWSERSTACK_ACCESSIBILITY] = "true";
        const options = this.options;
        const isNonBstackA11y = isTurboScale(options) || !shouldAddServiceVersion(this.browserstackConfig, options.testObservability);
        processAccessibilityResponse(startBinResponse, this.options);
        this.modules[AccessibilityModule.MODULE_NAME] = new AccessibilityModule(startBinResponse.accessibility, isNonBstackA11y);
      }
    }
    if (startBinResponse.percy?.success) {
      this.modules[PercyModule.MODULE_NAME] = new PercyModule(startBinResponse.percy);
    }
    this.configureModules();
  }
  /**
   * Configure modules
   * @returns {Promise<void>}
   */
  async configureModules() {
    this.logger.debug("configureModules: Configuring modules");
    for (const moduleName in this.modules) {
      const module = this.modules[moduleName];
      const platformIndex = process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0;
      this.logger.debug(`configureModules: Configuring module=${moduleName} platformIndex=${platformIndex}`);
      await module.configure(this.binSessionId, platformIndex, GrpcClient.getInstance().client, this.config);
    }
  }
  /**
   * Start the CLI process and return a promise that resolves when it's ready
   * @returns {Promise<void>}
   * @throws {Error} If the process fails to start
   */
  async start() {
    PerformanceTester.start(EVENTS.SDK_CLI_START);
    if (CLIUtils.isDevelopmentEnv()) {
      this.loadCliParams(CLIUtils.getCLIParamsForDevEnv());
      PerformanceTester.end(EVENTS.SDK_CLI_START);
      return Promise.resolve();
    }
    if (this.process && this.process.connected) {
      PerformanceTester.end(EVENTS.SDK_CLI_START);
      return Promise.resolve();
    }
    const SDK_CLI_BIN_PATH = await this.getCliBinPath();
    const cmd = [SDK_CLI_BIN_PATH, "sdk"];
    this.logger.debug(`spawning command='${cmd}'`);
    this.process = spawn3(cmd[0], cmd.slice(1), {
      env: process.env
    });
    if (!this.process.pid) {
      throw new Error("failed to start CLI, no PID found");
    }
    return new Promise((resolve, reject) => {
      const cliOut = {};
      this.process.stdout.on("data", (data) => {
        const lines = data.toString().trim().split("\n");
        for (const line of lines) {
          if (/^(id|listen|port)=.*$/.test(line)) {
            const [key, value] = line.split("=", 2);
            if (value !== void 0) {
              cliOut[key] = value;
            }
          }
          if (line.toLowerCase().includes("ready")) {
            this.loadCliParams(cliOut);
            PerformanceTester.end(EVENTS.SDK_CLI_START);
            resolve();
            return;
          }
        }
      });
      this.process.stderr.on("data", (data) => {
        this.logger.error(`CLI stderr: ${data.toString().trim()}`);
      });
      this.process.on("error", (err) => {
        cliOut.error = `Error in start: ${err.message}`;
        PerformanceTester.end(EVENTS.SDK_CLI_START, false, err);
        reject(new Error(`Failed to start CLI process: ${err.message}`));
      });
      this.process.on("close", (code) => {
        if (code !== 0) {
          reject(new Error(`CLI process exited with code ${code}`));
        }
      });
    });
  }
  /**
   * Stop the CLI
   * @returns {Promise<void>}
   */
  async stop() {
    PerformanceTester.start(EVENTS.SDK_CLI_ON_STOP);
    this.logger.debug("stop: CLI stop triggered");
    try {
      if (this.isMainConnected) {
        const response = await GrpcClient.getInstance().stopBinSession();
        BStackLogger2.debug(`stop: stopBinSession response=${JSON.stringify(response)}`);
      }
      await this.unConfigureModules();
      if (this.process && this.process.pid) {
        this.logger.debug("stop: shutting down CLI");
        this.process.kill();
        await new Promise((resolve) => {
          let exited = false;
          this.process.on("exit", () => {
            this.logger.debug("stop: CLI process exited");
            exited = true;
            PerformanceTester.end(EVENTS.SDK_CLI_ON_STOP);
            resolve();
          });
          setTimeout(() => {
            if (!exited) {
              this.logger.warn("stop: process exit timeout, forcing kill");
              this.process.kill("SIGKILL");
              PerformanceTester.end(EVENTS.SDK_CLI_ON_STOP);
              resolve();
            }
          }, CLI_STOP_TIMEOUT);
        });
      }
    } catch (error) {
      PerformanceTester.end(EVENTS.SDK_CLI_ON_STOP, false, util10.format(error));
      const errorMessage = error instanceof Error ? error.stack || error.message : String(error);
      this.logger.error(`stop: error in stop session exception=${errorMessage}`);
    }
  }
  /**
   * Unconfigure modules
   * @returns {Promise<void>}
   * @private
   */
  async unConfigureModules() {
    this.logger.debug("Unconfiguring modules");
    for (const moduleName in this.modules) {
      const module = this.modules[moduleName];
      const platformIndex = process.env.WDIO_WORKER_ID ? parseInt(process.env.WDIO_WORKER_ID.split("-")[0]) : 0;
      await module.configure(null, platformIndex, GrpcClient.getInstance().client);
    }
  }
  /**
   * Load CLI parameters from the output
   * @param {Object} params - Parameters parsed from CLI output
   * @private
   */
  loadCliParams(params) {
    this.logger.debug(`CLI params loaded: ${JSON.stringify(params)}`);
    this.cliParams = params;
    GrpcClient.getInstance().init(params);
  }
  /**
   * Start as a child process with the specified binSessionId
   * @param {string} binSessionId - session ID to connect to the CLI process
   * @returns {Promise<void>}
   */
  async startChild(binSessionId) {
    PerformanceTester.start(EVENTS.SDK_CONNECT_BIN_SESSION);
    try {
      this.logger.info(`Starting as child process with session ID: ${binSessionId}`);
      GrpcClient.getInstance().connect();
      const response = await GrpcClient.getInstance().connectBinSession();
      this.logger.info(`Connected to bin session: ${JSON.stringify(response)}`);
      this.loadModules(response);
      this.isChildConnected = true;
      PerformanceTester.end(EVENTS.SDK_CONNECT_BIN_SESSION);
    } catch (error) {
      PerformanceTester.end(EVENTS.SDK_CONNECT_BIN_SESSION, false, util10.format(error));
      this.logger.error(`Failed to start as child process: ${util10.format(error)}`);
    }
  }
  /**
   * Check if the CLI is running
   * @returns {boolean} True if the CLI is running
   */
  isRunning() {
    return (
      // is Dev mode
      CLIUtils.isDevelopmentEnv() || // Main process connection check
      this.isMainConnected && this.process !== null && this.process.exitCode === null && GrpcClient.getInstance().getClient() !== null && GrpcClient.getInstance().getChannel().getConnectivityState(false) !== 4 || // Child process connection check
      this.isChildConnected && GrpcClient.getInstance().getChannel() !== null && GrpcClient.getInstance().getChannel().getConnectivityState(false) !== 4
    );
  }
  /**
   * Get the Browserstack configuration
   * @returns {Object} The Browserstack configuration
   */
  getBrowserstackConfig() {
    return this.browserstackConfig;
  }
  /**
   * Set the Browserstack configuration
   * @param {Object}
   * @returns {void}
   */
  setBrowserstackConfig(browserstackConfig) {
    this.browserstackConfig = browserstackConfig;
  }
  /**
   * Get the CLI binary path
   * @returns {string} The CLI binary path
   */
  async getCliBinPath() {
    if (!this.SDK_CLI_BIN_PATH) {
      this.SDK_CLI_BIN_PATH = await CLIUtils.setupCliPath(this.browserstackConfig);
    }
    return this.SDK_CLI_BIN_PATH || "";
  }
  /**
   * Check if the CLI is enabled
   * @returns {boolean} True if the CLI is enabled
   */
  isCliEnabled() {
    return _BrowserstackCLI.enabled;
  }
  /**
   * Get the configuration
   * @returns {Object} The configuration
   */
  getConfig() {
    return this.config;
  }
  /**
  * Set the configuration
  * @param {Object}
  * @returns {void}
  */
  setConfig(response) {
    try {
      this.config = JSON.parse(response.config);
      this.logger.debug(`loadModules: config=${JSON.stringify(this.config)}`);
    } catch (error) {
      this.logger.error(`setConfig: error=${util10.format(error)}`);
    }
  }
  /**
   * Setup the test framework
   * @returns {void}
   */
  setupTestFramework() {
    const testFrameworkDetail = CLIUtils.getTestFrameworkDetail();
    if (testFrameworkDetail.name.toLowerCase() === "webdriverio-mocha") {
      this.testFramework = new WdioMochaTestFramework([testFrameworkDetail.name], testFrameworkDetail.version, this.binSessionId);
    }
  }
  /**
   * Setup the automation framework
   * @returns {void}
   */
  setupAutomationFramework() {
    const automationFrameworkDetail = CLIUtils.getAutomationFrameworkDetail();
    if (automationFrameworkDetail.name.toLowerCase() === "webdriverio") {
      this.automationFramework = new WdioAutomationFramework(automationFrameworkDetail.name, automationFrameworkDetail.version);
    }
  }
  /**
   * Get the test framework
   * @returns {Object} The test framework
   */
  getTestFramework() {
    return this.testFramework;
  }
  /**
   * Get the automation framework
   * @returns {Object} The automation framework
   */
  getAutomationFramework() {
    return this.automationFramework;
  }
};

// src/exitHandler.ts
var __filename = fileURLToPath2(import.meta.url);
var __dirname = path16.dirname(__filename);
function setupExitHandlers() {
  const handleCLICleanup = () => {
    BStackLogger.debug("Handling CLI cleanup in exit handler");
    try {
      const cliProcess = BrowserstackCLI.getInstance()?.process;
      if (cliProcess && cliProcess.pid && cliProcess.exitCode === null) {
        BStackLogger.debug(`Found CLI process with PID ${cliProcess.pid}, terminating`);
        try {
          if (process.platform === "win32") {
            cliProcess.kill("SIGTERM");
            BStackLogger.debug("CLI process terminated successfully with SIGTERM (Windows)");
          } else {
            cliProcess.kill("SIGKILL");
            BStackLogger.debug("CLI process terminated successfully with SIGKILL (Unix)");
          }
        } catch (processError2) {
          BStackLogger.debug(`CLI process termination error: ${processError2}`);
          try {
            cliProcess.kill();
            BStackLogger.debug("CLI process terminated with default signal (fallback)");
          } catch (fallbackError) {
            BStackLogger.debug(`CLI process fallback termination error: ${fallbackError}`);
          }
        }
      } else {
        BStackLogger.debug("No CLI process found to terminate");
      }
    } catch (error) {
      BStackLogger.debug(`Error in CLI cleanup: ${error}`);
    }
  };
  process.on("exit", () => {
    handleCLICleanup();
    const args = shouldCallCleanup(config_default.getInstance());
    if (Array.isArray(args) && args.length) {
      BStackLogger.debug(`Spawning cleanup.js with args: ${args.join(", ")}`);
      const childProcess = spawn4("node", [`${path16.join(__dirname, "cleanup.js")}`, ...args], { detached: true, stdio: "inherit", env: { ...process.env } });
      childProcess.unref();
    }
  });
}
function shouldCallCleanup(config) {
  const args = [];
  if (!!process.env[BROWSERSTACK_TESTHUB_JWT] && !config.testObservability.buildStopped) {
    args.push("--observability");
  }
  if (config.userName && config.accessKey && !config.funnelDataSent) {
    const savedFilePath = saveFunnelData("SDKTestSuccessful", config);
    args.push("--funnelData", savedFilePath);
  }
  if (PerformanceTester.isEnabled()) {
    process.env.PERF_USER_NAME = config.userName;
    process.env.PERF_TESTHUB_UUID = testOpsConfig_default.getInstance().buildHashedId;
    process.env.SDK_RUN_ID = config.sdkRunID;
    args.push("--performanceData");
  }
  return args;
}

// src/ai-handler.ts
import path17 from "node:path";
import fs12 from "node:fs";
import url2 from "node:url";
import aiSDK from "@browserstack/ai-sdk-node";
var AiHandler = class {
  authResult;
  wdioBstackVersion;
  constructor() {
    this.authResult = JSON.parse(process.env[BSTACK_TCG_AUTH_RESULT] || "{}");
    this.wdioBstackVersion = BSTACK_SERVICE_VERSION;
  }
  async authenticateUser(user, key) {
    return await aiSDK.BrowserstackHealing.init(key, user, TCG_URL, this.wdioBstackVersion);
  }
  updateCaps(authResult, options, caps) {
    const installExtCondition = authResult.isAuthenticated === true && (authResult.defaultLogDataEnabled === true || options.selfHeal === true);
    if (installExtCondition) {
      if (Array.isArray(caps)) {
        const newCaps = aiSDK.BrowserstackHealing.initializeCapabilities(caps[0]);
        caps[0] = newCaps;
      } else if (typeof caps === "object") {
        caps = aiSDK.BrowserstackHealing.initializeCapabilities(caps);
      }
    } else if (options.selfHeal === true) {
      const healingWarnMessage = authResult.message;
      BStackLogger.warn(`Healing Auth failed. Disabling healing for this session. Reason: ${healingWarnMessage}`);
    }
    return caps;
  }
  async setToken(sessionId, sessionToken) {
    await aiSDK.BrowserstackHealing.setToken(sessionId, sessionToken, TCG_URL);
  }
  async installFirefoxExtension(browser) {
    const __dirname2 = url2.fileURLToPath(new URL(".", import.meta.url));
    const extensionPath = path17.resolve(__dirname2, aiSDK.BrowserstackHealing.getFirefoxAddonPath());
    const extFile = fs12.readFileSync(extensionPath);
    await browser.installAddOn(extFile.toString("base64"), true);
  }
  async handleHealing(orginalFunc, using, value, browser, options) {
    const sessionId = browser.sessionId;
    const escapeString = (str) => str.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
    const tcgDetails = escapeString(JSON.stringify({
      region: TCG_INFO.tcgRegion,
      tcgUrls: {
        [TCG_INFO.tcgRegion]: {
          endpoint: TCG_INFO.tcgUrl.split("://")[1]
        }
      }
    }));
    const locatorType = escapeString(using);
    const locatorValue = escapeString(value);
    this.authResult = this.authResult;
    try {
      const result = await orginalFunc(using, value);
      if (!result.error) {
        const script = await aiSDK.BrowserstackHealing.logData(locatorType, locatorValue, void 0, void 0, this.authResult.groupId, sessionId, void 0, tcgDetails);
        if (script) {
          await browser.execute(script);
        }
        return result;
      }
      if (options.selfHeal === true && this.authResult.isHealingEnabled) {
        BStackLogger.info("findElement failed, trying to heal");
        const script = await aiSDK.BrowserstackHealing.healFailure(locatorType, locatorValue, void 0, void 0, this.authResult.userId, this.authResult.groupId, sessionId, void 0, void 0, this.authResult.isGroupAIEnabled, tcgDetails);
        if (script) {
          await browser.execute(script);
          const tcgData = await aiSDK.BrowserstackHealing.pollResult(TCG_URL, sessionId, this.authResult.sessionToken);
          if (tcgData && tcgData.selector && tcgData.value) {
            const healedResult = await orginalFunc(tcgData.selector, tcgData.value);
            BStackLogger.info("Healing worked, element found: " + tcgData.selector + ": " + tcgData.value);
            return healedResult.error ? result : healedResult;
          }
        }
      }
    } catch (err) {
      if (options.selfHeal === true) {
        BStackLogger.warn("Something went wrong while healing. Disabling healing for this command");
      } else {
        BStackLogger.warn("Error in findElement: " + err + "using: " + using + "value: " + value);
      }
    }
    return await orginalFunc(using, value);
  }
  addMultiRemoteCaps(authResult, config, browserStackConfig, options, caps, browser) {
    if (caps[browser].capabilities && !isBrowserstackInfra(caps[browser]) && SUPPORTED_BROWSERS_FOR_AI.includes(caps[browser]?.capabilities?.browserName?.toLowerCase() || "unknown browser")) {
      const innerConfig = getBrowserStackUserAndKey(config, options);
      if (innerConfig?.user && innerConfig.key) {
        handleHealingInstrumentation(authResult, browserStackConfig, options.selfHeal);
        caps[browser].capabilities = this.updateCaps(authResult, options, caps[browser].capabilities);
      }
    }
  }
  handleMultiRemoteSetup(authResult, config, browserStackConfig, options, caps) {
    const browserNames = Object.keys(caps);
    for (let i = 0; i < browserNames.length; i++) {
      const browser = browserNames[i];
      this.addMultiRemoteCaps(authResult, config, browserStackConfig, options, caps, browser);
    }
  }
  async setup(config, browserStackConfig, options, caps, isMultiremote) {
    try {
      const innerConfig = getBrowserStackUserAndKey(config, options);
      if (innerConfig?.user && innerConfig.key) {
        const authResult = await this.authenticateUser(innerConfig.user, innerConfig.key);
        process.env[BSTACK_TCG_AUTH_RESULT] = JSON.stringify(authResult);
        if (!isMultiremote && SUPPORTED_BROWSERS_FOR_AI.includes(caps.browserName?.toLowerCase() || "unknown browser")) {
          handleHealingInstrumentation(authResult, browserStackConfig, options.selfHeal);
          this.updateCaps(authResult, options, caps);
        } else if (isMultiremote) {
          this.handleMultiRemoteSetup(authResult, config, browserStackConfig, options, caps);
        }
      }
    } catch (err) {
      if (options.selfHeal === true) {
        BStackLogger.warn(`Error while initiliazing Browserstack healing Extension ${err}`);
      }
    }
    return caps;
  }
  async handleSelfHeal(options, browser) {
    if (SUPPORTED_BROWSERS_FOR_AI.includes(browser.capabilities?.browserName?.toLowerCase())) {
      const authInfo = this.authResult;
      if (Object.keys(authInfo).length === 0 && options.selfHeal === true) {
        BStackLogger.debug("TCG Auth result is empty");
        return;
      }
      const { isAuthenticated, sessionToken, defaultLogDataEnabled } = authInfo;
      if (isAuthenticated && (defaultLogDataEnabled === true || options.selfHeal === true)) {
        await this.setToken(browser.sessionId, sessionToken);
        if (browser.capabilities.browserName === "firefox") {
          await this.installFirefoxExtension(browser);
        }
        browser.overwriteCommand("findElement", async (orginalFunc, using, value) => {
          return await this.handleHealing(orginalFunc, using, value, browser, options);
        });
      }
    }
  }
  async selfHeal(options, caps, browser) {
    try {
      const multiRemoteBrowsers = Object.keys(caps).filter((e) => Object.keys(browser).includes(e));
      if (multiRemoteBrowsers.length > 0) {
        for (let i = 0; i < multiRemoteBrowsers.length; i++) {
          const remoteBrowser = browser[multiRemoteBrowsers[i]];
          await this.handleSelfHeal(options, remoteBrowser);
        }
      } else {
        await this.handleSelfHeal(options, browser);
      }
    } catch (err) {
      if (options.selfHeal === true) {
        BStackLogger.warn(`Error while setting up self-healing: ${err}. Disabling healing for this session.`);
      }
    }
  }
};
var ai_handler_default = new AiHandler();

// src/launcher.ts
var BrowserstackLauncherService = class {
  constructor(_options, capabilities, _config) {
    this._options = _options;
    this._config = _config;
    BStackLogger.clearLogFile();
    PercyLogger.clearLogFile();
    setupExitHandlers();
    if (!this._config) {
      this._config = _options;
    }
    if (!isUndefined(_options.testReporting)) {
      _options.testObservability = _options.testReporting;
    }
    if (!isUndefined(_options.testReportingOptions)) {
      _options.testObservabilityOptions = _options.testReportingOptions;
    }
    if (!isUndefined(process.env[BROWSERSTACK_TEST_REPORTING])) {
      process.env[BROWSERSTACK_OBSERVABILITY] = process.env[BROWSERSTACK_TEST_REPORTING];
    }
    if (!isUndefined(process.env[TEST_REPORTING_PROJECT_NAME])) {
      process.env.TEST_OBSERVABILITY_PROJECT_NAME = process.env[TEST_REPORTING_PROJECT_NAME];
    }
    if (!isUndefined(process.env.TEST_REPORTING_BUILD_NAME)) {
      process.env.TEST_OBSERVABILITY_BUILD_NAME = process.env.TEST_REPORTING_BUILD_NAME;
    }
    if (!isUndefined(process.env.TEST_REPORTING_BUILD_TAG)) {
      process.env.TEST_OBSERVABILITY_BUILD_TAG = process.env.TEST_REPORTING_BUILD_TAG;
    }
    this.browserStackConfig = config_default.getInstance(_options, _config);
    BStackLogger.debug(`_options data: ${JSON.stringify(_options)}`);
    BStackLogger.debug(`webdriver capabilities data: ${JSON.stringify(capabilities)}`);
    BStackLogger.debug(`_config data: ${JSON.stringify(_config)}`);
    if (Array.isArray(capabilities)) {
      capabilities.flatMap((c) => {
        if ("alwaysMatch" in c) {
          return c.alwaysMatch;
        }
        if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
          return Object.values(c).map((o) => o.capabilities);
        }
        return c;
      }).forEach((capability) => {
        if (!capability["bstack:options"]) {
          if (isBStackSession(this._config)) {
            const extensionCaps = Object.keys(capability).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              capability["bstack:options"] = { wdioService: BSTACK_SERVICE_VERSION };
              if (!isUndefined(capability["browserstack.accessibility"])) {
                this._accessibilityAutomation ||= isTrue(capability["browserstack.accessibility"]);
              } else if (isTrue(this._options.accessibility)) {
                capability["bstack:options"].accessibility = true;
              }
            } else if (shouldAddServiceVersion(this._config, this._options.testObservability)) {
              capability["browserstack.wdioService"] = BSTACK_SERVICE_VERSION;
            }
          }
          this._buildIdentifier = capability["browserstack.buildIdentifier"]?.toString();
          this._buildName = capability.build?.toString();
        } else {
          capability["bstack:options"].wdioService = BSTACK_SERVICE_VERSION;
          this._buildName = capability["bstack:options"].buildName;
          this._projectName = capability["bstack:options"].projectName;
          this._buildTag = capability["bstack:options"].buildTag;
          this._buildIdentifier = capability["bstack:options"].buildIdentifier;
          if (!isUndefined(capability["bstack:options"].accessibility)) {
            this._accessibilityAutomation ||= isTrue(capability["bstack:options"].accessibility);
          } else if (isTrue(this._options.accessibility)) {
            capability["bstack:options"].accessibility = isTrue(this._options.accessibility);
          }
        }
      });
    } else if (typeof capabilities === "object") {
      Object.entries(capabilities).forEach(([, caps]) => {
        if (!caps.capabilities["bstack:options"]) {
          if (isBStackSession(this._config)) {
            const extensionCaps = Object.keys(caps.capabilities).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              caps.capabilities["bstack:options"] = { wdioService: BSTACK_SERVICE_VERSION };
              if (!isUndefined(caps.capabilities["browserstack.accessibility"])) {
                this._accessibilityAutomation ||= isTrue(caps.capabilities["browserstack.accessibility"]);
              } else if (isTrue(this._options.accessibility)) {
                caps.capabilities["bstack:options"] = { wdioService: BSTACK_SERVICE_VERSION, accessibility: isTrue(this._options.accessibility) };
              }
            } else if (shouldAddServiceVersion(this._config, this._options.testObservability)) {
              caps.capabilities["browserstack.wdioService"] = BSTACK_SERVICE_VERSION;
            }
          }
          this._buildIdentifier = caps.capabilities["browserstack.buildIdentifier"];
        } else {
          const bstackOptions = caps.capabilities["bstack:options"];
          bstackOptions.wdioService = BSTACK_SERVICE_VERSION;
          this._buildName = bstackOptions.buildName;
          this._projectName = bstackOptions.projectName;
          this._buildTag = bstackOptions.buildTag;
          this._buildIdentifier = bstackOptions.buildIdentifier;
          if (!isUndefined(bstackOptions.accessibility)) {
            this._accessibilityAutomation ||= isTrue(bstackOptions.accessibility);
          } else if (isTrue(this._options.accessibility)) {
            bstackOptions.accessibility = isTrue(this._options.accessibility);
          }
        }
      });
    }
    this.browserStackConfig.buildIdentifier = this._buildIdentifier;
    this.browserStackConfig.buildName = this._buildName;
    PerformanceTester.startMonitoring("performance-report-launcher.csv");
    if (!isUndefined(this._options.accessibility)) {
      this._accessibilityAutomation ||= isTrue(this._options.accessibility);
    }
    this._options.accessibility = this._accessibilityAutomation;
    this._options.testObservability = this._options.testObservability !== false;
    if (this._options.testObservability && // update files to run if it's a rerun
    process.env[RERUN_ENV] && process.env[RERUN_TESTS_ENV]) {
      this._config.specs = process.env[RERUN_TESTS_ENV].split(",");
    }
    try {
      CrashReporter.setConfigDetails(this._config, capabilities, this._options);
    } catch (error) {
      BStackLogger.error(`[Crash_Report_Upload] Config processing failed due to ${error}`);
    }
  }
  browserstackLocal;
  _buildName;
  _projectName;
  _buildTag;
  _buildIdentifier;
  _accessibilityAutomation = null;
  _percy;
  _percyBestPlatformCaps;
  browserStackConfig;
  async onWorkerStart(cid, caps) {
    try {
      if (this._options.percy && this._percyBestPlatformCaps) {
        const isThisBestPercyPlatform = ObjectsAreEqual(caps, this._percyBestPlatformCaps);
        if (isThisBestPercyPlatform) {
          process.env.BEST_PLATFORM_CID = cid;
        }
      }
    } catch (err) {
      PercyLogger.error(`Error while setting best platform for Percy snapshot at worker start ${err}`);
    }
  }
  async onPrepare(config, capabilities) {
    await sendStart(this.browserStackConfig);
    try {
      if (CLIUtils.checkCLISupportedFrameworks(config.framework)) {
        CLIUtils.setFrameworkDetail(WDIO_NAMING_PREFIX + config.framework, "WebdriverIO");
        const binconfig = CLIUtils.getBinConfig(config, capabilities, this._options, this._buildTag);
        await BrowserstackCLI.getInstance().bootstrap(this._options, config, binconfig);
        BStackLogger.debug(`Is CLI running ${BrowserstackCLI.getInstance().isRunning()}`);
      }
    } catch (err) {
      BStackLogger.error(`Error while starting CLI ${err}`);
    }
    if (!shouldAddServiceVersion(this._config, this._options.testObservability, capabilities)) {
      try {
        if (capabilities.browserName) {
          capabilities = await ai_handler_default.setup(this._config, this.browserStackConfig, this._options, capabilities, false);
        } else if (Array.isArray(capabilities)) {
          for (let i = 0; i < capabilities.length; i++) {
            if (capabilities[i].browserName) {
              capabilities[i] = await ai_handler_default.setup(this._config, this.browserStackConfig, this._options, capabilities[i], false);
            }
          }
        } else if (isValidCapsForHealing(capabilities)) {
          capabilities = await ai_handler_default.setup(this._config, this.browserStackConfig, this._options, capabilities, true);
        }
      } catch (err) {
        if (this._options.selfHeal === true) {
          BStackLogger.warn(`Error while setting up Browserstack healing Extension ${err}. Disabling healing for this session.`);
        }
      }
    }
    if (!BrowserstackCLI.getInstance().isRunning()) {
      if (!this._options.app) {
        BStackLogger.debug("app is not defined in browserstack-service config, skipping ...");
      } else {
        let app = {};
        const appConfig = this._options.app;
        try {
          app = await this._validateApp(appConfig);
        } catch (error) {
          throw new SevereServiceError(error.message);
        }
        if (VALID_APP_EXTENSION.includes(path18.extname(app.app))) {
          if (fs13.existsSync(app.app)) {
            const data = await this._uploadApp(app);
            BStackLogger.info(`app upload completed: ${JSON.stringify(data)}`);
            app.app = data.app_url;
          } else if (app.customId) {
            app.app = app.customId;
          } else {
            throw new SevereServiceError(`[Invalid app path] app path ${app.app} is not correct, Provide correct path to app under test`);
          }
        }
        BStackLogger.info(`Using app: ${app.app}`);
        this._updateCaps(capabilities, "app", app.app);
      }
    }
    if (this._options.buildIdentifier) {
      this._buildIdentifier = this._options.buildIdentifier;
      this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
    }
    this._handleBuildIdentifier(capabilities);
    this._updateObjectTypeCaps(capabilities, "accessibilityOptions");
    const shouldSetupPercy = this._options.percy || isUndefined(this._options.percy) && this._options.app;
    let buildStartResponse = null;
    if (!BrowserstackCLI.getInstance().isRunning() && (this._options.testObservability || this._accessibilityAutomation || shouldSetupPercy)) {
      BStackLogger.debug("Sending launch start event");
      buildStartResponse = await launchTestSession(this._options, this._config, {
        projectName: this._projectName,
        buildName: this._buildName,
        buildTag: this._buildTag,
        bstackServiceVersion: BSTACK_SERVICE_VERSION,
        buildIdentifier: this._buildIdentifier
      }, this.browserStackConfig, this._accessibilityAutomation);
    }
    if (isAccessibilityAutomationSession(this._accessibilityAutomation) && (process.env.BROWSERSTACK_TURBOSCALE || !shouldAddServiceVersion(this._config, this._options.testObservability))) {
      const overrideOptions = accessibility_scripts_default.ChromeExtension;
      this._updateObjectTypeCaps(capabilities, "goog:chromeOptions", overrideOptions);
    }
    if (buildStartResponse?.accessibility) {
      if (this._accessibilityAutomation === null) {
        this.browserStackConfig.accessibility = buildStartResponse.accessibility.success;
        this._accessibilityAutomation = buildStartResponse.accessibility.success;
        this._options.accessibility = buildStartResponse.accessibility.success;
        if (buildStartResponse.accessibility.success === true) {
          this._updateCaps(capabilities, "accessibility", "true");
        }
      }
    }
    this.browserStackConfig.accessibility = this._accessibilityAutomation;
    if (this._accessibilityAutomation && this._options.accessibilityOptions) {
      const filteredOpts = Object.keys(this._options.accessibilityOptions).filter((key) => !NOT_ALLOWED_KEYS_IN_CAPS.includes(key)).reduce((opts2, key) => {
        return {
          ...opts2,
          [key]: this._options.accessibilityOptions?.[key]
        };
      }, {});
      this._updateObjectTypeCaps(capabilities, "accessibilityOptions", filteredOpts);
    } else if (isAccessibilityAutomationSession(this._accessibilityAutomation)) {
      this._updateObjectTypeCaps(capabilities, "accessibilityOptions", {});
    }
    if (shouldSetupPercy) {
      try {
        const bestPlatformPercyCaps = getBestPlatformForPercySnapshot(capabilities);
        this._percyBestPlatformCaps = bestPlatformPercyCaps;
        process.env[BROWSERSTACK_PERCY] = "false";
        await this.setupPercy(this._options, this._config, {
          projectName: this._projectName
        });
        this._updateBrowserStackPercyConfig();
      } catch (err) {
        PercyLogger.error(`Error while setting up Percy ${err}`);
      }
    }
    this._updateCaps(capabilities, "testhubBuildUuid");
    this._updateCaps(capabilities, "buildProductMap");
    if (BrowserstackCLI.getInstance().isRunning()) {
      return;
    }
    if (!this._options.browserstackLocal) {
      return BStackLogger.info("browserstackLocal is not enabled - skipping...");
    }
    const opts = {
      key: this._config.key,
      ...this._options.opts
    };
    this.browserstackLocal = new BrowserstackLocalLauncher.Local();
    this._updateCaps(capabilities, "local");
    if (opts.localIdentifier) {
      this._updateCaps(capabilities, "localIdentifier", opts.localIdentifier);
    }
    const obs = new PerformanceObserver2((list) => {
      const entry = list.getEntries()[0];
      BStackLogger.info(`Browserstack Local successfully started after ${entry.duration}ms`);
    });
    obs.observe({ entryTypes: ["measure"] });
    let timer;
    performance3.mark("tbTunnelStart");
    PerformanceTester.start(AUTOMATE_EVENTS.LOCAL_START);
    return Promise.race(
      [
        promisify4(this.browserstackLocal.start.bind(this.browserstackLocal))(opts),
        new Promise((resolve, reject) => {
          timer = setTimeout(function() {
            reject("Browserstack Local failed to start within 60 seconds!");
          }, 6e4);
        })
      ]
    ).then(function(result) {
      clearTimeout(timer);
      performance3.mark("tbTunnelEnd");
      PerformanceTester.end(AUTOMATE_EVENTS.LOCAL_START);
      performance3.measure("bootTime", "tbTunnelStart", "tbTunnelEnd");
      return Promise.resolve(result);
    }, function(err) {
      PerformanceTester.end(AUTOMATE_EVENTS.LOCAL_START, false, err);
      clearTimeout(timer);
      return Promise.reject(err);
    });
  }
  async onComplete() {
    BStackLogger.debug("Inside OnComplete hook..");
    BStackLogger.debug("Sending stop launch event");
    await (BrowserstackCLI.getInstance().isRunning() ? BrowserstackCLI.getInstance().stop() : stopBuildUpstream());
    if (process.env[BROWSERSTACK_OBSERVABILITY] && process.env[BROWSERSTACK_TESTHUB_UUID]) {
      console.log(`
Visit https://automation.browserstack.com/builds/${process.env[BROWSERSTACK_TESTHUB_UUID]} to view build report, insights, and many more debugging information all at one place!
`);
    }
    this.browserStackConfig.testObservability.buildStopped = true;
    await PerformanceTester.stopAndGenerate("performance-launcher.html");
    if (process.env[PERF_MEASUREMENT_ENV]) {
      PerformanceTester.calculateTimes(["launchTestSession", "stopBuildUpstream"]);
      if (!process.env.START_TIME) {
        return;
      }
      const duration = (/* @__PURE__ */ new Date()).getTime() - new Date(process.env.START_TIME).getTime();
      BStackLogger.info(`Total duration is ${duration / 1e3} s`);
    }
    BStackLogger.info(`BrowserStack service run ended for id: ${this.browserStackConfig?.sdkRunID} testhub id: ${testOpsConfig_default.getInstance()?.buildHashedId}`);
    await sendFinish(this.browserStackConfig);
    try {
      await this._uploadServiceLogs();
    } catch (error) {
      BStackLogger.debug(`Failed to upload BrowserStack WDIO Service logs ${error}`);
    }
    BStackLogger.clearLogger();
    if (this._options.percy) {
      await this.stopPercy();
      PercyLogger.clearLogger();
    }
    if (BrowserstackCLI.getInstance().isRunning()) {
      return;
    }
    if (!this.browserstackLocal || !this.browserstackLocal.isRunning()) {
      return;
    }
    if (this._options.forcedStop) {
      const pid = this.browserstackLocal.pid;
      process.kill(pid);
      return pid;
    }
    let timer;
    PerformanceTester.start(AUTOMATE_EVENTS.LOCAL_STOP);
    return Promise.race(
      [
        new Promise((resolve, reject) => {
          this.browserstackLocal?.stop((err) => {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        }),
        new Promise((resolve, reject) => {
          timer = setTimeout(
            () => reject(new Error("Browserstack Local failed to stop within 60 seconds!")),
            6e4
          );
        })
      ]
    ).then(function(result) {
      PerformanceTester.end(AUTOMATE_EVENTS.LOCAL_STOP);
      clearTimeout(timer);
      return Promise.resolve(result);
    }, function(err) {
      PerformanceTester.end(AUTOMATE_EVENTS.LOCAL_STOP, false, err);
      clearTimeout(timer);
      return Promise.reject(err);
    });
  }
  async setupPercy(options, config, bsConfig) {
    if (this._percy?.isRunning()) {
      process.env[BROWSERSTACK_PERCY] = "true";
      return;
    }
    try {
      this._percy = await startPercy(options, config, bsConfig);
      if (!this._percy || typeof this._percy === "object" && Object.keys(this._percy).length === 0) {
        throw new Error("Could not start percy, check percy logs for info.");
      }
      PercyLogger.info("Percy started successfully");
      process.env[BROWSERSTACK_PERCY] = "true";
      let signal = 0;
      const handler = async () => {
        signal++;
        if (signal === 1) {
          await this.stopPercy();
        }
      };
      process.on("beforeExit", handler);
      process.on("SIGINT", handler);
      process.on("SIGTERM", handler);
    } catch (err) {
      PercyLogger.debug(`Error in percy setup ${format4(err)}`);
      process.env[BROWSERSTACK_PERCY] = "false";
    }
  }
  async stopPercy() {
    if (!this._percy || !this._percy.isRunning()) {
      return;
    }
    try {
      await stopPercy(this._percy);
      PercyLogger.info("Percy stopped");
    } catch (err) {
      PercyLogger.error("Error occured while stopping percy : " + err);
    }
  }
  async _uploadApp(app) {
    BStackLogger.info(`uploading app ${app.app} ${app.customId ? `and custom_id: ${app.customId}` : ""} to browserstack`);
    const form = new FormData();
    if (app.app) {
      const fileName = path18.basename(app.app);
      const fileBuffer = await readFile(app.app);
      const fileBlob = new Blob([new Uint8Array(fileBuffer)]);
      form.append("file", fileBlob, fileName);
    }
    if (app.customId) {
      form.append("custom_id", app.customId);
    }
    const headers = {
      Authorization: getBasicAuthHeader(this._config.user, this._config.key)
    };
    const res = await _fetch("https://api-cloud.browserstack.com/app-automate/upload", {
      method: "POST",
      body: form,
      headers
    });
    if (!res.ok) {
      throw new SevereServiceError(`app upload failed ${res.body}`);
    }
    return await res.json();
  }
  /**
   * @param  {String | AppConfig}  appConfig    <string>: should be "app file path" or "app_url" or "custom_id" or "shareable_id".
   *                                            <object>: only "path" and "custom_id" should coexist as multiple properties.
   */
  async _validateApp(appConfig) {
    const app = {};
    if (typeof appConfig === "string") {
      app.app = appConfig;
    } else if (typeof appConfig === "object" && Object.keys(appConfig).length) {
      if (Object.keys(appConfig).length > 2 || Object.keys(appConfig).length === 2 && (!appConfig.path || !appConfig.custom_id)) {
        throw new SevereServiceError(`keys ${Object.keys(appConfig)} can't co-exist as app values, use any one property from
                            {id<string>, path<string>, custom_id<string>, shareable_id<string>}, only "path" and "custom_id" can co-exist.`);
      }
      app.app = appConfig.id || appConfig.path || appConfig.custom_id || appConfig.shareable_id;
      app.customId = appConfig.custom_id;
    } else {
      throw new SevereServiceError("[Invalid format] app should be string or an object");
    }
    if (!app.app) {
      throw new SevereServiceError(`[Invalid app property] supported properties are {id<string>, path<string>, custom_id<string>, shareable_id<string>}.
                        For more details please visit https://www.browserstack.com/docs/app-automate/appium/set-up-tests/specify-app ')`);
    }
    return app;
  }
  async _uploadServiceLogs() {
    const clientBuildUuid = this._getClientBuildUuid();
    const response = await uploadLogs(getBrowserStackUser(this._config), getBrowserStackKey(this._config), clientBuildUuid);
    if (response) {
      BStackLogger.info(`Upload response: ${JSON.stringify(response, null, 2)}`);
      BStackLogger.logToFile(`Response - ${format4(response)}`, "debug");
    }
  }
  _updateObjectTypeCaps(capabilities, capType, value) {
    try {
      if (Array.isArray(capabilities)) {
        capabilities.flatMap((c) => {
          if ("alwaysMatch" in c) {
            return c.alwaysMatch;
          }
          if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
            return Object.values(c).map((o) => o.capabilities);
          }
          return c;
        }).forEach((capability) => {
          if (validateCapsWithNonBstackA11y(capability.browserName, capability.browserVersion) && capType === "goog:chromeOptions" && value) {
            const chromeOptions = capability["goog:chromeOptions"];
            if (chromeOptions) {
              const finalChromeOptions = mergeChromeOptions(chromeOptions, value);
              capability["goog:chromeOptions"] = finalChromeOptions;
            } else {
              capability["goog:chromeOptions"] = value;
            }
            return;
          }
          if (!capability["bstack:options"]) {
            const extensionCaps = Object.keys(capability).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              if (capType === "accessibilityOptions" && value) {
                capability["bstack:options"] = { accessibilityOptions: value };
              }
            } else if (capType === "accessibilityOptions") {
              if (value) {
                const accessibilityOpts = { ...value };
                if (capability?.accessibility) {
                  accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                  accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
                }
                capability["browserstack.accessibilityOptions"] = accessibilityOpts;
              } else {
                delete capability["browserstack.accessibilityOptions"];
              }
            }
          } else if (capType === "accessibilityOptions") {
            if (value) {
              const accessibilityOpts = { ...value };
              if (capability["bstack:options"].accessibility) {
                accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
              }
              capability["bstack:options"].accessibilityOptions = accessibilityOpts;
            } else {
              delete capability["bstack:options"].accessibilityOptions;
            }
          }
        });
      } else if (typeof capabilities === "object") {
        Object.entries(capabilities).forEach(([, caps]) => {
          if (validateCapsWithNonBstackA11y(
            caps.capabilities.browserName,
            caps.capabilities.browserVersion
          ) && capType === "goog:chromeOptions" && value) {
            const chromeOptions = caps.capabilities["goog:chromeOptions"];
            if (chromeOptions) {
              const finalChromeOptions = mergeChromeOptions(chromeOptions, value);
              caps.capabilities["goog:chromeOptions"] = finalChromeOptions;
            } else {
              caps.capabilities["goog:chromeOptions"] = value;
            }
            return;
          }
          if (!caps.capabilities["bstack:options"]) {
            const extensionCaps = Object.keys(caps.capabilities).filter((cap) => cap.includes(":"));
            if (extensionCaps.length) {
              if (capType === "accessibilityOptions" && value) {
                caps.capabilities["bstack:options"] = { accessibilityOptions: value };
              }
            } else if (capType === "accessibilityOptions") {
              if (value) {
                const accessibilityOpts = { ...value };
                if (caps.capabilities["browserstack.accessibility"]) {
                  accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                  accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
                }
                caps.capabilities["browserstack.accessibilityOptions"] = accessibilityOpts;
              } else {
                delete caps.capabilities["browserstack.accessibilityOptions"];
              }
            }
          } else if (capType === "accessibilityOptions") {
            if (value) {
              const accessibilityOpts = { ...value };
              if (caps.capabilities["bstack:options"].accessibility) {
                accessibilityOpts.authToken = process.env.BSTACK_A11Y_JWT;
                accessibilityOpts.scannerVersion = process.env.BSTACK_A11Y_SCANNER_VERSION;
              }
              caps.capabilities["bstack:options"].accessibilityOptions = accessibilityOpts;
            } else {
              delete caps.capabilities["bstack:options"].accessibilityOptions;
            }
          }
        });
      }
    } catch (error) {
      BStackLogger.debug(`Exception while retrieving capability value. Error - ${error}`);
    }
  }
  _updateCaps(capabilities, capType, value) {
    if (Array.isArray(capabilities)) {
      capabilities.flatMap((c) => {
        if ("alwaysMatch" in c) {
          return c.alwaysMatch;
        }
        if (Object.values(c).length > 0 && Object.values(c).every((c2) => typeof c2 === "object" && c2.capabilities)) {
          return Object.values(c).map((o) => o.capabilities);
        }
        return c;
      }).forEach((capability) => {
        if (!capability["bstack:options"]) {
          const extensionCaps = Object.keys(capability).filter((cap) => cap.includes(":"));
          if (extensionCaps.length) {
            if (capType === "local") {
              capability["bstack:options"] = { local: true };
            } else if (capType === "app") {
              capability["appium:app"] = value;
            } else if (capType === "buildIdentifier" && value) {
              capability["bstack:options"] = { buildIdentifier: value };
            } else if (capType === "testhubBuildUuid") {
              capability["bstack:options"] = { testhubBuildUuid: testOpsConfig_default.getInstance().buildHashedId };
            } else if (capType === "buildProductMap") {
              capability["bstack:options"] = { buildProductMap: getProductMap(this.browserStackConfig) };
            } else if (capType === "accessibility") {
              capability["bstack:options"] = { accessibility: getBooleanValueFromString(value) };
            }
          } else if (capType === "local") {
            capability["browserstack.local"] = true;
          } else if (capType === "app") {
            capability.app = value;
          } else if (capType === "buildIdentifier") {
            if (value) {
              capability["browserstack.buildIdentifier"] = value;
            } else {
              delete capability["browserstack.buildIdentifier"];
            }
          } else if (capType === "localIdentifier") {
            capability["browserstack.localIdentifier"] = value;
          } else if (capType === "testhubBuildUuid") {
            capability["browserstack.testhubBuildUuid"] = testOpsConfig_default.getInstance().buildHashedId;
          } else if (capType === "buildProductMap") {
            capability["browserstack.buildProductMap"] = getProductMap(this.browserStackConfig);
          } else if (capType === "accessibility") {
            capability["browserstack.accessibility"] = getBooleanValueFromString(value);
          }
        } else if (capType === "local") {
          capability["bstack:options"].local = true;
        } else if (capType === "app") {
          capability["appium:app"] = value;
        } else if (capType === "buildIdentifier") {
          if (value) {
            capability["bstack:options"].buildIdentifier = value;
          } else {
            delete capability["bstack:options"].buildIdentifier;
          }
        } else if (capType === "localIdentifier") {
          capability["bstack:options"].localIdentifier = value;
        } else if (capType === "testhubBuildUuid") {
          capability["bstack:options"].testhubBuildUuid = testOpsConfig_default.getInstance().buildHashedId;
        } else if (capType === "buildProductMap") {
          capability["bstack:options"].buildProductMap = getProductMap(this.browserStackConfig);
        } else if (capType === "accessibility") {
          capability["bstack:options"].accessibility = getBooleanValueFromString(value);
        }
      });
    } else if (typeof capabilities === "object") {
      Object.entries(capabilities).forEach(([, caps]) => {
        if (!caps.capabilities["bstack:options"]) {
          const extensionCaps = Object.keys(caps.capabilities).filter((cap) => cap.includes(":"));
          if (extensionCaps.length) {
            if (capType === "local") {
              caps.capabilities["bstack:options"] = { local: true };
            } else if (capType === "app") {
              caps.capabilities["appium:app"] = value;
            } else if (capType === "buildIdentifier" && value) {
              caps.capabilities["bstack:options"] = { buildIdentifier: value };
            } else if (capType === "testhubBuildUuid") {
              caps.capabilities["bstack:options"] = { testhubBuildUuid: testOpsConfig_default.getInstance().buildHashedId };
            } else if (capType === "buildProductMap") {
              caps.capabilities["bstack:options"] = { buildProductMap: getProductMap(this.browserStackConfig) };
            } else if (capType === "accessibility") {
              caps.capabilities["bstack:options"] = { accessibility: getBooleanValueFromString(value) };
            }
          } else if (capType === "local") {
            caps.capabilities["browserstack.local"] = true;
          } else if (capType === "app") {
            caps.capabilities["appium:app"] = value;
          } else if (capType === "buildIdentifier") {
            if (value) {
              caps.capabilities["browserstack.buildIdentifier"] = value;
            } else {
              delete caps.capabilities["browserstack.buildIdentifier"];
            }
          } else if (capType === "localIdentifier") {
            caps.capabilities["browserstack.localIdentifier"] = value;
          } else if (capType === "testhubBuildUuid") {
            caps.capabilities["browserstack.testhubBuildUuid"] = testOpsConfig_default.getInstance().buildHashedId;
          } else if (capType === "buildProductMap") {
            caps.capabilities["browserstack.buildProductMap"] = getProductMap(this.browserStackConfig);
          } else if (capType === "accessibility") {
            caps.capabilities["browserstack.accessibility"] = getBooleanValueFromString(value);
          }
        } else if (capType === "local") {
          caps.capabilities["bstack:options"].local = true;
        } else if (capType === "app") {
          caps.capabilities["appium:app"] = value;
        } else if (capType === "buildIdentifier") {
          if (value) {
            caps.capabilities["bstack:options"].buildIdentifier = value;
          } else {
            delete caps.capabilities["bstack:options"].buildIdentifier;
          }
        } else if (capType === "localIdentifier") {
          caps.capabilities["bstack:options"].localIdentifier = value;
        } else if (capType === "testhubBuildUuid") {
          caps.capabilities["bstack:options"].testhubBuildUuid = testOpsConfig_default.getInstance().buildHashedId;
        } else if (capType === "buildProductMap") {
          caps.capabilities["bstack:options"].buildProductMap = getProductMap(this.browserStackConfig);
        } else if (capType === "accessibility") {
          caps.capabilities["bstack:options"].accessibility = getBooleanValueFromString(value);
        }
      });
    } else {
      throw new SevereServiceError("Capabilities should be an object or Array!");
    }
  }
  _handleBuildIdentifier(capabilities) {
    if (!this._buildIdentifier) {
      return;
    }
    if ((!this._buildName || process.env.BROWSERSTACK_BUILD_NAME) && this._buildIdentifier) {
      this._updateCaps(capabilities, "buildIdentifier");
      BStackLogger.warn("Skipping buildIdentifier as buildName is not passed.");
      return;
    }
    if (this._buildIdentifier && this._buildIdentifier.includes("${DATE_TIME}")) {
      const formattedDate = new Intl.DateTimeFormat("en-GB", {
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
      }).format(/* @__PURE__ */ new Date()).replace(/ |, /g, "-");
      this._buildIdentifier = this._buildIdentifier.replace("${DATE_TIME}", formattedDate);
      this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
    }
    if (!this._buildIdentifier.includes("${BUILD_NUMBER}")) {
      return;
    }
    const ciInfo = getCiInfo();
    if (ciInfo !== null && ciInfo.build_number) {
      this._buildIdentifier = this._buildIdentifier.replace("${BUILD_NUMBER}", "CI " + ciInfo.build_number);
      this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
    } else {
      const localBuildNumber = this._getLocalBuildNumber();
      if (localBuildNumber) {
        this._buildIdentifier = this._buildIdentifier.replace("${BUILD_NUMBER}", localBuildNumber);
        this._updateCaps(capabilities, "buildIdentifier", this._buildIdentifier);
      }
    }
  }
  _updateBrowserStackPercyConfig() {
    const { percyAutoEnabled = false, percyCaptureMode, buildId, percy } = this._percy || {};
    this.browserStackConfig.percyCaptureMode = percyCaptureMode;
    this.browserStackConfig.percyBuildId = buildId;
    this.browserStackConfig.isPercyAutoEnabled = percyAutoEnabled;
    this._options.percy = percy;
    process.env.BROWSERSTACK_PERCY = String(percy);
    process.env.BROWSERSTACK_PERCY_CAPTURE_MODE = percyCaptureMode;
  }
  /**
   * @return {string} if buildName doesn't exist in json file, it will return 1
   *                  else returns corresponding value in json file (e.g. { "wdio-build": { "identifier" : 2 } } => 2 in this case)
   */
  _getLocalBuildNumber() {
    const browserstackFolderPath = path18.join(os5.homedir(), ".browserstack");
    try {
      if (!fs13.existsSync(browserstackFolderPath)) {
        fs13.mkdirSync(browserstackFolderPath);
      }
      const filePath = path18.join(browserstackFolderPath, ".build-name-cache.json");
      if (!fs13.existsSync(filePath)) {
        fs13.appendFileSync(filePath, JSON.stringify({}));
      }
      const buildCacheFileData = fs13.readFileSync(filePath);
      const parsedBuildCacheFileData = JSON.parse(buildCacheFileData.toString());
      if (this._buildName && this._buildName in parsedBuildCacheFileData) {
        const prevIdentifier = parseInt(parsedBuildCacheFileData[this._buildName].identifier);
        const newIdentifier2 = prevIdentifier + 1;
        this._updateLocalBuildCache(filePath, this._buildName, newIdentifier2);
        return newIdentifier2.toString();
      }
      const newIdentifier = 1;
      this._updateLocalBuildCache(filePath, this._buildName, 1);
      return newIdentifier.toString();
    } catch {
      return null;
    }
  }
  _updateLocalBuildCache(filePath, buildName, buildIdentifier) {
    if (!buildName || !filePath) {
      return;
    }
    const jsonContent = JSON.parse(fs13.readFileSync(filePath).toString());
    jsonContent[buildName] = { "identifier": buildIdentifier };
    fs13.writeFileSync(filePath, JSON.stringify(jsonContent));
  }
  _getClientBuildUuid() {
    if (process.env[BROWSERSTACK_TESTHUB_UUID]) {
      return process.env[BROWSERSTACK_TESTHUB_UUID];
    }
    const uuid = this.browserStackConfig?.sdkRunID;
    BStackLogger.logToFile(`If facing any issues, please contact BrowserStack support with the Build Run Id - ${uuid}`, "info");
    return uuid;
  }
};
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_SETUP)
], BrowserstackLauncherService.prototype, "onWorkerStart", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_PRE_TEST)
], BrowserstackLauncherService.prototype, "onPrepare", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_CLEANUP)
], BrowserstackLauncherService.prototype, "onComplete", 1);
__decorateClass([
  PerformanceTester.Measure(APP_AUTOMATE_EVENTS.APP_UPLOAD)
], BrowserstackLauncherService.prototype, "_uploadApp", 1);

// src/accessibility-handler.ts
import util11 from "node:util";
var _AccessibilityHandler = class {
  constructor(_browser, _capabilities, _options, isAppAutomate, _config, _framework, _accessibilityAutomation, _turboscale, _accessibilityOpts) {
    this._browser = _browser;
    this.isAppAutomate = isAppAutomate;
    this._framework = _framework;
    const caps = this._browser.capabilities;
    this._platformA11yMeta = {
      browser_name: caps.browserName,
      // @ts-expect-error invalid caps property
      browser_version: caps?.browserVersion || caps?.version || "latest",
      platform_name: caps?.platformName,
      platform_version: this._getCapabilityValue(caps, "appium:platformVersion", "platformVersion"),
      os_name: this._getCapabilityValue(_capabilities, "os", "os"),
      os_version: this._getCapabilityValue(_capabilities, "osVersion", "os_version")
    };
    this._caps = _capabilities;
    this._accessibility = isTrue(_accessibilityAutomation);
    this._accessibilityOptions = _accessibilityOpts;
    this._autoScanning = !isFalse(this._accessibilityOptions?.autoScanning);
    this._options = _options;
    this._config = _config;
    this._turboscale = isTrue(_turboscale);
  }
  _platformA11yMeta;
  _caps;
  _suiteFile;
  _accessibility;
  _turboscale;
  _options;
  _config;
  _accessibilityOptions;
  _autoScanning = true;
  _testIdentifier = null;
  _testMetadata = {};
  static _a11yScanSessionMap = {};
  _sessionId = null;
  listener = listener_default.getInstance();
  setSuiteFile(filename) {
    this._suiteFile = filename;
  }
  _getCapabilityValue(caps, capType, legacyCapType) {
    if (caps) {
      if (capType === "accessibility") {
        if (caps["bstack:options"] && isTrue(caps["bstack:options"]?.accessibility)) {
          return caps["bstack:options"]?.accessibility;
        } else if (isTrue(caps["browserstack.accessibility"])) {
          return caps["browserstack.accessibility"];
        }
      } else if (capType === "deviceName") {
        if (caps["bstack:options"] && caps["bstack:options"]?.deviceName) {
          return caps["bstack:options"]?.deviceName;
        } else if (caps["bstack:options"] && caps["bstack:options"]?.device) {
          return caps["bstack:options"]?.device;
        } else if (caps["appium:deviceName"]) {
          return caps["appium:deviceName"];
        }
      } else if (capType === "goog:chromeOptions" && caps["goog:chromeOptions"]) {
        return caps["goog:chromeOptions"];
      } else {
        const bstackOptions = caps["bstack:options"];
        if (bstackOptions && bstackOptions?.[capType]) {
          return bstackOptions?.[capType];
        } else if (caps[legacyCapType]) {
          return caps[legacyCapType];
        }
      }
    }
  }
  async before(sessionId) {
    this._sessionId = sessionId;
    this._accessibility = isTrue(this._getCapabilityValue(this._caps, "accessibility", "browserstack.accessibility"));
    if (isAccessibilityAutomationSession(this._accessibility) && (this._turboscale || !shouldAddServiceVersion(this._config, this._options.testObservability)) && validateCapsWithNonBstackA11y(
      this._platformA11yMeta.browser_name,
      this._platformA11yMeta?.browser_version
    )) {
      this._accessibility = true;
    } else {
      if (isAccessibilityAutomationSession(this._accessibility) && !this.isAppAutomate) {
        const deviceName = this._getCapabilityValue(this._caps, "deviceName", "device");
        const chromeOptions = this._getCapabilityValue(this._caps, "goog:chromeOptions", "");
        this._accessibility = validateCapsWithA11y(deviceName, this._platformA11yMeta, chromeOptions);
      }
      if (isAppAccessibilityAutomationSession(this._accessibility, this.isAppAutomate)) {
        this._accessibility = validateCapsWithAppA11y(this._platformA11yMeta);
      }
    }
    const browserWithA11y = this._browser;
    browserWithA11y.getAccessibilityResultsSummary = async () => {
      if (isAppAccessibilityAutomationSession(this._accessibility, this.isAppAutomate)) {
        return await getAppA11yResultsSummary(this.isAppAutomate, this._browser, isBrowserstackSession(this._browser), this._accessibility, this._sessionId);
      }
      return await getA11yResultsSummary(this.isAppAutomate, this._browser, isBrowserstackSession(this._browser), this._accessibility);
    };
    browserWithA11y.getAccessibilityResults = async () => {
      if (isAppAccessibilityAutomationSession(this._accessibility, this.isAppAutomate)) {
        return await getAppA11yResults(this.isAppAutomate, this._browser, isBrowserstackSession(this._browser), this._accessibility, this._sessionId);
      }
      return await getA11yResults(this.isAppAutomate, this._browser, isBrowserstackSession(this._browser), this._accessibility);
    };
    browserWithA11y.performScan = async () => {
      const results = await performA11yScan(this.isAppAutomate, this._browser, isBrowserstackSession(this._browser), this._accessibility);
      if (results) {
        this._testMetadata[this._testIdentifier] = {
          scanTestForAccessibility: true,
          accessibilityScanStarted: true
        };
      }
      await this._setAnnotation("Accessibility scanning was triggered manually");
      return results;
    };
    browserWithA11y.startA11yScanning = async () => {
      if (this._testIdentifier === null) {
        BStackLogger.warn("Accessibility scanning cannot be started from outside the test");
        return;
      }
      AccessibilityHandler._a11yScanSessionMap[sessionId] = true;
      this._testMetadata[this._testIdentifier] = {
        scanTestForAccessibility: true,
        accessibilityScanStarted: true
      };
      await this._setAnnotation("Accessibility scanning has started");
    };
    browserWithA11y.stopA11yScanning = async () => {
      if (this._testIdentifier === null) {
        BStackLogger.warn("Accessibility scanning cannot be stopped from outside the test");
        return;
      }
      AccessibilityHandler._a11yScanSessionMap[sessionId] = false;
      await this._setAnnotation("Accessibility scanning has stopped");
    };
    if (!this._accessibility) {
      return;
    }
    if (!("overwriteCommand" in this._browser && Array.isArray(accessibility_scripts_default.commandsToWrap))) {
      return;
    }
    accessibility_scripts_default.commandsToWrap.filter((command) => command.name && command.class).forEach((command) => {
      const browser = this._browser;
      try {
        const prevImpl = browser[command.name].bind(browser);
        browser.overwriteCommand(command.name, this.commandWrapper.bind(this, command, prevImpl), command.class === "Element");
      } catch (error) {
        BStackLogger.debug(`Exception in overwrite command ${command.name} - ${error}`);
      }
    });
  }
  async beforeTest(suiteTitle, test) {
    try {
      if (this._framework !== "mocha" || !this.shouldRunTestHooks(this._browser, this._accessibility)) {
        listener_default.setTestRunAccessibilityVar(false);
        return;
      }
      const shouldScanTest = this._autoScanning && shouldScanTestForAccessibility(suiteTitle, test.title, this._accessibilityOptions);
      const testIdentifier = this.getIdentifier(test);
      this._testIdentifier = testIdentifier;
      if (this._sessionId) {
        AccessibilityHandler._a11yScanSessionMap[this._sessionId] = shouldScanTest;
      }
      listener_default.setTestRunAccessibilityVar(this._accessibility && shouldScanTest);
      this._testMetadata[testIdentifier] = {
        scanTestForAccessibility: shouldScanTest,
        accessibilityScanStarted: true
      };
      this._testMetadata[testIdentifier].accessibilityScanStarted = shouldScanTest;
      if (shouldScanTest) {
        BStackLogger.info("Automate test case execution has started.");
      }
    } catch (error) {
      BStackLogger.error(`Exception in starting accessibility automation scan for this test case ${error}`);
    }
  }
  async afterTest(suiteTitle, test) {
    BStackLogger.debug("Accessibility after test hook. Before sending test stop event");
    if (this._framework !== "mocha" || !this.shouldRunTestHooks(this._browser, this._accessibility)) {
      return;
    }
    try {
      const testIdentifier = this.getIdentifier(test);
      const accessibilityScanStarted = this._testMetadata[testIdentifier]?.accessibilityScanStarted;
      const shouldScanTestForAccessibility2 = this._testMetadata[testIdentifier]?.scanTestForAccessibility;
      if (!accessibilityScanStarted) {
        return;
      }
      if (shouldScanTestForAccessibility2) {
        BStackLogger.info("Automate test case execution has ended. Processing for accessibility testing is underway. ");
        const dataForExtension = {
          "thTestRunUuid": process.env.TEST_ANALYTICS_ID,
          "thBuildUuid": process.env.BROWSERSTACK_TESTHUB_UUID,
          "thJwtToken": process.env.BROWSERSTACK_TESTHUB_JWT
        };
        await this.sendTestStopEvent(this._browser, dataForExtension);
        BStackLogger.info("Accessibility testing for this test case has ended.");
      }
    } catch (error) {
      BStackLogger.error(`Accessibility results could not be processed for the test case ${test.title}. Error : ${error}`);
    }
  }
  /**
    * Cucumber Only
  */
  async beforeScenario(world) {
    const pickleData = world.pickle;
    const gherkinDocument = world.gherkinDocument;
    const featureData = gherkinDocument.feature;
    const uniqueId = getUniqueIdentifierForCucumber(world);
    this._testIdentifier = uniqueId;
    if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
      listener_default.setTestRunAccessibilityVar(false);
      return;
    }
    try {
      const shouldScanScenario = this._autoScanning && shouldScanTestForAccessibility(featureData?.name, pickleData.name, this._accessibilityOptions, world, true);
      this._testMetadata[uniqueId] = {
        scanTestForAccessibility: shouldScanScenario,
        accessibilityScanStarted: true
      };
      this._testMetadata[uniqueId].accessibilityScanStarted = shouldScanScenario;
      if (this._sessionId) {
        AccessibilityHandler._a11yScanSessionMap[this._sessionId] = shouldScanScenario;
      }
      listener_default.setTestRunAccessibilityVar(this._accessibility && shouldScanScenario);
      if (shouldScanScenario) {
        BStackLogger.info("Automate test case execution has started.");
      }
    } catch (error) {
      BStackLogger.error(`Exception in starting accessibility automation scan for this test case ${error}`);
    }
  }
  async afterScenario(world) {
    BStackLogger.debug("Accessibility after scenario hook. Before sending test stop event");
    if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
      return;
    }
    const pickleData = world.pickle;
    try {
      const uniqueId = getUniqueIdentifierForCucumber(world);
      const accessibilityScanStarted = this._testMetadata[uniqueId]?.accessibilityScanStarted;
      const shouldScanTestForAccessibility2 = this._testMetadata[uniqueId]?.scanTestForAccessibility;
      if (!accessibilityScanStarted) {
        return;
      }
      if (shouldScanTestForAccessibility2) {
        BStackLogger.info("Automate test case execution has ended. Processing for accessibility testing is underway. ");
        const dataForExtension = {
          "thTestRunUuid": process.env.TEST_ANALYTICS_ID,
          "thBuildUuid": process.env.BROWSERSTACK_TESTHUB_UUID,
          "thJwtToken": process.env.BROWSERSTACK_TESTHUB_JWT
        };
        await this.sendTestStopEvent(this._browser, dataForExtension);
        BStackLogger.info("Accessibility testing for this test case has ended.");
      }
    } catch (error) {
      BStackLogger.error(`Accessibility results could not be processed for the test case ${pickleData.name}. Error : ${error}`);
    }
  }
  /*
   * private methods
   */
  async commandWrapper(command, prevImpl, origFunction, ...args) {
    if (this._sessionId && AccessibilityHandler._a11yScanSessionMap[this._sessionId] && (!command.name.includes("execute") || !AccessibilityHandler.shouldPatchExecuteScript(args.length ? args[0] : null))) {
      BStackLogger.debug(`Performing scan for ${command.class} ${command.name}`);
      await performA11yScan(this.isAppAutomate, this._browser, true, true, command.name);
    }
    return prevImpl(...args);
  }
  async sendTestStopEvent(browser, dataForExtension) {
    BStackLogger.debug("Performing scan before saving results");
    if (AccessibilityHandler._a11yScanSessionMap[this._sessionId]) {
      await PerformanceTester.measureWrapper(A11Y_EVENTS.PERFORM_SCAN, async () => {
        await performA11yScan(this.isAppAutomate, browser, true, true);
      }, { command: "afterTest" })();
    }
    if (isAppAccessibilityAutomationSession(this._accessibility, this.isAppAutomate)) {
      return;
    }
    await PerformanceTester.measureWrapper(A11Y_EVENTS.SAVE_RESULTS, async () => {
      if (accessibility_scripts_default.saveTestResults) {
        const results = await executeAccessibilityScript(browser, accessibility_scripts_default.saveTestResults, dataForExtension);
        BStackLogger.debug(util11.format(results));
      } else {
        BStackLogger.error("saveTestResults script is null or undefined");
      }
    })();
  }
  getIdentifier(test) {
    if ("pickle" in test) {
      return getUniqueIdentifierForCucumber(test);
    }
    return getUniqueIdentifier(test, this._framework);
  }
  shouldRunTestHooks(browser, isAccessibility) {
    if (!browser) {
      return false;
    }
    return isAccessibilityAutomationSession(isAccessibility);
  }
  async checkIfPageOpened(browser, testIdentifier, shouldScanTest) {
    let pageOpen = false;
    this._testMetadata[testIdentifier] = {
      scanTestForAccessibility: shouldScanTest,
      accessibilityScanStarted: true
    };
    try {
      const currentURL = await browser.getUrl();
      const url3 = new URL(currentURL);
      pageOpen = url3?.protocol === "http:" || url3?.protocol === "https:";
    } catch {
      pageOpen = false;
    }
    return pageOpen;
  }
  static shouldPatchExecuteScript(script) {
    if (!script || typeof script !== "string") {
      return true;
    }
    return script.toLowerCase().indexOf("browserstack_executor") !== -1 || script.toLowerCase().indexOf("browserstack_accessibility_automation_script") !== -1;
  }
  async _setAnnotation(message) {
    if (this._accessibility && isBrowserstackSession(this._browser)) {
      await this._browser.executeScript(`browserstack_executor: ${JSON.stringify({
        action: "annotate",
        arguments: {
          data: message,
          level: "info"
        }
      })}`, []);
    }
  }
};
var AccessibilityHandler = o11yClassErrorHandler(_AccessibilityHandler);
var accessibility_handler_default = AccessibilityHandler;

// src/service.ts
import util12 from "node:util";
var BrowserstackService = class {
  constructor(options, _caps, _config) {
    this._caps = _caps;
    this._config = _config;
    this._options = { ...DEFAULT_OPTIONS, ...options };
    if (!this._config) {
      this._config = this._options;
    }
    this._observability = this._options.testObservability;
    this._accessibility = this._options.accessibility;
    this._percy = isTrue(process.env.BROWSERSTACK_PERCY);
    this._percyCaptureMode = process.env.BROWSERSTACK_PERCY_CAPTURE_MODE;
    this._turboScale = this._options.turboScale;
    PerformanceTester.startMonitoring("performance-report-service.csv");
    if (shouldProcessEventForTesthub("")) {
      this._config.reporters?.push(reporter_default);
    }
    if (process.env.BROWSERSTACK_TURBOSCALE) {
      this._turboScale = process.env.BROWSERSTACK_TURBOSCALE === "true";
    }
    process.env.BROWSERSTACK_TURBOSCALE_INTERNAL = String(this._turboScale);
    const strict = Boolean(this._config.cucumberOpts && this._config.cucumberOpts.strict);
    if (strict) {
      this._failureStatuses.push("pending");
    }
    if (process.env.WDIO_WORKER_ID === process.env.BEST_PLATFORM_CID) {
      process.env.PERCY_SNAPSHOT = "true";
    }
  }
  _sessionBaseUrl = "https://api.browserstack.com/automate/sessions";
  _failReasons = [];
  _hookFailReasons = [];
  _pureTestFailReasons = [];
  _scenariosThatRan = [];
  _failureStatuses = ["failed", "ambiguous", "undefined", "unknown"];
  _browser;
  _suiteTitle;
  _suiteFile;
  _fullTitle;
  _options;
  _specsRan = false;
  _observability;
  _currentTest;
  _insightsHandler;
  _accessibility;
  _accessibilityHandler;
  _percy;
  _percyCaptureMode = void 0;
  _percyHandler;
  _turboScale;
  _updateCaps(fn) {
    const multiRemoteCap = this._caps;
    if (multiRemoteCap.capabilities) {
      return Object.entries(multiRemoteCap).forEach(([, caps]) => fn(caps.capabilities));
    }
    return fn(this._caps);
  }
  async beforeSession(config, capabilities) {
    const testObservabilityOptions = this._options.testObservabilityOptions;
    if (!config.user && !(testObservabilityOptions && testObservabilityOptions.user)) {
      config.user = "NotSetUser";
    }
    if (!config.key && !(testObservabilityOptions && testObservabilityOptions.key)) {
      config.key = "NotSetKey";
    }
    this._config.user = config.user;
    this._config.key = config.key;
    try {
      if (CLIUtils.checkCLISupportedFrameworks(this._config.framework)) {
        await BrowserstackCLI.getInstance().bootstrap(this._options, this._config);
        const hubUrl = BrowserstackCLI.getInstance().getConfig().hubUrl;
        if (hubUrl) {
          this._config.hostname = new URL(hubUrl).hostname;
        }
      }
      if (BrowserstackCLI.getInstance().isRunning()) {
        await BrowserstackCLI.getInstance().getAutomationFramework().trackEvent(AutomationFrameworkState.CREATE, HookState.PRE, { caps: capabilities });
        const instance = AutomationFramework.getTrackedInstance();
        const caps = AutomationFramework.getState(instance, AutomationFrameworkConstants.KEY_CAPABILITIES);
        Object.assign(capabilities, caps);
      }
    } catch (err) {
      BStackLogger.error(`Error while connecting to Browserstack CLI: ${err}`);
    }
  }
  async before(caps, specs, browser) {
    this._browser = browser ? browser : globalThis.browser;
    PerformanceTester.browser = this._browser;
    if (!isBrowserstackSession(this._browser)) {
      try {
        await ai_handler_default.selfHeal(this._options, caps, this._browser);
      } catch (err) {
        if (this._options.selfHeal === true) {
          BStackLogger.warn(`Error while setting up self-healing: ${err}. Disabling healing for this session.`);
        }
      }
    }
    if (this._isAppAutomate()) {
      this._sessionBaseUrl = "https://api-cloud.browserstack.com/app-automate/sessions";
    }
    if (this._turboScale) {
      this._sessionBaseUrl = "https://api.browserstack.com/automate-turboscale/v1/sessions";
    }
    this._scenariosThatRan = [];
    PerformanceTester.scenarioThatRan = this._scenariosThatRan;
    if (this._browser) {
      try {
        const sessionId = this._browser.sessionId;
        try {
          this._accessibilityHandler = new accessibility_handler_default(
            this._browser,
            this._caps,
            this._options,
            this._isAppAutomate(),
            this._config,
            this._config.framework,
            this._accessibility,
            this._turboScale,
            this._options.accessibilityOptions
          );
          if (isBrowserstackSession(this._browser) && BrowserstackCLI.getInstance().isRunning()) {
            BStackLogger.info(`CLI is running, tracking accessibility event for before: ${sessionId}`);
          } else {
            await this._accessibilityHandler.before(sessionId);
          }
          listener_default.setAccessibilityOptions(this._options.accessibilityOptions);
        } catch (err) {
          BStackLogger.error(`[Accessibility Test Run] Error in service class before function: ${err}`);
        }
        if (shouldProcessEventForTesthub("")) {
          patchConsoleLogs();
          this._insightsHandler = new insights_handler_default(
            this._browser,
            this._config.framework,
            this._caps,
            this._options
          );
          if (BrowserstackCLI.getInstance().isRunning()) {
            BStackLogger.info(`CLI is running, tracking insights event for before: ${sessionId}`);
            await BrowserstackCLI.getInstance().getAutomationFramework().trackEvent(AutomationFrameworkState.CREATE, HookState.POST, { browser: this._browser, hubUrl: this._config.hostname });
            this._insightsHandler.setGitConfigPath();
            return;
          }
          await this._insightsHandler.before();
        }
        if (!BrowserstackCLI.getInstance().isRunning()) {
          this._browser.on("command", async (command) => {
            if (shouldProcessEventForTesthub("")) {
              this._insightsHandler?.browserCommand(
                "client:beforeCommand",
                Object.assign(command, { sessionId }),
                this._currentTest
              );
            }
            await this._percyHandler?.browserBeforeCommand(
              Object.assign(command, { sessionId })
            );
          });
          this._browser.on("result", (result) => {
            if (shouldProcessEventForTesthub("")) {
              this._insightsHandler?.browserCommand(
                "client:afterCommand",
                Object.assign(result, { sessionId }),
                this._currentTest
              );
            }
            this._percyHandler?.browserAfterCommand(
              Object.assign(result, { sessionId })
            );
          });
        }
      } catch (err) {
        BStackLogger.error(`Error in service class before function: ${err}`);
        if (shouldProcessEventForTesthub("")) {
          CrashReporter.uploadCrashReport(`Error in service class before function: ${err}`, err ? err.stack : "unknown error");
        }
      }
      if (this._percy && !BrowserstackCLI.getInstance().isRunning()) {
        this._percyHandler = new Percy_Handler_default(
          this._percyCaptureMode,
          this._browser,
          this._caps,
          this._isAppAutomate(),
          this._config.framework
        );
        this._percyHandler.before();
      }
    }
    return await this._printSessionURL();
  }
  async beforeSuite(suite) {
    this._suiteTitle = suite.title;
    this._insightsHandler?.setSuiteFile(suite.file);
    this._accessibilityHandler?.setSuiteFile(suite.file);
    if (suite.title && suite.title !== "Jasmine__TopLevel__Suite") {
      if (!BrowserstackCLI.getInstance().isRunning() || this._config.framework !== "mocha") {
        await this._setSessionName(suite.title);
      }
    }
  }
  async beforeHook(test, context) {
    if (this._config.framework !== "cucumber") {
      this._currentTest = test;
    }
    await this._insightsHandler?.beforeHook(test, context);
  }
  async afterHook(test, context, result) {
    if (result && !result.passed) {
      const hookError = result.error && result.error.message || "Hook failed";
      this._hookFailReasons.push(hookError);
      if (!this._options.testObservabilityOptions?.ignoreHooksStatus) {
        this._failReasons.push(hookError);
      }
    }
    await this._insightsHandler?.afterHook(test, result);
  }
  async beforeTest(test) {
    this._currentTest = test;
    let suiteTitle = this._suiteTitle;
    if (test.fullName) {
      const testSuiteName = test.fullName.slice(0, test.fullName.indexOf(test.description || "") - 1);
      if (this._suiteTitle === "Jasmine__TopLevel__Suite") {
        suiteTitle = testSuiteName;
      } else if (this._suiteTitle) {
        suiteTitle = getParentSuiteName(this._suiteTitle, testSuiteName);
      }
    }
    if (BrowserstackCLI.getInstance().isRunning()) {
      await BrowserstackCLI.getInstance().getTestFramework().trackEvent(TestFrameworkState.INIT_TEST, HookState.PRE, { test });
      const uuid = TestFramework.getState(TestFramework.getTrackedInstance(), TestFrameworkConstants.KEY_TEST_UUID);
      this._insightsHandler?.setTestData(test, uuid);
      await BrowserstackCLI.getInstance().getTestFramework().trackEvent(TestFrameworkState.TEST, HookState.PRE, { test, suiteTitle });
      return;
    }
    await this._setAnnotation(`Test: ${test.fullName ?? test.title}`);
    await this._setSessionName(suiteTitle, test);
    await this._accessibilityHandler?.beforeTest(suiteTitle, test);
    await this._insightsHandler?.beforeTest(test);
  }
  async afterTest(test, context, results) {
    this._specsRan = true;
    const { error, passed } = results;
    if (!passed) {
      const testError = error && error.message || "Unknown Error";
      this._failReasons.push(testError);
      this._pureTestFailReasons.push(testError);
    }
    if (BrowserstackCLI.getInstance().isRunning()) {
      await BrowserstackCLI.getInstance().getTestFramework().trackEvent(TestFrameworkState.LOG_REPORT, HookState.POST, { test, result: results });
      await BrowserstackCLI.getInstance().getTestFramework().trackEvent(TestFrameworkState.TEST, HookState.POST, { test, result: results, suiteTite: this._suiteTitle });
      return;
    }
    await this._accessibilityHandler?.afterTest(this._suiteTitle, test);
    await this._insightsHandler?.afterTest(test, results);
    await this._percyHandler?.afterTest();
  }
  async after(result) {
    PerformanceTester.start(HOOK_EVENTS.AFTER);
    try {
      if (BrowserstackCLI.getInstance().isRunning()) {
        await BrowserstackCLI.getInstance().getAutomationFramework().trackEvent(AutomationFrameworkState.EXECUTE, HookState.POST, {});
      }
      const { preferScenarioName, setSessionName, setSessionStatus } = this._options;
      if (preferScenarioName && this._scenariosThatRan.length === 1) {
        this._fullTitle = this._scenariosThatRan.pop();
      }
      await PerformanceTester.measureWrapper(AUTOMATE_EVENTS.SESSION_STATUS, async () => {
        if (setSessionStatus && !BrowserstackCLI.getInstance().isRunning()) {
          const ignoreHooksStatus2 = this._options.testObservabilityOptions?.ignoreHooksStatus === true;
          let sessionStatus;
          let failureReason;
          if (result === 0 && this._specsRan) {
            if (ignoreHooksStatus2) {
              const hasPureTestFailures = this._pureTestFailReasons.length > 0;
              sessionStatus = hasPureTestFailures ? "failed" : "passed";
              failureReason = hasPureTestFailures ? this._pureTestFailReasons.join("\n") : void 0;
            } else {
              const hasReasons = this._failReasons.length > 0;
              sessionStatus = hasReasons ? "failed" : "passed";
              failureReason = hasReasons ? this._failReasons.join("\n") : void 0;
            }
          } else if (ignoreHooksStatus2 && this._specsRan) {
            const hasPureTestFailures = this._pureTestFailReasons.length > 0;
            const hasOnlyHookFailures2 = this._failReasons.length === 0 && this._hookFailReasons.length > 0;
            if (hasOnlyHookFailures2 && !hasPureTestFailures) {
              sessionStatus = "passed";
              failureReason = void 0;
            } else {
              sessionStatus = "failed";
              failureReason = hasPureTestFailures ? this._pureTestFailReasons.join("\n") : void 0;
            }
          } else {
            sessionStatus = "failed";
            if (ignoreHooksStatus2 && this._pureTestFailReasons.length > 0) {
              failureReason = this._pureTestFailReasons.join("\n");
            } else if (this._failReasons.length > 0) {
              failureReason = this._failReasons.join("\n");
            } else {
              failureReason = void 0;
            }
          }
          await this._updateJob({
            status: sessionStatus,
            ...setSessionName ? { name: this._fullTitle } : {},
            ...failureReason ? { reason: failureReason } : {}
          });
        }
      })();
      await listener_default.getInstance().onWorkerEnd();
      if (!BrowserstackCLI.getInstance().isRunning()) {
        await this._percyHandler?.teardown();
      }
      this.saveWorkerData();
      PerformanceTester.end(HOOK_EVENTS.AFTER);
      await PerformanceTester.stopAndGenerate("performance-service.html");
      if (process.env[PERF_MEASUREMENT_ENV]) {
        PerformanceTester.calculateTimes([
          "onRunnerStart",
          "onSuiteStart",
          "onSuiteEnd",
          "onTestStart",
          "onTestEnd",
          "onTestSkip",
          "before",
          "beforeHook",
          "afterHook",
          "beforeTest",
          "afterTest",
          "uploadPending",
          "teardown",
          "browserCommand"
        ]);
      }
      const ignoreHooksStatus = this._options.testObservabilityOptions?.ignoreHooksStatus === true;
      const hasOnlyHookFailures = this._failReasons.length === 0 && this._hookFailReasons.length > 0;
      const shouldOverrideResult = ignoreHooksStatus && this._specsRan && hasOnlyHookFailures;
      if (shouldOverrideResult && result !== 0) {
        return;
      }
    } catch (error) {
      BStackLogger.error(`Error in after hook: ${error}`);
      PerformanceTester.end(HOOK_EVENTS.AFTER, false, util12.format(error));
      await PerformanceTester.stopAndGenerate("performance-service.html");
    }
  }
  async beforeFeature(uri, feature) {
    this._suiteTitle = feature.name;
    await this._setSessionName(feature.name);
    await this._setAnnotation(`Feature: ${feature.name}`);
    await this._insightsHandler?.beforeFeature(uri, feature);
  }
  async beforeScenario(world) {
    this._currentTest = world;
    await this._accessibilityHandler?.beforeScenario(world);
    await this._insightsHandler?.beforeScenario(world);
    const scenarioName = world.pickle.name || "unknown scenario";
    await this._setAnnotation(`Scenario: ${scenarioName}`);
  }
  async afterScenario(world) {
    this._specsRan = true;
    const status = world.result?.status.toLowerCase();
    if (status !== "skipped") {
      this._scenariosThatRan.push(world.pickle.name || "unknown pickle name");
    }
    if (status && this._failureStatuses.includes(status)) {
      const exception = world.result && world.result.message || (status === "pending" ? `Some steps/hooks are pending for scenario "${world.pickle.name}"` : "Unknown Error");
      const ignoreHooksStatus = this._options.testObservabilityOptions?.ignoreHooksStatus === true;
      if (ignoreHooksStatus && this._insightsHandler) {
        const hasTestStepFailures = this._insightsHandler.hasTestStepFailures(world);
        if (hasTestStepFailures) {
          this._failReasons.push(exception);
          this._pureTestFailReasons.push(exception);
        }
      } else {
        this._failReasons.push(exception);
        this._pureTestFailReasons.push(exception);
      }
    }
    await this._accessibilityHandler?.afterScenario(world);
    await this._insightsHandler?.afterScenario(world);
    await this._percyHandler?.afterScenario();
  }
  async beforeStep(step, scenario) {
    await this._insightsHandler?.beforeStep(step, scenario);
    await this._setAnnotation(`Step: ${step.keyword}${step.text}`);
  }
  async afterStep(step, scenario, result) {
    await this._insightsHandler?.afterStep(step, scenario, result);
  }
  async onReload(oldSessionId, newSessionId) {
    if (!this._browser) {
      return Promise.resolve();
    }
    const { setSessionName, setSessionStatus } = this._options;
    const ignoreHooksStatus = this._options.testObservabilityOptions?.ignoreHooksStatus === true;
    let sessionStatus;
    let failureReason;
    if (ignoreHooksStatus) {
      const hasPureTestFailures = this._pureTestFailReasons.length > 0;
      sessionStatus = hasPureTestFailures ? "failed" : "passed";
      failureReason = hasPureTestFailures ? this._pureTestFailReasons.join("\n") : void 0;
    } else {
      const hasReasons = this._failReasons.length > 0;
      sessionStatus = hasReasons ? "failed" : "passed";
      failureReason = hasReasons ? this._failReasons.join("\n") : void 0;
    }
    if (!this._browser.isMultiremote) {
      BStackLogger.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${sessionStatus}`);
    } else {
      const browserName = this._browser.instances.filter(
        (browserName2) => this._browser && this._browser.getInstance(browserName2).sessionId === newSessionId
      )[0];
      BStackLogger.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${sessionStatus}`);
    }
    BStackLogger.warn(`Session Reloaded: Old Session Id: ${oldSessionId}, New Session Id: ${newSessionId}`);
    await this._insightsHandler?.sendCBTInfo();
    if (setSessionStatus) {
      await this._update(oldSessionId, {
        status: sessionStatus,
        ...setSessionName ? { name: this._fullTitle } : {},
        ...failureReason ? { reason: failureReason } : {}
      });
    }
    this._scenariosThatRan = [];
    delete this._fullTitle;
    delete this._suiteFile;
    this._failReasons = [];
    this._hookFailReasons = [];
    this._pureTestFailReasons = [];
    await this._printSessionURL();
  }
  _isAppAutomate() {
    const browserDesiredCapabilities = this._browser?.capabilities ?? {};
    const desiredCapabilities = this._caps ?? {};
    return !!browserDesiredCapabilities["appium:app"] || !!desiredCapabilities["appium:app"] || !!desiredCapabilities["appium:options"]?.app;
  }
  _updateJob(requestBody) {
    return this._multiRemoteAction((sessionId, browserName) => {
      BStackLogger.info(
        browserName ? `Update multiremote job for browser "${browserName}" and sessionId ${sessionId}` : `Update job with sessionId ${sessionId}`
      );
      return this._update(sessionId, requestBody);
    });
  }
  _multiRemoteAction(action) {
    if (!this._browser) {
      return Promise.resolve();
    }
    if (!this._browser.isMultiremote) {
      return action(this._browser.sessionId);
    }
    const multiremotebrowser = this._browser;
    return Promise.all(
      multiremotebrowser.instances.filter((browserName) => {
        const cap = getBrowserCapabilities(multiremotebrowser, this._caps, browserName);
        return isBrowserstackCapability(cap);
      }).map((browserName) => action(multiremotebrowser.getInstance(browserName).sessionId, browserName))
    );
  }
  _update(sessionId, requestBody) {
    if (!isBrowserstackSession(this._browser)) {
      return Promise.resolve();
    }
    const sessionUrl = `${this._sessionBaseUrl}/${sessionId}.json`;
    BStackLogger.debug(`Updating Browserstack session at ${sessionUrl} with request body: `, requestBody);
    const encodedAuth = Buffer.from(`${this._config.user}:${this._config.key}`, "utf8").toString("base64");
    const headers = {
      "Content-Type": "application/json; charset=utf-8",
      Authorization: `Basic ${encodedAuth}`
    };
    if (this._turboScale) {
      return _fetch(sessionUrl, {
        method: "PATCH",
        body: JSON.stringify(requestBody),
        headers
      });
    }
    return _fetch(sessionUrl, {
      method: "PUT",
      body: JSON.stringify(requestBody),
      headers
    });
  }
  async _printSessionURL() {
    if (!this._browser || !isBrowserstackSession(this._browser)) {
      return Promise.resolve();
    }
    await this._multiRemoteAction(async (sessionId, browserName) => {
      const sessionUrl = `${this._sessionBaseUrl}/${sessionId}.json`;
      BStackLogger.debug(`Requesting Browserstack session URL at ${sessionUrl}`);
      let browserUrl;
      const encodedAuth = Buffer.from(`${this._config.user}:${this._config.key}`, "utf8").toString("base64");
      const headers = {
        "Content-Type": "application/json; charset=utf-8",
        Authorization: `Basic ${encodedAuth}`
      };
      if (this._turboScale) {
        const response = await _fetch(sessionUrl, {
          method: "GET",
          headers
        });
        const res = response.clone();
        browserUrl = (await res.json()).url;
      } else {
        const response = await _fetch(sessionUrl, {
          method: "GET",
          headers
        });
        const res = response.clone();
        browserUrl = (await res.json()).automation_session.browser_url;
      }
      if (!this._browser) {
        return;
      }
      const capabilities = getBrowserCapabilities(this._browser, this._caps, browserName);
      const browserString = getBrowserDescription(capabilities);
      BStackLogger.info(`${browserString} session: ${browserUrl}`);
    });
  }
  async _setSessionName(suiteTitle, test) {
    if (!this._options.setSessionName || !suiteTitle) {
      return;
    }
    let name = suiteTitle;
    if (this._options.sessionNameFormat) {
      name = this._options.sessionNameFormat(
        this._config,
        this._caps,
        suiteTitle,
        test?.title
      );
    } else if (test && !test.fullName) {
      const pre = this._options.sessionNamePrependTopLevelSuiteTitle ? `${suiteTitle} - ` : "";
      const post = !this._options.sessionNameOmitTestTitle ? ` - ${test.title}` : "";
      name = `${pre}${test.parent}${post}`;
    }
    if (!BrowserstackCLI.getInstance().isRunning()) {
      this._percyHandler?._setSessionName(name);
    }
    if (name !== this._fullTitle && !BrowserstackCLI.getInstance().isRunning()) {
      this._fullTitle = name;
      await this._updateJob({ name });
    }
    return name;
  }
  _setAnnotation(data) {
    return this._executeCommand("annotate", { data, level: "info" });
  }
  async _executeCommand(action, args) {
    if (!this._browser || !isBrowserstackSession(this._browser)) {
      return Promise.resolve();
    }
    const cmd = { action, ...args ? { arguments: args } : {} };
    const script = `browserstack_executor: ${JSON.stringify(cmd)}`;
    if (this._browser.isMultiremote) {
      const multiRemoteBrowser = this._browser;
      return Promise.all(Object.keys(this._caps).map(async (browserName) => {
        const browser = multiRemoteBrowser.getInstance(browserName);
        return await browser.executeScript(script, []);
      }));
    }
    return await this._browser.executeScript(script, []);
  }
  saveWorkerData() {
    saveWorkerData({
      usageStats: usageStats_default.getInstance().getDataToSave()
    });
  }
};
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeSession" })
], BrowserstackService.prototype, "beforeSession", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "before" })
], BrowserstackService.prototype, "before", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeSuite" })
], BrowserstackService.prototype, "beforeSuite", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeHook" })
], BrowserstackService.prototype, "beforeHook", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "afterHook" })
], BrowserstackService.prototype, "afterHook", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeTest" })
], BrowserstackService.prototype, "beforeTest", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "afterTest" })
], BrowserstackService.prototype, "afterTest", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "after" })
], BrowserstackService.prototype, "after", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeFeature" })
], BrowserstackService.prototype, "beforeFeature", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeScenario" })
], BrowserstackService.prototype, "beforeScenario", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "afterScenario" })
], BrowserstackService.prototype, "afterScenario", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "beforeStep" })
], BrowserstackService.prototype, "beforeStep", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "afterStep" })
], BrowserstackService.prototype, "afterStep", 1);
__decorateClass([
  PerformanceTester.Measure(EVENTS.SDK_HOOK, { hookType: "onReload" })
], BrowserstackService.prototype, "onReload", 1);
__decorateClass([
  PerformanceTester.Measure(AUTOMATE_EVENTS.PRINT_BUILDLINK)
], BrowserstackService.prototype, "_printSessionURL", 1);

// src/logReportingAPI.ts
import Transport2 from "winston-transport";
var LOG_LEVELS2 = {
  INFO: "INFO",
  ERROR: "ERROR",
  DEBUG: "DEBUG",
  TRACE: "TRACE",
  WARN: "WARN"
};
var logReportingAPI = class extends Transport2 {
  log(info, callback = void 0) {
    setImmediate(() => {
      this.emit("logged", info);
    });
    if (typeof info === "object") {
      this.logToTestOps(info.level || LOG_LEVELS2.INFO, info.message, false);
    } else {
      this.logToTestOps(LOG_LEVELS2.INFO, info);
    }
    if (callback && typeof callback === "function") {
      callback();
    }
  }
  logToTestOps = (level = LOG_LEVELS2.INFO, message = "", consoleLog = true) => {
    if (consoleLog) {
      consoleHolder[level.toLowerCase()](message);
    }
    process.emit(`bs:addLog:${process.pid}`, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: level.toUpperCase(),
      message,
      kind: "TEST_LOG",
      http_response: {}
    });
  };
  /* Patching this would show user an extended trace on their cli */
  trace = (message) => {
    this.logToTestOps(LOG_LEVELS2.TRACE, message);
  };
  debug = (message) => {
    this.logToTestOps(LOG_LEVELS2.DEBUG, message);
  };
  info = (message) => {
    this.logToTestOps(LOG_LEVELS2.INFO, message);
  };
  warn = (message) => {
    this.logToTestOps(LOG_LEVELS2.WARN, message);
  };
  error = (message) => {
    this.logToTestOps(LOG_LEVELS2.ERROR, message);
  };
};
var logReportingAPI_default = logReportingAPI;

// src/log4jsAppender.ts
var BSTestOpsLogger = new logReportingAPI_default({});
function BSTestOpsLog4JSAppender(layout, timezoneOffset) {
  return (loggingEvent) => {
    BSTestOpsLogger.log({
      level: loggingEvent.level ? loggingEvent.level.levelStr : null,
      message: loggingEvent.data ? loggingEvent.data.join(" ") : null
    });
  };
}
var configure = (config, layouts) => {
  let layout = layouts.colouredLayout;
  if (config.layout) {
    layout = layouts.layout(config.layout.type, config.layout);
  }
  return BSTestOpsLog4JSAppender(layout, config.timezoneOffset);
};

// src/index.ts
var index_default = BrowserstackService;
var launcher = BrowserstackLauncherService;
var log4jsAppender = { configure };
var BStackTestOpsLogger = logReportingAPI_default;
var PercySDK = PercySDK_exports;
export {
  BStackTestOpsLogger,
  PercySDK,
  index_default as default,
  launcher,
  log4jsAppender
};
