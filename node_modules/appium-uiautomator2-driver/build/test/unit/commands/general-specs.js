"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sinon_1 = __importDefault(require("sinon"));
const driver_1 = require("../../../lib/driver");
const appium_adb_1 = require("appium-adb");
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const { expect } = chai_1.default;
chai_1.default.use(chai_as_promised_1.default);
describe('General', function () {
    let driver;
    let mockDriver;
    beforeEach(function () {
        driver = new driver_1.AndroidUiautomator2Driver();
        mockDriver = sinon_1.default.mock(driver);
    });
    afterEach(function () {
        mockDriver.verify();
    });
    describe('getWindowRect', function () {
        it('should get window size', async function () {
            mockDriver.expects('getWindowSize').once().returns({ width: 300, height: 400 });
            const result = await driver.getWindowRect();
            expect(result).to.eql({
                width: 300,
                height: 400,
                x: 0,
                y: 0,
            });
        });
    });
    describe('mobile command', function () {
        it('should raise error on non-existent mobile command', async function () {
            await expect(driver.execute('mobile: fruta', {})).to.be.rejectedWith(/Unsupported/);
        });
    });
    describe('mobile: sensorSet', function () {
        // note: this test does not depend on whether or not isEmulator returns
        // true, because the "am I an emulator?" check happens in the sensorSet
        // implementation, which is stubbed out.
        it('should call sensorSet', async function () {
            mockDriver.expects('sensorSet').once().withArgs('acceleration', '0:9.77631:0.812349');
            await driver.execute('mobile: sensorSet', {
                sensorType: 'acceleration',
                value: '0:9.77631:0.812349',
            });
        });
    });
    describe('mobile: installMultipleApks', function () {
        let adb;
        let mockHelpers;
        let mockAdb;
        beforeEach(function () {
            adb = new appium_adb_1.ADB();
            mockAdb = sinon_1.default.mock(adb);
            driver = new driver_1.AndroidUiautomator2Driver();
            driver.adb = adb;
            mockHelpers = sinon_1.default.mock(driver.helpers);
            mockHelpers.expects('configureApp').returns('/path/to/test/apk.apk');
        });
        afterEach(function () {
            mockHelpers.restore();
            mockAdb.verify();
        });
        it('should call mobileInstallMultipleApks', async function () {
            mockAdb.expects('installMultipleApks').once().withExactArgs(['/path/to/test/apk.apk'], undefined);
            await driver.execute('mobile: installMultipleApks', { apks: ['/path/to/test/apk.apk'] });
        });
        it('should reject if no apks were given', async function () {
            await expect(driver.execute('mobile: installMultipleApks', { apks: [] })).to.be.rejectedWith('No apks are given to install');
        });
        it('should reject with default args', async function () {
            await expect(driver.execute('mobile: installMultipleApks')).to.be.rejected;
        });
    });
});
//# sourceMappingURL=general-specs.js.map