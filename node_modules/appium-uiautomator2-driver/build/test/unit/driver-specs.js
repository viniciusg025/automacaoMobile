"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const driver_1 = require("../../lib/driver");
const sinon_1 = __importDefault(require("sinon"));
const path = __importStar(require("node:path"));
const bluebird_1 = __importDefault(require("bluebird"));
const appium_adb_1 = require("appium-adb");
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const { expect } = chai_1.default;
chai_1.default.use(chai_as_promised_1.default);
const sandbox = sinon_1.default.createSandbox();
function defaultStub(driver) {
    sandbox.stub(driver, 'getDeviceDetails');
    const adb = new appium_adb_1.ADB();
    sandbox.stub(driver, 'createADB').returns(Promise.resolve(adb));
    sandbox.mock(driver).expects('getDeviceInfoFromCaps').once().returns(Promise.resolve({
        udid: '123',
        emPort: false
    }));
    return adb;
}
describe('driver.js', function () {
    this.afterEach(function () {
        sandbox.restore();
    });
    describe('constructor', function () {
        it('calls BaseDriver constructor with opts', function () {
            const driver = new driver_1.AndroidUiautomator2Driver({}, false);
            expect(driver).to.exist;
            expect(driver.opts).to.exist;
        });
    });
    describe('createSession', function () {
        it('should throw an error if app can not be found', async function () {
            const driver = new driver_1.AndroidUiautomator2Driver({}, false);
            const adb = defaultStub(driver);
            sandbox.stub(adb, 'getApiLevel').onFirstCall().returns(bluebird_1.default.resolve(24));
            await expect(driver
                .createSession({}, {}, {
                firstMatch: [{}],
                alwaysMatch: {
                    'appium:app': 'foo.apk',
                },
            })).to.be.rejectedWith('does not exist or is not accessible');
        });
        it('should set sessionId', async function () {
            const driver = new driver_1.AndroidUiautomator2Driver({}, false);
            const adb = defaultStub(driver);
            sandbox.mock(driver).expects('checkAppPresent').once().returns(bluebird_1.default.resolve());
            sandbox.stub(adb, 'getApiLevel').onFirstCall().returns(bluebird_1.default.resolve(24));
            sandbox.mock(driver).expects('startUiAutomator2Session').once().returns(bluebird_1.default.resolve());
            await driver.createSession({}, {}, {
                firstMatch: [{}],
                alwaysMatch: {
                    browserName: 'chrome',
                },
            });
            expect(driver.sessionId).to.exist;
        });
        it('should set the default context', async function () {
            const driver = new driver_1.AndroidUiautomator2Driver({}, false);
            const adb = defaultStub(driver);
            sandbox.stub(adb, 'getApiLevel').onFirstCall().returns(bluebird_1.default.resolve(24));
            sandbox.mock(driver).expects('checkAppPresent').returns(bluebird_1.default.resolve());
            sandbox.mock(driver).expects('startUiAutomator2Session').returns(bluebird_1.default.resolve());
            await driver.createSession({}, {}, {
                firstMatch: [{}],
                alwaysMatch: {
                    browserName: 'chrome',
                },
            });
            expect(driver.curContext).to.equal('NATIVE_APP');
        });
    });
    describe('checkAppPresent', function () {
        it('should resolve if app present', async function () {
            const driver = new driver_1.AndroidUiautomator2Driver({}, false);
            defaultStub(driver);
            const app = path.resolve('.');
            sandbox.mock(driver).expects('startUiAutomator2Session').returns(bluebird_1.default.resolve());
            const configureAppStub = sandbox.stub(driver.helpers, 'configureApp').returns(app);
            await driver.createSession({}, {}, {
                firstMatch: [{}],
                alwaysMatch: { 'appium:app': app },
            });
            await driver.checkAppPresent(); // should not error
            // configureApp is shared between the two,
            // so restore mock or the next test will fail
            configureAppStub.restore();
        });
        it('should reject if app not present', async function () {
            const driver = new driver_1.AndroidUiautomator2Driver({}, false);
            defaultStub(driver);
            const app = path.resolve('asdfasdf');
            const checkAppPresentStub = sandbox.stub(driver, 'checkAppPresent').returns(bluebird_1.default.resolve());
            sandbox.mock(driver).expects('startUiAutomator2Session').returns(bluebird_1.default.resolve());
            sandbox.mock(driver.helpers).expects('configureApp').returns(app);
            await driver.createSession({}, {}, {
                firstMatch: [{}],
                alwaysMatch: { 'appium:app': app },
            });
            checkAppPresentStub.restore();
            await expect(driver.checkAppPresent()).to.be.rejectedWith('Could not find');
        });
    });
    describe('proxying', function () {
        let driver;
        before(function () {
            driver = new driver_1.AndroidUiautomator2Driver({}, false);
            defaultStub(driver);
            driver.sessionId = 'abc';
        });
        describe('#proxyActive', function () {
            it('should exist', function () {
                expect(driver.proxyActive).to.be.an.instanceof(Function);
            });
            it('should return true', function () {
                expect(driver.proxyActive('abc')).to.be.true;
            });
            it('should throw an error if session id is wrong', function () {
                expect(() => {
                    driver.proxyActive('aaa');
                }).to.throw;
            });
        });
        describe('#getProxyAvoidList', function () {
            it('should exist', function () {
                expect(driver.getProxyAvoidList).to.be.an.instanceof(Function);
            });
            it('should return jwpProxyAvoid array', function () {
                const avoidList = driver.getProxyAvoidList();
                expect(avoidList).to.be.an.instanceof(Array);
                expect(avoidList).to.eql(driver.jwpProxyAvoid);
            });
            it('should throw an error if session id is wrong', function () {
                expect(() => {
                    driver.getProxyAvoidList();
                }).to.not.throw;
            });
            describe('nativeWebScreenshot', function () {
                let proxyAvoidList;
                const nativeWebScreenshotFilter = (item) => item[0] === 'GET' && item[1].test('/session/xxx/screenshot/');
                beforeEach(function () {
                    driver = new driver_1.AndroidUiautomator2Driver({}, false);
                    const adb = defaultStub(driver);
                    sandbox.mock(driver).expects('checkAppPresent').once().returns(bluebird_1.default.resolve());
                    sandbox.stub(adb, 'getApiLevel').onFirstCall().returns(bluebird_1.default.resolve(24));
                    sandbox.mock(driver).expects('startUiAutomator2Session').once().returns(bluebird_1.default.resolve());
                });
                describe('on webview mode', function () {
                    beforeEach(function () {
                        driver.chromedriver = true;
                    });
                    it('should proxy screenshot if nativeWebScreenshot is off on chromedriver mode', async function () {
                        await driver.createSession({}, {}, {
                            firstMatch: [{}],
                            alwaysMatch: {
                                platformName: 'Android',
                                'appium:deviceName': 'device',
                                browserName: 'chrome',
                                'appium:nativeWebScreenshot': false,
                            },
                        });
                        proxyAvoidList = driver.getProxyAvoidList().filter(nativeWebScreenshotFilter);
                        expect(proxyAvoidList).to.be.empty;
                    });
                    it('should not proxy screenshot if nativeWebScreenshot is on on chromedriver mode', async function () {
                        await driver.createSession({}, {}, {
                            firstMatch: [{}],
                            alwaysMatch: {
                                platformName: 'Android',
                                'appium:deviceName': 'device',
                                browserName: 'chrome',
                                'appium:nativeWebScreenshot': true,
                            },
                        });
                        proxyAvoidList = driver.getProxyAvoidList().filter(nativeWebScreenshotFilter);
                        expect(proxyAvoidList).to.not.be.empty;
                    });
                });
                describe('on native mode', function () {
                    it('should never proxy screenshot regardless of nativeWebScreenshot setting (on)', async function () {
                        // nativeWebScreenshot on
                        await driver.createSession({}, {}, {
                            firstMatch: [{}],
                            alwaysMatch: {
                                platformName: 'Android',
                                'appium:deviceName': 'device',
                                browserName: 'chrome',
                                'appium:nativeWebScreenshot': true,
                            },
                        });
                        proxyAvoidList = driver.getProxyAvoidList().filter(nativeWebScreenshotFilter);
                        expect(proxyAvoidList).to.not.be.empty;
                    });
                    it('should never proxy screenshot regardless of nativeWebScreenshot setting (off)', async function () {
                        // nativeWebScreenshot off
                        await driver.createSession({}, {}, {
                            firstMatch: [{}],
                            alwaysMatch: {
                                platformName: 'Android',
                                'appium:deviceName': 'device',
                                browserName: 'chrome',
                                'appium:nativeWebScreenshot': false,
                            },
                        });
                        proxyAvoidList = driver.getProxyAvoidList().filter(nativeWebScreenshotFilter);
                        expect(proxyAvoidList).to.not.be.empty;
                    });
                });
            });
        });
        describe('#canProxy', function () {
            it('should exist', function () {
                expect(driver.canProxy).to.be.an.instanceof(Function);
            });
            it('should return true', function () {
                expect(driver.canProxy('abc')).to.be.true;
            });
            it('should throw an error if session id is wrong', function () {
                expect(() => {
                    driver.canProxy('aaa');
                }).to.throw;
            });
        });
    });
    describe('magic first visible child xpath', function () {
        const driver = new driver_1.AndroidUiautomator2Driver({}, false);
        it('should trap and proxy to special uia2 server endpoint', async function () {
            defaultStub(driver);
            driver.uiautomator2 = { jwproxy: { command: () => { } } };
            const proxySpy = sandbox.stub(driver.uiautomator2.jwproxy, 'command');
            await driver.doFindElementOrEls({
                strategy: 'xpath',
                selector: '/*[@firstVisible="true"]',
                context: 'foo',
                multiple: false,
            });
            expect(proxySpy.firstCall.args).to.eql([`/appium/element/foo/first_visible`, 'GET', {}]);
        });
    });
    describe('magic scrollable view xpath', function () {
        const driver = new driver_1.AndroidUiautomator2Driver({}, false);
        it('should trap and rewrite as uiautomator locator', async function () {
            defaultStub(driver);
            driver.uiautomator2 = { jwproxy: { command: () => { } } };
            const proxySpy = sandbox.stub(driver.uiautomator2.jwproxy, 'command');
            await driver.doFindElementOrEls({
                strategy: 'xpath',
                selector: '//*[@scrollable="true"]',
                context: 'foo',
                multiple: false,
            });
            expect(proxySpy.firstCall.args).to.eql([
                '/element',
                'POST',
                {
                    context: 'foo',
                    multiple: false,
                    strategy: '-android uiautomator',
                    selector: 'new UiSelector().scrollable(true)',
                },
            ]);
        });
    });
    describe('deleteSession', function () {
        let driver;
        beforeEach(function () {
            driver = new driver_1.AndroidUiautomator2Driver({}, false);
            driver.adb = new appium_adb_1.ADB();
            driver.caps = {};
            sandbox.stub(driver.adb, 'stopLogcat');
        });
        afterEach(function () {
            sandbox.restore();
        });
        it('should call setDefaultHiddenApiPolicy', async function () {
            sandbox.stub(driver.adb, 'getApiLevel').returns(28);
            const setDefaultHiddenApiPolicyStub = sandbox.stub(driver.adb, 'setDefaultHiddenApiPolicy');
            await driver.deleteSession();
            expect(setDefaultHiddenApiPolicyStub.calledOnce).to.be.true;
        });
        it('should not call setDefaultHiddenApiPolicy', async function () {
            sandbox.stub(driver.adb, 'getApiLevel').returns(27);
            const setDefaultHiddenApiPolicyStub = sandbox.stub(driver.adb, 'setDefaultHiddenApiPolicy');
            await driver.deleteSession();
            expect(setDefaultHiddenApiPolicyStub.calledOnce).to.be.false;
        });
    });
});
//# sourceMappingURL=driver-specs.js.map