import { Devicectl } from 'node-devicectl';
import type { AppiumLogger } from '@appium/types';
import type { XCUITestDriver } from '../driver';
export declare const IO_TIMEOUT_MS: number;
/**
 * Retrieve a file from a real device
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param remotePath Relative path to the file on the device
 * @returns The file content as a buffer
 */
export declare function pullFile(afcService: any, remotePath: string): Promise<Buffer>;
/**
 * Retrieve a folder from a real device
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param remoteRootPath Relative path to the folder on the device
 * @returns The folder content as a zipped base64-encoded buffer
 */
export declare function pullFolder(afcService: any, remoteRootPath: string): Promise<Buffer>;
/**
 * Pushes a file to a real device
 *
 * @param afcService afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param localPathOrPayload Either full path to the source file
 * or a buffer payload to be written into the remote destination
 * @param remotePath Relative path to the file on the device. The remote
 * folder structure is created automatically if necessary.
 * @param opts Push file options
 */
export declare function pushFile(afcService: any, localPathOrPayload: string | Buffer, remotePath: string, opts?: PushFileOptions): Promise<void>;
/**
 * Pushes a folder to a real device
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param srcRootPath The full path to the source folder
 * @param dstRootPath The relative path to the destination folder. The folder
 * will be deleted if already exists.
 * @param opts Push folder options
 */
export declare function pushFolder(afcService: any, srcRootPath: string, dstRootPath: string, opts?: PushFolderOptions): Promise<void>;
/**
 * Get list of connected devices
 */
export declare function getConnectedDevices(): Promise<string[]>;
export declare class RealDevice {
    readonly udid: string;
    private readonly _log;
    readonly devicectl: Devicectl;
    constructor(udid: string, logger?: AppiumLogger);
    get log(): AppiumLogger;
    remove(bundleId: string): Promise<void>;
    removeApp(bundleId: string): Promise<void>;
    install(appPath: string, bundleId: string, opts?: RealDeviceInstallOptions): Promise<void>;
    installOrUpgradeApplication(bundlePathOnPhone: string, opts: InstallOrUpgradeOptions): Promise<void>;
    /**
     * Alias for {@linkcode install}
     */
    installApp(appPath: string, bundleId: string, opts?: RealDeviceInstallOptions): Promise<void>;
    /**
     * Return an application object if test app has 'bundleid'.
     * The target bundleid can be User and System apps.
     *
     * @param bundleId The bundleId to ensure it is installed
     * @returns Returns True if the app is installed on the device under test.
     */
    isAppInstalled(bundleId: string): Promise<boolean>;
    /**
     * Fetches various attributes, like bundle id, version, entitlements etc. of
     * an installed application.
     *
     * @param bundleId the bundle identifier of an app to check
     * @param returnAttributes If provided then
     * only fetches the requested attributes of the app into the resulting object.
     * Some apps may have too many attributes, so it makes sense to limit these
     * by default if you don't need all of them.
     * @returns Either app info as an object or undefined if the app is not found.
     */
    fetchAppInfo(bundleId: string, returnAttributes?: string | string[]): Promise<Record<string, any> | undefined>;
    terminateApp(bundleId: string, platformVersion: string): Promise<boolean>;
    /**
     * @param bundleName The name of CFBundleName in Info.plist
     *
     * @returns A list of User level apps' bundle ids which has
     *                          'CFBundleName' attribute as 'bundleName'.
     */
    getUserInstalledBundleIdsByBundleName(bundleName: string): Promise<string[]>;
    getPlatformVersion(): Promise<string>;
    reset(opts: {
        bundleId?: string;
        fullReset?: boolean;
    }): Promise<void>;
}
/**
 * Install app to real device
 */
export declare function installToRealDevice(this: XCUITestDriver, app: string, bundleId?: string, opts?: ManagementInstallOptions): Promise<void>;
/**
 * Run real device reset
 */
export declare function runRealDeviceReset(this: XCUITestDriver): Promise<void>;
/**
 * Configures Safari startup options based on the given session capabilities.
 *
 * !!! This method mutates driver options.
 *
 * @returns true if process arguments have been modified
 */
export declare function applySafariStartupArgs(this: XCUITestDriver): boolean;
/**
 * Auto-detect device UDID
 */
export declare function detectUdid(this: XCUITestDriver): Promise<string>;
export interface PushFileOptions {
    /** The maximum count of milliceconds to wait until file push is completed. Cannot be lower than 60000ms */
    timeoutMs?: number;
}
export interface PushFolderOptions {
    /** The maximum timeout to wait until a single file is copied */
    timeoutMs?: number;
    /** Whether to push files in parallel. This usually gives better performance, but might sometimes be less stable. */
    enableParallelPush?: boolean;
}
export interface RealDeviceInstallOptions {
    /** Application installation timeout in milliseconds */
    timeoutMs?: number;
}
export interface InstallOrUpgradeOptions {
    /** Install/upgrade timeout in milliseconds */
    timeout: number;
    /** Whether it is an app upgrade or a new install */
    isUpgrade: boolean;
}
export interface ManagementInstallOptions {
    /** Whether to skip app uninstall before installing it */
    skipUninstall?: boolean;
    /** App install timeout */
    timeout?: number;
    /** Whether to enforce the app uninstallation. e.g. fullReset, or enforceAppInstall is true */
    shouldEnforceUninstall?: boolean;
}
//# sourceMappingURL=real-device-management.d.ts.map