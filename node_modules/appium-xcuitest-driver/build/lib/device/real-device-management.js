"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealDevice = exports.IO_TIMEOUT_MS = void 0;
exports.pullFile = pullFile;
exports.pullFolder = pullFolder;
exports.pushFile = pushFile;
exports.pushFolder = pushFolder;
exports.getConnectedDevices = getConnectedDevices;
exports.installToRealDevice = installToRealDevice;
exports.runRealDeviceReset = runRealDeviceReset;
exports.applySafariStartupArgs = applySafariStartupArgs;
exports.detectUdid = detectUdid;
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importStar(require("bluebird"));
const support_1 = require("appium/support");
const path_1 = __importDefault(require("path"));
const appium_ios_device_1 = require("appium-ios-device");
const app_utils_1 = require("../app-utils");
const logger_1 = __importDefault(require("../logger"));
const node_devicectl_1 = require("node-devicectl");
const DEFAULT_APP_INSTALLATION_TIMEOUT_MS = 8 * 60 * 1000;
exports.IO_TIMEOUT_MS = 4 * 60 * 1000;
// Mobile devices use NAND memory modules for the storage,
// and the parallelism there is not as performant as on regular SSDs
const MAX_IO_CHUNK_SIZE = 8;
const APPLICATION_INSTALLED_NOTIFICATION = 'com.apple.mobile.application_installed';
const APPLICATION_NOTIFICATION_TIMEOUT_MS = 30 * 1000;
const INSTALLATION_STAGING_DIR = 'PublicStaging';
//#region Public File System Functions
/**
 * Retrieve a file from a real device
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param remotePath Relative path to the file on the device
 * @returns The file content as a buffer
 */
async function pullFile(afcService, remotePath) {
    const stream = await afcService.createReadStream(remotePath, { autoDestroy: true });
    const pullPromise = new bluebird_1.default((resolve, reject) => {
        stream.on('close', resolve);
        stream.on('error', reject);
    }).timeout(exports.IO_TIMEOUT_MS);
    const buffers = [];
    stream.on('data', (data) => buffers.push(data));
    await pullPromise;
    return Buffer.concat(buffers);
}
/**
 * Retrieve a folder from a real device
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param remoteRootPath Relative path to the folder on the device
 * @returns The folder content as a zipped base64-encoded buffer
 */
async function pullFolder(afcService, remoteRootPath) {
    const tmpFolder = await support_1.tempDir.openDir();
    try {
        let localTopItem = null;
        let countFilesSuccess = 0;
        let countFilesFail = 0;
        let countFolders = 0;
        const pullPromises = [];
        await afcService.walkDir(remoteRootPath, true, async (remotePath, isDir) => {
            const localPath = path_1.default.join(tmpFolder, remotePath);
            const dirname = isDir ? localPath : path_1.default.dirname(localPath);
            if (!(await folderExists(dirname))) {
                await (0, support_1.mkdirp)(dirname);
            }
            if (!localTopItem || localPath.split(path_1.default.sep).length < localTopItem.split(path_1.default.sep).length) {
                localTopItem = localPath;
            }
            if (isDir) {
                ++countFolders;
                return;
            }
            const readStream = await afcService.createReadStream(remotePath, { autoDestroy: true });
            const writeStream = support_1.fs.createWriteStream(localPath, { autoClose: true });
            pullPromises.push(new bluebird_1.default((resolve) => {
                writeStream.on('close', () => {
                    ++countFilesSuccess;
                    resolve();
                });
                const onStreamingError = (e) => {
                    readStream.unpipe(writeStream);
                    logger_1.default.warn(`Cannot pull '${remotePath}' to '${localPath}'. ` +
                        `The file will be skipped. Original error: ${e.message}`);
                    ++countFilesFail;
                    resolve();
                };
                writeStream.on('error', onStreamingError);
                readStream.on('error', onStreamingError);
            }).timeout(exports.IO_TIMEOUT_MS));
            readStream.pipe(writeStream);
            if (pullPromises.length >= MAX_IO_CHUNK_SIZE) {
                await bluebird_1.default.any(pullPromises);
                for (let i = pullPromises.length - 1; i >= 0; i--) {
                    if (pullPromises[i].isFulfilled()) {
                        pullPromises.splice(i, 1);
                    }
                }
            }
        });
        // Wait for the rest of files to be pulled
        if (!lodash_1.default.isEmpty(pullPromises)) {
            await bluebird_1.default.all(pullPromises);
        }
        logger_1.default.info(`Pulled ${support_1.util.pluralize('file', countFilesSuccess, true)} out of ` +
            `${countFilesSuccess + countFilesFail} and ${support_1.util.pluralize('folder', countFolders, true)} ` +
            `from '${remoteRootPath}'`);
        return await support_1.zip.toInMemoryZip(localTopItem ? path_1.default.dirname(localTopItem) : tmpFolder, {
            encodeToBase64: true,
        });
    }
    finally {
        await support_1.fs.rimraf(tmpFolder);
    }
}
/**
 * Pushes a file to a real device
 *
 * @param afcService afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param localPathOrPayload Either full path to the source file
 * or a buffer payload to be written into the remote destination
 * @param remotePath Relative path to the file on the device. The remote
 * folder structure is created automatically if necessary.
 * @param opts Push file options
 */
async function pushFile(afcService, localPathOrPayload, remotePath, opts = {}) {
    const { timeoutMs = exports.IO_TIMEOUT_MS } = opts;
    const timer = new support_1.timing.Timer().start();
    await remoteMkdirp(afcService, path_1.default.dirname(remotePath));
    const source = Buffer.isBuffer(localPathOrPayload)
        ? localPathOrPayload
        : support_1.fs.createReadStream(localPathOrPayload, { autoClose: true });
    const writeStream = await afcService.createWriteStream(remotePath, {
        autoDestroy: true,
    });
    writeStream.on('finish', writeStream.destroy);
    let pushError = null;
    const filePushPromise = new bluebird_1.default((resolve, reject) => {
        writeStream.on('close', () => {
            if (pushError) {
                reject(pushError);
            }
            else {
                resolve();
            }
        });
        const onStreamError = (e) => {
            if (!Buffer.isBuffer(source)) {
                source.unpipe(writeStream);
            }
            logger_1.default.debug(e);
            pushError = e;
        };
        writeStream.on('error', onStreamError);
        if (!Buffer.isBuffer(source)) {
            source.on('error', onStreamError);
        }
    });
    if (Buffer.isBuffer(source)) {
        writeStream.write(source);
        writeStream.end();
    }
    else {
        source.pipe(writeStream);
    }
    await filePushPromise.timeout(Math.max(timeoutMs, 60000));
    const fileSize = Buffer.isBuffer(localPathOrPayload)
        ? localPathOrPayload.length
        : (await support_1.fs.stat(localPathOrPayload)).size;
    logger_1.default.debug(`Successfully pushed the file payload (${support_1.util.toReadableSizeString(fileSize)}) ` +
        `to the remote location '${remotePath}' in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
}
/**
 * Pushes a folder to a real device
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param srcRootPath The full path to the source folder
 * @param dstRootPath The relative path to the destination folder. The folder
 * will be deleted if already exists.
 * @param opts Push folder options
 */
async function pushFolder(afcService, srcRootPath, dstRootPath, opts = {}) {
    const { timeoutMs = exports.IO_TIMEOUT_MS, enableParallelPush = false } = opts;
    const timer = new support_1.timing.Timer().start();
    const allItems = /** @type {import('path-scurry').Path[]} */ (
    /** @type {unknown} */ (await support_1.fs.glob('**', {
        cwd: srcRootPath,
        withFileTypes: true,
    })));
    logger_1.default.debug(`Successfully scanned the tree structure of '${srcRootPath}'`);
    // top-level folders go first
    const foldersToPush = allItems
        .filter((x) => x.isDirectory())
        .map((x) => x.relative())
        .sort((a, b) => a.split(path_1.default.sep).length - b.split(path_1.default.sep).length);
    // larger files go first
    const filesToPush = allItems
        .filter((x) => !x.isDirectory())
        .sort((a, b) => (b.size ?? 0) - (a.size ?? 0))
        .map((x) => x.relative());
    logger_1.default.debug(`Got ${support_1.util.pluralize('folder', foldersToPush.length, true)} and ` +
        `${support_1.util.pluralize('file', filesToPush.length, true)} to push`);
    // create the folder structure first
    try {
        await afcService.deleteDirectory(dstRootPath);
    }
    catch { }
    await afcService.createDirectory(dstRootPath);
    for (const relativeFolderPath of foldersToPush) {
        // createDirectory does not accept folder names ending with a path separator
        const absoluteFolderPath = lodash_1.default.trimEnd(path_1.default.join(dstRootPath, relativeFolderPath), path_1.default.sep);
        if (absoluteFolderPath) {
            await afcService.createDirectory(absoluteFolderPath);
        }
    }
    // do not forget about the root folder
    logger_1.default.debug(`Successfully created the remote folder structure ` +
        `(${support_1.util.pluralize('item', foldersToPush.length + 1, true)})`);
    const _pushFile = async (relativePath) => {
        const absoluteSourcePath = path_1.default.join(srcRootPath, relativePath);
        const readStream = support_1.fs.createReadStream(absoluteSourcePath, { autoClose: true });
        const absoluteDestinationPath = path_1.default.join(dstRootPath, relativePath);
        const writeStream = await afcService.createWriteStream(absoluteDestinationPath, {
            autoDestroy: true,
        });
        writeStream.on('finish', writeStream.destroy);
        let pushError = null;
        const filePushPromise = new bluebird_1.default((resolve, reject) => {
            writeStream.on('close', () => {
                if (pushError) {
                    reject(pushError);
                }
                else {
                    resolve();
                }
            });
            const onStreamError = (e) => {
                readStream.unpipe(writeStream);
                logger_1.default.debug(e);
                pushError = e;
            };
            writeStream.on('error', onStreamError);
            readStream.on('error', onStreamError);
        });
        readStream.pipe(writeStream);
        await filePushPromise.timeout(Math.max(timeoutMs - timer.getDuration().asMilliSeconds, 60000));
    };
    if (enableParallelPush) {
        logger_1.default.debug(`Proceeding to parallel files push (max ${MAX_IO_CHUNK_SIZE} writers)`);
        const pushPromises = [];
        for (const relativeFilePath of filesToPush) {
            pushPromises.push(bluebird_1.default.resolve(_pushFile(relativeFilePath)));
            // keep the push queue filled
            if (pushPromises.length >= MAX_IO_CHUNK_SIZE) {
                await bluebird_1.default.any(pushPromises);
                const elapsedMs = timer.getDuration().asMilliSeconds;
                if (elapsedMs > timeoutMs) {
                    throw new bluebird_1.TimeoutError(`Timed out after ${elapsedMs} ms`);
                }
            }
            for (let i = pushPromises.length - 1; i >= 0; i--) {
                if (pushPromises[i].isFulfilled()) {
                    pushPromises.splice(i, 1);
                }
            }
        }
        if (!lodash_1.default.isEmpty(pushPromises)) {
            const remainingPromises = pushPromises.filter((p) => !p.isFulfilled());
            if (remainingPromises.length > 0) {
                await bluebird_1.default.all(remainingPromises).timeout(Math.max(timeoutMs - timer.getDuration().asMilliSeconds, 60000));
            }
        }
    }
    else {
        logger_1.default.debug(`Proceeding to serial files push`);
        for (const relativeFilePath of filesToPush) {
            await _pushFile(relativeFilePath);
            const elapsedMs = timer.getDuration().asMilliSeconds;
            if (elapsedMs > timeoutMs) {
                throw new bluebird_1.TimeoutError(`Timed out after ${elapsedMs} ms`);
            }
        }
    }
    logger_1.default.debug(`Successfully pushed ${support_1.util.pluralize('folder', foldersToPush.length, true)} ` +
        `and ${support_1.util.pluralize('file', filesToPush.length, true)} ` +
        `within ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
}
//#endregion
//#region Public Device Connection Functions
/**
 * Get list of connected devices
 */
async function getConnectedDevices() {
    if (['yes', 'true', '1'].includes(lodash_1.default.toLower(process.env.APPIUM_XCUITEST_PREFER_DEVICECTL))) {
        return (await new node_devicectl_1.Devicectl('').listDevices())
            .map(({ hardwareProperties }) => hardwareProperties?.udid)
            .filter(Boolean);
    }
    return await appium_ios_device_1.utilities.getConnectedDevices();
}
//#endregion
//#region Public Real Device Class
class RealDevice {
    udid;
    _log;
    devicectl;
    constructor(udid, logger) {
        this.udid = udid;
        this._log = logger ?? logger_1.default;
        this.devicectl = new node_devicectl_1.Devicectl(this.udid);
    }
    get log() {
        return this._log;
    }
    async remove(bundleId) {
        const service = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        try {
            await service.uninstallApplication(bundleId);
        }
        finally {
            service.close();
        }
    }
    async removeApp(bundleId) {
        await this.remove(bundleId);
    }
    async install(appPath, bundleId, opts = {}) {
        const { timeoutMs = exports.IO_TIMEOUT_MS, } = opts;
        const timer = new support_1.timing.Timer().start();
        const afcService = await appium_ios_device_1.services.startAfcService(this.udid);
        try {
            let bundlePathOnPhone;
            if ((await support_1.fs.stat(appPath)).isFile()) {
                // https://github.com/doronz88/pymobiledevice3/blob/6ff5001f5776e03b610363254e82d7fbcad4ef5f/pymobiledevice3/services/installation_proxy.py#L75
                bundlePathOnPhone = `/${path_1.default.basename(appPath)}`;
                await pushFile(afcService, appPath, bundlePathOnPhone, {
                    timeoutMs,
                });
            }
            else {
                bundlePathOnPhone = `${INSTALLATION_STAGING_DIR}/${bundleId}`;
                await pushFolder(afcService, appPath, bundlePathOnPhone, {
                    enableParallelPush: true,
                    timeoutMs,
                });
            }
            await this.installOrUpgradeApplication(bundlePathOnPhone, {
                timeout: Math.max(timeoutMs - timer.getDuration().asMilliSeconds, 60000),
                isUpgrade: await this.isAppInstalled(bundleId),
            });
        }
        catch (err) {
            this.log.debug(err.stack);
            let errMessage = `Cannot install the ${bundleId} application`;
            if (err instanceof bluebird_1.TimeoutError) {
                errMessage += `. Consider increasing the value of 'appPushTimeout' capability (the current value equals to ${timeoutMs}ms)`;
            }
            errMessage += `. Original error: ${err.message}`;
            throw new Error(errMessage);
        }
        finally {
            afcService.close();
        }
        this.log.info(`The installation of '${bundleId}' succeeded after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
    }
    async installOrUpgradeApplication(bundlePathOnPhone, opts) {
        const { isUpgrade, timeout } = opts;
        const notificationService = await appium_ios_device_1.services.startNotificationProxyService(this.udid);
        const installationService = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        const appInstalledNotification = new bluebird_1.default((resolve) => {
            notificationService.observeNotification(APPLICATION_INSTALLED_NOTIFICATION, {
                notification: resolve,
            });
        });
        const clientOptions = { PackageType: 'Developer' };
        try {
            if (isUpgrade) {
                this.log.debug(`An upgrade of the existing application is going to be performed. ` +
                    `Will timeout in ${timeout.toFixed(0)} ms`);
                await installationService.upgradeApplication(bundlePathOnPhone, clientOptions, timeout);
            }
            else {
                this.log.debug(`A new application installation is going to be performed. ` +
                    `Will timeout in ${timeout.toFixed(0)} ms`);
                await installationService.installApplication(bundlePathOnPhone, clientOptions, timeout);
            }
            try {
                await appInstalledNotification.timeout(APPLICATION_NOTIFICATION_TIMEOUT_MS, `Could not get the application installed notification within ` +
                    `${APPLICATION_NOTIFICATION_TIMEOUT_MS}ms but we will continue`);
            }
            catch (e) {
                this.log.warn(e.message);
            }
        }
        finally {
            installationService.close();
            notificationService.close();
        }
    }
    /**
     * Alias for {@linkcode install}
     */
    async installApp(appPath, bundleId, opts = {}) {
        return await this.install(appPath, bundleId, opts);
    }
    /**
     * Return an application object if test app has 'bundleid'.
     * The target bundleid can be User and System apps.
     *
     * @param bundleId The bundleId to ensure it is installed
     * @returns Returns True if the app is installed on the device under test.
     */
    async isAppInstalled(bundleId) {
        return Boolean(await this.fetchAppInfo(bundleId));
    }
    /**
     * Fetches various attributes, like bundle id, version, entitlements etc. of
     * an installed application.
     *
     * @param bundleId the bundle identifier of an app to check
     * @param returnAttributes If provided then
     * only fetches the requested attributes of the app into the resulting object.
     * Some apps may have too many attributes, so it makes sense to limit these
     * by default if you don't need all of them.
     * @returns Either app info as an object or undefined if the app is not found.
     */
    async fetchAppInfo(bundleId, returnAttributes = ['CFBundleIdentifier', 'CFBundleVersion']) {
        const service = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        try {
            return (await service.lookupApplications({
                bundleIds: bundleId,
                // https://github.com/appium/appium/issues/18753
                returnAttributes,
            }))[bundleId];
        }
        finally {
            service.close();
        }
    }
    async terminateApp(bundleId, platformVersion) {
        let instrumentService;
        let installProxyService;
        try {
            installProxyService = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
            const apps = await installProxyService.listApplications({
                returnAttributes: ['CFBundleIdentifier', 'CFBundleExecutable']
            });
            if (!apps[bundleId]) {
                this.log.info(`The bundle id '${bundleId}' did not exist`);
                return false;
            }
            const executableName = apps[bundleId].CFBundleExecutable;
            this.log.debug(`The executable name for the bundle id '${bundleId}' was '${executableName}'`);
            // 'devicectl' has overhead (generally?) than the instrument service via appium-ios-device,
            // so hre uses the 'devicectl' only for iOS 17+.
            if (support_1.util.compareVersions(platformVersion, '>=', '17.0')) {
                this.log.debug(`Calling devicectl to kill the process`);
                const pids = (await this.devicectl.listProcesses())
                    .filter(({ executable }) => executable.endsWith(`/${executableName}`))
                    .map(({ processIdentifier }) => processIdentifier);
                if (lodash_1.default.isEmpty(pids)) {
                    this.log.info(`The process of the bundle id '${bundleId}' was not running`);
                    return false;
                }
                await this.devicectl.sendSignalToProcess(pids[0], 2);
            }
            else {
                instrumentService = await appium_ios_device_1.services.startInstrumentService(this.udid);
                // The result of "runningProcesses" includes `bundle_id` key in iOS 16+ (possibly a specific 16.x+)
                // then here may not be necessary to find a process with `CFBundleExecutable`
                // after dropping older iOS version support.
                const processes = await instrumentService.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.DEVICE_INFO, 'runningProcesses');
                const process = processes.selector.find((process) => process.name === executableName);
                if (!process) {
                    this.log.info(`The process of the bundle id '${bundleId}' was not running`);
                    return false;
                }
                await instrumentService.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.PROCESS_CONTROL, 'killPid:', `${process.pid}`);
            }
        }
        catch (err) {
            this.log.warn(`Failed to kill '${bundleId}'. Original error: ${err.stderr || err.message}`);
            return false;
        }
        finally {
            if (installProxyService) {
                installProxyService.close();
            }
            if (instrumentService) {
                instrumentService.close();
            }
        }
        return true;
    }
    /**
     * @param bundleName The name of CFBundleName in Info.plist
     *
     * @returns A list of User level apps' bundle ids which has
     *                          'CFBundleName' attribute as 'bundleName'.
     */
    async getUserInstalledBundleIdsByBundleName(bundleName) {
        const service = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        try {
            const applications = await service.listApplications({
                applicationType: 'User', returnAttributes: ['CFBundleIdentifier', 'CFBundleName']
            });
            return lodash_1.default.reduce(applications, (acc, { CFBundleName }, key) => {
                if (CFBundleName === bundleName) {
                    acc.push(key);
                }
                return acc;
            }, []);
        }
        finally {
            service.close();
        }
    }
    async getPlatformVersion() {
        return await appium_ios_device_1.utilities.getOSVersion(this.udid);
    }
    async reset(opts) {
        const { bundleId, fullReset } = opts;
        if (!bundleId || !fullReset || bundleId === app_utils_1.SAFARI_BUNDLE_ID) {
            // Safari cannot be removed as system app.
            // Safari process handling will be managed by WDA
            // with noReset, forceAppLaunch or shouldTerminateApp capabilities.
            return;
        }
        this.log.debug(`Reset: fullReset requested. Will try to uninstall the app '${bundleId}'.`);
        if (!(await this.isAppInstalled(bundleId))) {
            this.log.debug('Reset: app not installed. No need to uninstall');
            return;
        }
        try {
            await this.remove(bundleId);
        }
        catch (err) {
            this.log.error(`Reset: could not remove '${bundleId}' from device: ${err.message}`);
            throw err;
        }
        this.log.debug(`Reset: removed '${bundleId}'`);
    }
}
exports.RealDevice = RealDevice;
//#endregion
//#region Public Device Management Functions
/**
 * Install app to real device
 */
async function installToRealDevice(app, bundleId, opts = {}) {
    const device = this.device;
    if (!device.udid || !app || !bundleId) {
        this.log.debug('No device id, app or bundle id, not installing to real device.');
        return;
    }
    const { skipUninstall, timeout = DEFAULT_APP_INSTALLATION_TIMEOUT_MS, } = opts;
    if (!skipUninstall) {
        this.log.info(`Reset requested. Removing app with id '${bundleId}' from the device`);
        await device.remove(bundleId);
    }
    this.log.debug(`Installing '${app}' on the device with UUID '${device.udid}'`);
    try {
        await device.install(app, bundleId, {
            timeoutMs: timeout,
        });
        this.log.debug('The app has been installed successfully.');
    }
    catch (e) {
        // Want to clarify the device's application installation state in this situation.
        if (!skipUninstall || !e.message.includes('MismatchedApplicationIdentifierEntitlement')) {
            // Other error cases that could not be recoverable by here.
            // Exact error will be in the log.
            // We cannot recover 'ApplicationVerificationFailed' situation since this reason is clearly the app's provisioning profile was invalid.
            // [XCUITest] Error installing app '/path/to.app': Unexpected data: {"Error":"ApplicationVerificationFailed","ErrorDetail":-402620395,"ErrorDescription":"Failed to verify code signature of /path/to.app : 0xe8008015 (A valid provisioning profile for this executable was not found.)"}
            throw e;
        }
        // If the error was by below error case, we could recover the situation
        // by uninstalling the device's app bundle id explicitly regard less the app exists on the device or not (e.g. offload app).
        // [XCUITest] Error installing app '/path/to.app': Unexpected data: {"Error":"MismatchedApplicationIdentifierEntitlement","ErrorDescription":"Upgrade's application-identifier entitlement string (TEAM_ID.com.kazucocoa.example) does not match installed application's application-identifier string (ANOTHER_TEAM_ID.com.kazucocoa.example); rejecting upgrade."}
        this.log.info(`The application identified by '${bundleId}' cannot be installed because it might ` +
            `be already cached on the device, probably with a different signature. ` +
            `Will try to remove it and install a new copy. Original error: ${e.message}`);
        await device.remove(bundleId);
        await device.install(app, bundleId, {
            timeoutMs: timeout,
        });
        this.log.debug('The app has been installed after one retrial.');
    }
}
/**
 * Run real device reset
 */
async function runRealDeviceReset() {
    if (!this.opts.noReset || this.opts.fullReset) {
        this.log.debug('Reset: running ios real device reset flow');
        if (!this.opts.noReset) {
            await this.device.reset(this.opts);
        }
    }
    else {
        this.log.debug('Reset: fullReset not set. Leaving as is');
    }
}
/**
 * Configures Safari startup options based on the given session capabilities.
 *
 * !!! This method mutates driver options.
 *
 * @returns true if process arguments have been modified
 */
function applySafariStartupArgs() {
    const prefs = (0, app_utils_1.buildSafariPreferences)(this.opts);
    if (lodash_1.default.isEmpty(prefs)) {
        return false;
    }
    const args = lodash_1.default.toPairs(prefs)
        .flatMap(([key, value]) => [lodash_1.default.startsWith(key, '-') ? key : `-${key}`, String(value)]);
    logger_1.default.debug(`Generated Safari command line arguments: ${args.join(' ')}`);
    const processArguments = this.opts.processArguments;
    if (processArguments && lodash_1.default.isPlainObject(processArguments)) {
        processArguments.args = [...(processArguments.args ?? []), ...args];
    }
    else {
        this.opts.processArguments = { args };
    }
    return true;
}
/**
 * Auto-detect device UDID
 */
async function detectUdid() {
    this.log.debug('Auto-detecting real device udid...');
    const udids = await getConnectedDevices();
    if (lodash_1.default.isEmpty(udids)) {
        throw new Error('No real devices are connected to the host');
    }
    const udid = udids[udids.length - 1];
    if (udids.length > 1) {
        this.log.info(`Multiple devices found: ${udids.join(', ')}`);
        this.log.info(`Choosing '${udid}'. Consider settings the 'udid' capability if another device must be selected`);
    }
    this.log.debug(`Detected real device udid: '${udid}'`);
    return udid;
}
//#endregion
//#region Private Helper Functions
/**
 * Checks a presence of a local folder.
 *
 * @param folderPath Full path to the local folder
 * @returns True if the folder exists and is actually a folder
 */
async function folderExists(folderPath) {
    try {
        return (await support_1.fs.stat(folderPath)).isDirectory();
    }
    catch {
        return false;
    }
}
/**
 * Creates remote folder path recursively. Noop if the given path
 * already exists
 *
 * @param afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param remoteRoot The relative path to the remote folder structure
 * to be created
 */
async function remoteMkdirp(afcService, remoteRoot) {
    if (remoteRoot === '.' || remoteRoot === '/') {
        return;
    }
    try {
        await afcService.listDirectory(remoteRoot);
        return;
    }
    catch {
        // This means that the directory is missing and we got an object not found error.
        // Therefore, we are going to the parent
        await remoteMkdirp(afcService, path_1.default.dirname(remoteRoot));
    }
    await afcService.createDirectory(remoteRoot);
}
//#endregion
//# sourceMappingURL=real-device-management.js.map