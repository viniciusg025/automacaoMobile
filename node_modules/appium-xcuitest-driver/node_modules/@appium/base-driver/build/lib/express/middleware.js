"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleIdempotency = void 0;
exports.allowCrossDomain = allowCrossDomain;
exports.allowCrossDomainAsyncExecute = allowCrossDomainAsyncExecute;
exports.handleLogContext = handleLogContext;
exports.defaultToJSONContentType = defaultToJSONContentType;
exports.tryHandleWebSocketUpgrade = tryHandleWebSocketUpgrade;
exports.handleUpgrade = handleUpgrade;
exports.catchAllHandler = catchAllHandler;
exports.catch404Handler = catch404Handler;
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = __importDefault(require("./logger"));
const protocol_1 = require("../protocol");
var idempotency_1 = require("./idempotency");
Object.defineProperty(exports, "handleIdempotency", { enumerable: true, get: function () { return idempotency_1.handleIdempotency; } });
const path_to_regexp_1 = require("path-to-regexp");
const support_1 = require("@appium/support");
const session_1 = require("../helpers/session");
const errors_1 = require("../protocol/errors");
const SESSION_ID_PATTERN = /\/session\/([^/]+)/;
/**
 *
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 * @param {import('express').NextFunction} next
 * @returns {any}
 */
function allowCrossDomain(req, res, next) {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, OPTIONS, DELETE');
    res.header('Access-Control-Allow-Headers', 'Cache-Control, Pragma, Origin, X-Requested-With, Content-Type, Accept, User-Agent');
    // need to respond 200 to OPTIONS
    if ('OPTIONS' === req.method) {
        return res.sendStatus(200);
    }
    next();
}
/**
 * @param {string} basePath
 * @returns {import('express').RequestHandler}
 */
function allowCrossDomainAsyncExecute(basePath) {
    return (req, res, next) => {
        // there are two paths for async responses, so cover both
        // https://regex101.com/r/txYiEz/1
        const receiveAsyncResponseRegExp = new RegExp(`${lodash_1.default.escapeRegExp(basePath)}/session/[a-f0-9-]+/(appium/)?receive_async_response`);
        if (!receiveAsyncResponseRegExp.test(req.url)) {
            return next();
        }
        allowCrossDomain(req, res, next);
    };
}
/**
 *
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 * @param {import('express').NextFunction} next
 * @returns {any}
 */
function handleLogContext(req, res, next) {
    const requestId = fetchHeaderValue(req, 'x-request-id') || support_1.util.uuidV4();
    const sessionId = SESSION_ID_PATTERN.exec(req.url)?.[1];
    const sessionInfo = sessionId ? { sessionId, sessionSignature: (0, session_1.calcSignature)(sessionId) } : {};
    const isSensitiveHeaderValue = fetchHeaderValue(req, 'x-appium-is-sensitive');
    logger_1.default.updateAsyncContext({
        requestId,
        ...sessionInfo,
        isSensitive: ['true', '1', 'yes'].includes(lodash_1.default.toLower(isSensitiveHeaderValue)),
    }, true);
    return next();
}
/**
 *
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 * @param {import('express').NextFunction} next
 * @returns {any}
 */
function defaultToJSONContentType(req, res, next) {
    if (!req.headers['content-type']) {
        req.headers['content-type'] = 'application/json; charset=utf-8';
    }
    next();
}
/**
 * Core function to handle WebSocket upgrade requests by matching the request path
 * against registered WebSocket handlers in the webSocketsMapping.
 *
 * @param {import('http').IncomingMessage} req - The HTTP request
 * @param {import('stream').Duplex} socket - The network socket
 * @param {Buffer} head - The first packet of the upgraded stream
 * @param {import('@appium/types').StringRecord<import('@appium/types').WSServer>} webSocketsMapping - Mapping of paths to WebSocket servers
 * @returns {boolean} - Returns true if the upgrade was handled, false otherwise
 */
function tryHandleWebSocketUpgrade(req, socket, head, webSocketsMapping) {
    if (lodash_1.default.toLower(req.headers?.upgrade) !== 'websocket') {
        return false;
    }
    let currentPathname;
    try {
        currentPathname = new URL(req.url ?? '', 'http://localhost').pathname;
    }
    catch {
        currentPathname = req.url ?? '';
    }
    for (const [pathname, wsServer] of lodash_1.default.toPairs(webSocketsMapping)) {
        if ((0, path_to_regexp_1.match)(pathname)(currentPathname)) {
            wsServer.handleUpgrade(req, socket, head, (ws) => {
                wsServer.emit('connection', ws, req);
            });
            return true;
        }
    }
    logger_1.default.info(`Did not match the websocket upgrade request at ${currentPathname} to any known route`);
    return false;
}
/**
 *
 * @param {import('@appium/types').StringRecord<import('@appium/types').WSServer>} webSocketsMapping
 * @returns {import('express').RequestHandler}
 */
function handleUpgrade(webSocketsMapping) {
    return (req, res, next) => {
        if (tryHandleWebSocketUpgrade(req, req.socket, Buffer.from(''), webSocketsMapping)) {
            return;
        }
        next();
    };
}
/**
 * @param {Error} err
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 * @param {import('express').NextFunction} next
 */
function catchAllHandler(err, req, res, next) {
    if (res.headersSent) {
        return next(err);
    }
    logger_1.default.error(`Uncaught error: ${err.message}`);
    const [status, body] = (0, errors_1.getResponseForW3CError)(err);
    res.status(status).json(body);
}
/**
 * @param {import('express').Request} req
 * @param {import('express').Response} res
 */
function catch404Handler(req, res) {
    logger_1.default.debug(`No route found for ${req.url}`);
    const [status, body] = (0, errors_1.getResponseForW3CError)(new protocol_1.errors.UnknownCommandError());
    res.status(status).json(body);
}
/**
 * @param {import('express').Request} req
 * @param {string} name
 * @returns {string | undefined}
 */
function fetchHeaderValue(req, name) {
    return lodash_1.default.isArray(req.headers[name])
        ? req.headers[name][0]
        : req.headers[name];
}
//# sourceMappingURL=middleware.js.map